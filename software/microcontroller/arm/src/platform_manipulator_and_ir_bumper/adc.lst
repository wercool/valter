   1              		.file	"adc.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	InitADC
  13              	InitADC:
  14              	.LFB2:
  15              		.file 1 "adc.c"
   1:adc.c         **** #include "adc.h"
   2:adc.c         **** 
   3:adc.c         **** AT91PS_ADC a_pADC = AT91C_BASE_ADC;
   4:adc.c         **** AT91PS_PMC a_pPMC = AT91C_BASE_PMC;
   5:adc.c         **** 
   6:adc.c         **** #define ADC_CHN_0  0x01
   7:adc.c         **** #define ADC_CHN_1  0x02
   8:adc.c         **** #define ADC_CHN_2  0x04
   9:adc.c         **** #define ADC_CHN_3  0x08
  10:adc.c         **** #define ADC_CHN_4  0x10
  11:adc.c         **** #define ADC_CHN_5  0x20
  12:adc.c         **** #define ADC_CHN_6  0x40
  13:adc.c         **** #define ADC_CHN_7  0x80
  14:adc.c         **** 
  15:adc.c         **** void InitADC(void)
  16:adc.c         **** {
  16              		.loc 1 16 0
  17              		@ Function supports interworking.
  18              		@ args = 0, pretend = 0, frame = 0
  19              		@ frame_needed = 0, uses_anonymous_args = 0
  20              		@ link register save eliminated.
  17:adc.c         ****     // enable clock frequency for ADC
  18:adc.c         ****     a_pPMC->PMC_PCER = 1 << AT91C_ID_ADC;
  21              		.loc 1 18 0
  22 0000 38309FE5 		ldr	r3, .L3
  23 0004 001093E5 		ldr	r1, [r3, #0]
  19:adc.c         **** 
  20:adc.c         ****     // reset ADC
  21:adc.c         ****     a_pADC->ADC_CR = 0x1;
  24              		.loc 1 21 0
  25 0008 34309FE5 		ldr	r3, .L3+4
  26 000c 002093E5 		ldr	r2, [r3, #0]
  27              		.loc 1 18 0
  28 0010 1000A0E3 		mov	r0, #16
  29              		.loc 1 21 0
  30 0014 0130A0E3 		mov	r3, #1
  31              		.loc 1 18 0
  32 0018 100081E5 		str	r0, [r1, #16]
  33              		.loc 1 21 0
  34 001c 003082E5 		str	r3, [r2, #0]
  22:adc.c         ****     a_pADC->ADC_CR = 0x0;
  35              		.loc 1 22 0
  36 0020 0030A0E3 		mov	r3, #0
  37 0024 003082E5 		str	r3, [r2, #0]
  23:adc.c         **** 
  24:adc.c         ****     // max for startup time Ð¸ hold time
  25:adc.c         ****     a_pADC->ADC_MR = 0x0F1F0F00;
  38              		.loc 1 25 0
  39 0028 18309FE5 		ldr	r3, .L3+8
  40 002c 043082E5 		str	r3, [r2, #4]
  26:adc.c         **** 
  27:adc.c         ****     // enable all needed channels
  28:adc.c         ****     //a_pADC->ADC_CHER = AT91C_ADC_CH0;
  29:adc.c         ****     //a_pADC->ADC_CHER = AT91C_ADC_CH1;
  30:adc.c         ****     //a_pADC->ADC_CHER = AT91C_ADC_CH2;
  31:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH4;
  32:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH5;
  41              		.loc 1 32 0
  42 0030 2030A0E3 		mov	r3, #32
  43              		.loc 1 31 0
  44 0034 100082E5 		str	r0, [r2, #16]
  45              		.loc 1 16 0
  46              		@ lr needed for prologue
  47              		.loc 1 32 0
  48 0038 103082E5 		str	r3, [r2, #16]
  33:adc.c         ****     //a_pADC->ADC_CHER = AT91C_ADC_CH6;
  34:adc.c         **** }
  49              		.loc 1 34 0
  50 003c 1EFF2FE1 		bx	lr
  51              	.L4:
  52              		.align	2
  53              	.L3:
  54 0040 00000000 		.word	a_pPMC
  55 0044 00000000 		.word	a_pADC
  56 0048 000F1F0F 		.word	253693696
  57              	.LFE2:
  59              		.align	2
  60              		.global	getValueChannel0
  62              	getValueChannel0:
  63              	.LFB3:
  35:adc.c         **** 
  36:adc.c         **** unsigned int getValueChannel0()
  37:adc.c         **** {
  64              		.loc 1 37 0
  65              		@ Function supports interworking.
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  38:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
  69              		.loc 1 38 0
  70 004c 1C309FE5 		ldr	r3, .L11
  71 0050 002093E5 		ldr	r2, [r3, #0]
  72 0054 0230A0E3 		mov	r3, #2
  73 0058 003082E5 		str	r3, [r2, #0]
  74              		.loc 1 37 0
  75              		@ lr needed for prologue
  76              	.L6:
  39:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_0)); //wait until conversion complete
  77              		.loc 1 39 0
  78 005c 1C3092E5 		ldr	r3, [r2, #28]
  79 0060 010013E3 		tst	r3, #1
  80 0064 1500000A 		beq	.L6
  40:adc.c         ****   return a_pADC->ADC_CDR0;
  81              		.loc 1 40 0
  82 0068 300092E5 		ldr	r0, [r2, #48]
  41:adc.c         **** }
  83              		.loc 1 41 0
  84 006c 1EFF2FE1 		bx	lr
  85              	.L12:
  86              		.align	2
  87              	.L11:
  88 0070 00000000 		.word	a_pADC
  89              	.LFE3:
  91              		.align	2
  92              		.global	getValueChannel1
  94              	getValueChannel1:
  95              	.LFB4:
  42:adc.c         **** 
  43:adc.c         **** unsigned int getValueChannel1()
  44:adc.c         **** {
  96              		.loc 1 44 0
  97              		@ Function supports interworking.
  98              		@ args = 0, pretend = 0, frame = 0
  99              		@ frame_needed = 0, uses_anonymous_args = 0
 100              		@ link register save eliminated.
  45:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 101              		.loc 1 45 0
 102 0074 1C309FE5 		ldr	r3, .L19
 103 0078 002093E5 		ldr	r2, [r3, #0]
 104 007c 0230A0E3 		mov	r3, #2
 105 0080 003082E5 		str	r3, [r2, #0]
 106              		.loc 1 44 0
 107              		@ lr needed for prologue
 108              	.L14:
  46:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_1)); //wait until conversion complete
 109              		.loc 1 46 0
 110 0084 1C3092E5 		ldr	r3, [r2, #28]
 111 0088 020013E3 		tst	r3, #2
 112 008c 1F00000A 		beq	.L14
  47:adc.c         ****   return a_pADC->ADC_CDR1;
 113              		.loc 1 47 0
 114 0090 340092E5 		ldr	r0, [r2, #52]
  48:adc.c         **** }
 115              		.loc 1 48 0
 116 0094 1EFF2FE1 		bx	lr
 117              	.L20:
 118              		.align	2
 119              	.L19:
 120 0098 00000000 		.word	a_pADC
 121              	.LFE4:
 123              		.align	2
 124              		.global	getValueChannel2
 126              	getValueChannel2:
 127              	.LFB5:
  49:adc.c         **** 
  50:adc.c         **** unsigned int getValueChannel2()
  51:adc.c         **** {
 128              		.loc 1 51 0
 129              		@ Function supports interworking.
 130              		@ args = 0, pretend = 0, frame = 0
 131              		@ frame_needed = 0, uses_anonymous_args = 0
 132              		@ link register save eliminated.
  52:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 133              		.loc 1 52 0
 134 009c 1C309FE5 		ldr	r3, .L27
 135 00a0 002093E5 		ldr	r2, [r3, #0]
 136 00a4 0230A0E3 		mov	r3, #2
 137 00a8 003082E5 		str	r3, [r2, #0]
 138              		.loc 1 51 0
 139              		@ lr needed for prologue
 140              	.L22:
  53:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_2)); //wait until conversion complete
 141              		.loc 1 53 0
 142 00ac 1C3092E5 		ldr	r3, [r2, #28]
 143 00b0 040013E3 		tst	r3, #4
 144 00b4 2900000A 		beq	.L22
  54:adc.c         ****   return a_pADC->ADC_CDR2;
 145              		.loc 1 54 0
 146 00b8 380092E5 		ldr	r0, [r2, #56]
  55:adc.c         **** }
 147              		.loc 1 55 0
 148 00bc 1EFF2FE1 		bx	lr
 149              	.L28:
 150              		.align	2
 151              	.L27:
 152 00c0 00000000 		.word	a_pADC
 153              	.LFE5:
 155              		.align	2
 156              		.global	getValueChannel4
 158              	getValueChannel4:
 159              	.LFB6:
  56:adc.c         **** 
  57:adc.c         **** unsigned int getValueChannel4()
  58:adc.c         **** {
 160              		.loc 1 58 0
 161              		@ Function supports interworking.
 162              		@ args = 0, pretend = 0, frame = 0
 163              		@ frame_needed = 0, uses_anonymous_args = 0
 164              		@ link register save eliminated.
  59:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 165              		.loc 1 59 0
 166 00c4 1C309FE5 		ldr	r3, .L35
 167 00c8 002093E5 		ldr	r2, [r3, #0]
 168 00cc 0230A0E3 		mov	r3, #2
 169 00d0 003082E5 		str	r3, [r2, #0]
 170              		.loc 1 58 0
 171              		@ lr needed for prologue
 172              	.L30:
  60:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_4)); //wait until conversion complete
 173              		.loc 1 60 0
 174 00d4 1C3092E5 		ldr	r3, [r2, #28]
 175 00d8 100013E3 		tst	r3, #16
 176 00dc 3300000A 		beq	.L30
  61:adc.c         ****   return a_pADC->ADC_CDR4;
 177              		.loc 1 61 0
 178 00e0 400092E5 		ldr	r0, [r2, #64]
  62:adc.c         **** }
 179              		.loc 1 62 0
 180 00e4 1EFF2FE1 		bx	lr
 181              	.L36:
 182              		.align	2
 183              	.L35:
 184 00e8 00000000 		.word	a_pADC
 185              	.LFE6:
 187              		.align	2
 188              		.global	getValueChannel5
 190              	getValueChannel5:
 191              	.LFB7:
  63:adc.c         **** 
  64:adc.c         **** unsigned int getValueChannel5()
  65:adc.c         **** {
 192              		.loc 1 65 0
 193              		@ Function supports interworking.
 194              		@ args = 0, pretend = 0, frame = 0
 195              		@ frame_needed = 0, uses_anonymous_args = 0
 196              		@ link register save eliminated.
  66:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 197              		.loc 1 66 0
 198 00ec 1C309FE5 		ldr	r3, .L43
 199 00f0 002093E5 		ldr	r2, [r3, #0]
 200 00f4 0230A0E3 		mov	r3, #2
 201 00f8 003082E5 		str	r3, [r2, #0]
 202              		.loc 1 65 0
 203              		@ lr needed for prologue
 204              	.L38:
  67:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_5)); //wait until conversion complete
 205              		.loc 1 67 0
 206 00fc 1C3092E5 		ldr	r3, [r2, #28]
 207 0100 200013E3 		tst	r3, #32
 208 0104 3D00000A 		beq	.L38
  68:adc.c         ****   return a_pADC->ADC_CDR5;
 209              		.loc 1 68 0
 210 0108 440092E5 		ldr	r0, [r2, #68]
  69:adc.c         **** }
 211              		.loc 1 69 0
 212 010c 1EFF2FE1 		bx	lr
 213              	.L44:
 214              		.align	2
 215              	.L43:
 216 0110 00000000 		.word	a_pADC
 217              	.LFE7:
 219              		.align	2
 220              		.global	getValueChannel6
 222              	getValueChannel6:
 223              	.LFB8:
  70:adc.c         **** 
  71:adc.c         **** unsigned int getValueChannel6()
  72:adc.c         **** {
 224              		.loc 1 72 0
 225              		@ Function supports interworking.
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
  73:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 229              		.loc 1 73 0
 230 0114 1C309FE5 		ldr	r3, .L51
 231 0118 002093E5 		ldr	r2, [r3, #0]
 232 011c 0230A0E3 		mov	r3, #2
 233 0120 003082E5 		str	r3, [r2, #0]
 234              		.loc 1 72 0
 235              		@ lr needed for prologue
 236              	.L46:
  74:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_6)); //wait until conversion complete
 237              		.loc 1 74 0
 238 0124 1C3092E5 		ldr	r3, [r2, #28]
 239 0128 400013E3 		tst	r3, #64
 240 012c 4700000A 		beq	.L46
  75:adc.c         ****   return a_pADC->ADC_CDR6;
 241              		.loc 1 75 0
 242 0130 480092E5 		ldr	r0, [r2, #72]
  76:adc.c         **** }
 243              		.loc 1 76 0
 244 0134 1EFF2FE1 		bx	lr
 245              	.L52:
 246              		.align	2
 247              	.L51:
 248 0138 00000000 		.word	a_pADC
 249              	.LFE8:
 251              		.global	a_pADC
 252              		.data
 253              		.align	2
 256              	a_pADC:
 257 0000 0080FDFF 		.word	-163840
 258              		.global	a_pPMC
 259              		.align	2
 262              	a_pPMC:
 263 0004 00FCFFFF 		.word	-1024
 337              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/ccam2zej.s:13     .text:00000000 InitADC
     /tmp/ccam2zej.s:22     .text:00000000 $a
     /tmp/ccam2zej.s:54     .text:00000040 $d
     /tmp/ccam2zej.s:262    .data:00000004 a_pPMC
     /tmp/ccam2zej.s:256    .data:00000000 a_pADC
     /tmp/ccam2zej.s:62     .text:0000004c getValueChannel0
     /tmp/ccam2zej.s:70     .text:0000004c $a
     /tmp/ccam2zej.s:88     .text:00000070 $d
     /tmp/ccam2zej.s:94     .text:00000074 getValueChannel1
     /tmp/ccam2zej.s:102    .text:00000074 $a
     /tmp/ccam2zej.s:120    .text:00000098 $d
     /tmp/ccam2zej.s:126    .text:0000009c getValueChannel2
     /tmp/ccam2zej.s:134    .text:0000009c $a
     /tmp/ccam2zej.s:152    .text:000000c0 $d
     /tmp/ccam2zej.s:158    .text:000000c4 getValueChannel4
     /tmp/ccam2zej.s:166    .text:000000c4 $a
     /tmp/ccam2zej.s:184    .text:000000e8 $d
     /tmp/ccam2zej.s:190    .text:000000ec getValueChannel5
     /tmp/ccam2zej.s:198    .text:000000ec $a
     /tmp/ccam2zej.s:216    .text:00000110 $d
     /tmp/ccam2zej.s:222    .text:00000114 getValueChannel6
     /tmp/ccam2zej.s:230    .text:00000114 $a
     /tmp/ccam2zej.s:248    .text:00000138 $d
     /tmp/ccam2zej.s:257    .data:00000000 $d

NO UNDEFINED SYMBOLS
