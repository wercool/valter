   1              		.file	"adc.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	InitADC
  13              	InitADC:
  14              	.LFB2:
  15              		.file 1 "adc.c"
   1:adc.c         **** #include "adc.h"
   2:adc.c         **** 
   3:adc.c         **** AT91PS_ADC a_pADC = AT91C_BASE_ADC;
   4:adc.c         **** AT91PS_PMC a_pPMC = AT91C_BASE_PMC;
   5:adc.c         **** 
   6:adc.c         **** #define ADC_CHN_0  0x01
   7:adc.c         **** #define ADC_CHN_1  0x02
   8:adc.c         **** #define ADC_CHN_2  0x04
   9:adc.c         **** #define ADC_CHN_3  0x08
  10:adc.c         **** #define ADC_CHN_4  0x10
  11:adc.c         **** #define ADC_CHN_5  0x20
  12:adc.c         **** #define ADC_CHN_6  0x40
  13:adc.c         **** #define ADC_CHN_7  0x80
  14:adc.c         **** 
  15:adc.c         **** void InitADC(void)
  16:adc.c         **** {
  16              		.loc 1 16 0
  17              		@ Function supports interworking.
  18              		@ args = 0, pretend = 0, frame = 0
  19              		@ frame_needed = 0, uses_anonymous_args = 0
  20              		@ link register save eliminated.
  17:adc.c         ****     // enable clock frequency for ADC
  18:adc.c         ****     a_pPMC->PMC_PCER = 1 << AT91C_ID_ADC;
  21              		.loc 1 18 0
  22 0000 54309FE5 		ldr	r3, .L3
  23 0004 000093E5 		ldr	r0, [r3, #0]
  19:adc.c         **** 
  20:adc.c         ****     // reset ADC
  21:adc.c         ****     a_pADC->ADC_CR = 0x1;
  24              		.loc 1 21 0
  25 0008 50309FE5 		ldr	r3, .L3+4
  26 000c 002093E5 		ldr	r2, [r3, #0]
  27              		.loc 1 18 0
  28 0010 10C0A0E3 		mov	ip, #16
  29              		.loc 1 21 0
  30 0014 0110A0E3 		mov	r1, #1
  22:adc.c         ****     a_pADC->ADC_CR = 0x0;
  31              		.loc 1 22 0
  32 0018 0030A0E3 		mov	r3, #0
  33              		.loc 1 18 0
  34 001c 10C080E5 		str	ip, [r0, #16]
  35              		.loc 1 21 0
  36 0020 001082E5 		str	r1, [r2, #0]
  37              		.loc 1 22 0
  38 0024 003082E5 		str	r3, [r2, #0]
  23:adc.c         **** 
  24:adc.c         ****     // max for startup time Ð¸ hold time
  25:adc.c         ****     a_pADC->ADC_MR = 0x0F1F0F00;
  39              		.loc 1 25 0
  40 0028 34309FE5 		ldr	r3, .L3+8
  41 002c 043082E5 		str	r3, [r2, #4]
  26:adc.c         **** 
  27:adc.c         ****     // enable all needed channels
  28:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH0;
  29:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH1;
  42              		.loc 1 29 0
  43 0030 0230A0E3 		mov	r3, #2
  44              		.loc 1 28 0
  45 0034 101082E5 		str	r1, [r2, #16]
  46              		.loc 1 29 0
  47 0038 103082E5 		str	r3, [r2, #16]
  30:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH2;
  48              		.loc 1 30 0
  49 003c 033083E0 		add	r3, r3, r3
  50 0040 103082E5 		str	r3, [r2, #16]
  31:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH4;
  32:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH5;
  51              		.loc 1 32 0
  52 0044 1C3083E2 		add	r3, r3, #28
  53              		.loc 1 31 0
  54 0048 10C082E5 		str	ip, [r2, #16]
  55              		.loc 1 32 0
  56 004c 103082E5 		str	r3, [r2, #16]
  33:adc.c         ****     a_pADC->ADC_CHER = AT91C_ADC_CH6;
  57              		.loc 1 33 0
  58 0050 203083E2 		add	r3, r3, #32
  59              		.loc 1 16 0
  60              		@ lr needed for prologue
  61              		.loc 1 33 0
  62 0054 103082E5 		str	r3, [r2, #16]
  34:adc.c         **** }
  63              		.loc 1 34 0
  64 0058 1EFF2FE1 		bx	lr
  65              	.L4:
  66              		.align	2
  67              	.L3:
  68 005c 00000000 		.word	a_pPMC
  69 0060 00000000 		.word	a_pADC
  70 0064 000F1F0F 		.word	253693696
  71              	.LFE2:
  73              		.align	2
  74              		.global	getValueChannel0
  76              	getValueChannel0:
  77              	.LFB3:
  35:adc.c         **** 
  36:adc.c         **** unsigned int getValueChannel0()
  37:adc.c         **** {
  78              		.loc 1 37 0
  79              		@ Function supports interworking.
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              		@ link register save eliminated.
  38:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
  83              		.loc 1 38 0
  84 0068 1C309FE5 		ldr	r3, .L11
  85 006c 002093E5 		ldr	r2, [r3, #0]
  86 0070 0230A0E3 		mov	r3, #2
  87 0074 003082E5 		str	r3, [r2, #0]
  88              		.loc 1 37 0
  89              		@ lr needed for prologue
  90              	.L6:
  39:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_0)); //wait until conversion complete
  91              		.loc 1 39 0
  92 0078 1C3092E5 		ldr	r3, [r2, #28]
  93 007c 010013E3 		tst	r3, #1
  94 0080 1C00000A 		beq	.L6
  40:adc.c         ****   return a_pADC->ADC_CDR0;
  95              		.loc 1 40 0
  96 0084 300092E5 		ldr	r0, [r2, #48]
  41:adc.c         **** }
  97              		.loc 1 41 0
  98 0088 1EFF2FE1 		bx	lr
  99              	.L12:
 100              		.align	2
 101              	.L11:
 102 008c 00000000 		.word	a_pADC
 103              	.LFE3:
 105              		.align	2
 106              		.global	getValueChannel1
 108              	getValueChannel1:
 109              	.LFB4:
  42:adc.c         **** 
  43:adc.c         **** unsigned int getValueChannel1()
  44:adc.c         **** {
 110              		.loc 1 44 0
 111              		@ Function supports interworking.
 112              		@ args = 0, pretend = 0, frame = 0
 113              		@ frame_needed = 0, uses_anonymous_args = 0
 114              		@ link register save eliminated.
  45:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 115              		.loc 1 45 0
 116 0090 1C309FE5 		ldr	r3, .L19
 117 0094 002093E5 		ldr	r2, [r3, #0]
 118 0098 0230A0E3 		mov	r3, #2
 119 009c 003082E5 		str	r3, [r2, #0]
 120              		.loc 1 44 0
 121              		@ lr needed for prologue
 122              	.L14:
  46:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_1)); //wait until conversion complete
 123              		.loc 1 46 0
 124 00a0 1C3092E5 		ldr	r3, [r2, #28]
 125 00a4 020013E3 		tst	r3, #2
 126 00a8 2600000A 		beq	.L14
  47:adc.c         ****   return a_pADC->ADC_CDR1;
 127              		.loc 1 47 0
 128 00ac 340092E5 		ldr	r0, [r2, #52]
  48:adc.c         **** }
 129              		.loc 1 48 0
 130 00b0 1EFF2FE1 		bx	lr
 131              	.L20:
 132              		.align	2
 133              	.L19:
 134 00b4 00000000 		.word	a_pADC
 135              	.LFE4:
 137              		.align	2
 138              		.global	getValueChannel2
 140              	getValueChannel2:
 141              	.LFB5:
  49:adc.c         **** 
  50:adc.c         **** unsigned int getValueChannel2()
  51:adc.c         **** {
 142              		.loc 1 51 0
 143              		@ Function supports interworking.
 144              		@ args = 0, pretend = 0, frame = 0
 145              		@ frame_needed = 0, uses_anonymous_args = 0
 146              		@ link register save eliminated.
  52:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 147              		.loc 1 52 0
 148 00b8 1C309FE5 		ldr	r3, .L27
 149 00bc 002093E5 		ldr	r2, [r3, #0]
 150 00c0 0230A0E3 		mov	r3, #2
 151 00c4 003082E5 		str	r3, [r2, #0]
 152              		.loc 1 51 0
 153              		@ lr needed for prologue
 154              	.L22:
  53:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_2)); //wait until conversion complete
 155              		.loc 1 53 0
 156 00c8 1C3092E5 		ldr	r3, [r2, #28]
 157 00cc 040013E3 		tst	r3, #4
 158 00d0 3000000A 		beq	.L22
  54:adc.c         ****   return a_pADC->ADC_CDR2;
 159              		.loc 1 54 0
 160 00d4 380092E5 		ldr	r0, [r2, #56]
  55:adc.c         **** }
 161              		.loc 1 55 0
 162 00d8 1EFF2FE1 		bx	lr
 163              	.L28:
 164              		.align	2
 165              	.L27:
 166 00dc 00000000 		.word	a_pADC
 167              	.LFE5:
 169              		.align	2
 170              		.global	getValueChannel4
 172              	getValueChannel4:
 173              	.LFB6:
  56:adc.c         **** 
  57:adc.c         **** unsigned int getValueChannel4()
  58:adc.c         **** {
 174              		.loc 1 58 0
 175              		@ Function supports interworking.
 176              		@ args = 0, pretend = 0, frame = 0
 177              		@ frame_needed = 0, uses_anonymous_args = 0
 178              		@ link register save eliminated.
  59:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 179              		.loc 1 59 0
 180 00e0 1C309FE5 		ldr	r3, .L35
 181 00e4 002093E5 		ldr	r2, [r3, #0]
 182 00e8 0230A0E3 		mov	r3, #2
 183 00ec 003082E5 		str	r3, [r2, #0]
 184              		.loc 1 58 0
 185              		@ lr needed for prologue
 186              	.L30:
  60:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_4)); //wait until conversion complete
 187              		.loc 1 60 0
 188 00f0 1C3092E5 		ldr	r3, [r2, #28]
 189 00f4 100013E3 		tst	r3, #16
 190 00f8 3A00000A 		beq	.L30
  61:adc.c         ****   return a_pADC->ADC_CDR4;
 191              		.loc 1 61 0
 192 00fc 400092E5 		ldr	r0, [r2, #64]
  62:adc.c         **** }
 193              		.loc 1 62 0
 194 0100 1EFF2FE1 		bx	lr
 195              	.L36:
 196              		.align	2
 197              	.L35:
 198 0104 00000000 		.word	a_pADC
 199              	.LFE6:
 201              		.align	2
 202              		.global	getValueChannel5
 204              	getValueChannel5:
 205              	.LFB7:
  63:adc.c         **** 
  64:adc.c         **** unsigned int getValueChannel5()
  65:adc.c         **** {
 206              		.loc 1 65 0
 207              		@ Function supports interworking.
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              		@ link register save eliminated.
  66:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 211              		.loc 1 66 0
 212 0108 1C309FE5 		ldr	r3, .L43
 213 010c 002093E5 		ldr	r2, [r3, #0]
 214 0110 0230A0E3 		mov	r3, #2
 215 0114 003082E5 		str	r3, [r2, #0]
 216              		.loc 1 65 0
 217              		@ lr needed for prologue
 218              	.L38:
  67:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_5)); //wait until conversion complete
 219              		.loc 1 67 0
 220 0118 1C3092E5 		ldr	r3, [r2, #28]
 221 011c 200013E3 		tst	r3, #32
 222 0120 4400000A 		beq	.L38
  68:adc.c         ****   return a_pADC->ADC_CDR5;
 223              		.loc 1 68 0
 224 0124 440092E5 		ldr	r0, [r2, #68]
  69:adc.c         **** }
 225              		.loc 1 69 0
 226 0128 1EFF2FE1 		bx	lr
 227              	.L44:
 228              		.align	2
 229              	.L43:
 230 012c 00000000 		.word	a_pADC
 231              	.LFE7:
 233              		.align	2
 234              		.global	getValueChannel6
 236              	getValueChannel6:
 237              	.LFB8:
  70:adc.c         **** 
  71:adc.c         **** unsigned int getValueChannel6()
  72:adc.c         **** {
 238              		.loc 1 72 0
 239              		@ Function supports interworking.
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
  73:adc.c         ****   a_pADC->ADC_CR = 0x2; // set Start Bit
 243              		.loc 1 73 0
 244 0130 1C309FE5 		ldr	r3, .L51
 245 0134 002093E5 		ldr	r2, [r3, #0]
 246 0138 0230A0E3 		mov	r3, #2
 247 013c 003082E5 		str	r3, [r2, #0]
 248              		.loc 1 72 0
 249              		@ lr needed for prologue
 250              	.L46:
  74:adc.c         ****   while(!(a_pADC->ADC_SR & ADC_CHN_6)); //wait until conversion complete
 251              		.loc 1 74 0
 252 0140 1C3092E5 		ldr	r3, [r2, #28]
 253 0144 400013E3 		tst	r3, #64
 254 0148 4E00000A 		beq	.L46
  75:adc.c         ****   return a_pADC->ADC_CDR6;
 255              		.loc 1 75 0
 256 014c 480092E5 		ldr	r0, [r2, #72]
  76:adc.c         **** }
 257              		.loc 1 76 0
 258 0150 1EFF2FE1 		bx	lr
 259              	.L52:
 260              		.align	2
 261              	.L51:
 262 0154 00000000 		.word	a_pADC
 263              	.LFE8:
 265              		.global	a_pADC
 266              		.data
 267              		.align	2
 270              	a_pADC:
 271 0000 0080FDFF 		.word	-163840
 272              		.global	a_pPMC
 273              		.align	2
 276              	a_pPMC:
 277 0004 00FCFFFF 		.word	-1024
 351              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/ccYQhF14.s:13     .text:00000000 InitADC
     /tmp/ccYQhF14.s:22     .text:00000000 $a
     /tmp/ccYQhF14.s:68     .text:0000005c $d
     /tmp/ccYQhF14.s:276    .data:00000004 a_pPMC
     /tmp/ccYQhF14.s:270    .data:00000000 a_pADC
     /tmp/ccYQhF14.s:76     .text:00000068 getValueChannel0
     /tmp/ccYQhF14.s:84     .text:00000068 $a
     /tmp/ccYQhF14.s:102    .text:0000008c $d
     /tmp/ccYQhF14.s:108    .text:00000090 getValueChannel1
     /tmp/ccYQhF14.s:116    .text:00000090 $a
     /tmp/ccYQhF14.s:134    .text:000000b4 $d
     /tmp/ccYQhF14.s:140    .text:000000b8 getValueChannel2
     /tmp/ccYQhF14.s:148    .text:000000b8 $a
     /tmp/ccYQhF14.s:166    .text:000000dc $d
     /tmp/ccYQhF14.s:172    .text:000000e0 getValueChannel4
     /tmp/ccYQhF14.s:180    .text:000000e0 $a
     /tmp/ccYQhF14.s:198    .text:00000104 $d
     /tmp/ccYQhF14.s:204    .text:00000108 getValueChannel5
     /tmp/ccYQhF14.s:212    .text:00000108 $a
     /tmp/ccYQhF14.s:230    .text:0000012c $d
     /tmp/ccYQhF14.s:236    .text:00000130 getValueChannel6
     /tmp/ccYQhF14.s:244    .text:00000130 $a
     /tmp/ccYQhF14.s:262    .text:00000154 $d
     /tmp/ccYQhF14.s:271    .data:00000000 $d

NO UNDEFINED SYMBOLS
