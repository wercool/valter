   1              	# 1 "common/Cstartup.S"
   2              	# 1 "<built-in>"
   1              	/*------------------------------------------------------------------------------
   0              	
   0              	
   2              	//*-         ATMEL Microcontroller Software Support  -  ROUSSET  -
   3              	//*------------------------------------------------------------------------------
   4              	//* The software is delivered "AS IS" without warranty or condition of any
   5              	//* kind, either express, implied or statutory. This includes without
   6              	//* limitation any warranty or condition with respect to merchantability or
   7              	//* fitness for any particular purpose, or against the infringements of
   8              	//* intellectual property rights of others.
   9              	//*-----------------------------------------------------------------------------
  10              	//*- File source          : Cstartup.s
  11              	//*- Object               : Generic CStartup for KEIL and GCC
  12              	//*- Compilation flag     : None
  13              	//*-
  14              	//*- 1.0 18/Oct/04 JPP    : Creation
  15              	//*- 1.1 21/Feb/05 JPP    : Set Interrupt
  16              	//*- 1.1 01/Apr/05 JPP    : save SPSR 
  17              	//*
  18              	//*- WinARM/arm-elf-gcc-version by Martin Thomas - Modifications:
  19              	//*  remapping-support, vector-location, stack-position and more...
  20              	//*-----------------------------------------------------------------------------*/
  21              	
  22              	/* 
  23              	   20060902 (mth) : moved IRQ-Handler from section .vect* to 
  24              	                    .init/.fastrun
  25              	   20061101 (mth) : update IRQ-Handler
  26              	                    FIQ-stack init
  27              	*/
  28              	
  29              	/* check configuration-options and map to "assembler symbols": */
  30              	
  31              	#ifdef ROM_RUN
  32              	.set RAM_MODE, 0
  33              	#ifdef VECTORS_IN_RAM
  34              	.set REMAP, 1
  35              	.set VECTREMAPPED, 1
  36              	#else
  37              	.set REMAP, 0
  38              	.set VECTREMAPPED, 0
  39              	#endif
  40              	#endif
  41              	
  42              	#ifdef RAM_RUN
  43              	.set RAM_MODE, 1
  44              	.set REMAP, 1
  45              	.set VECTREMAPPED, 0
  46              	#endif
  47              	
  48              	
  49              	.if (RAM_MODE)
  50              	.print "RAM_MODE enabled"
  51              	.else
  52              	.print "ROM_MODE enabled"
  53              	.endif
  54              	
  55              	.if (REMAP)
  56              	.print "remapping enabled"
  57              	.endif
  58              	
  59              	.if (VECTREMAPPED)
  60              	.print "Vectors at start of RAM"
  61              	.else
  62              	.print "Vectors at start of Code"
  63              	.endif
  64              	
  65              		.equ AIC_IVR,         (256) 
  66              		.equ AIC_FVR,         (260) 
  67              		.equ AIC_EOICR,       (304)
  68              		.equ AT91C_BASE_AIC,  (0xFFFFF000)
  69              	
  70              	/*------------------------------------------------------------------------------
  71              	//*- Exception vectors 
  72              	//*--------------------
  73              	//*- These vectors can be read at address 0 or at RAM address
  74              	//*- They ABSOLUTELY requires to be in relative addresssing mode in order to
  75              	//*- guarantee a valid jump. For the moment, all are just looping.
  76              	//*- If an exception occurs before remap, this would result in an infinite loop.
  77              	//*- To ensure if a exeption occurs before start application to infinite loop.
  78              	//*------------------------------------------------------------------------------*/
  79              	
  80              	.if (VECTREMAPPED)
  81              	.print "Vectors in section .vectmapped -> .data"
  82              	.section .vectmapped, "ax"
  83              	.else
  84              	.print "Vectors in section .vectorg -> .text"
  85              	.section .vectorg, "ax"
  86              	.endif
  87              	
  88 0000 3CF09FE5 				LDR     PC,Reset_Addr		/* 0x00 Reset handler */    
  89 0004 3CF09FE5 				LDR     PC,Undef_Addr		/* 0x04 Undefined Instruction */
  90 0008 3CF09FE5 				LDR     PC,SWI_Addr			/* 0x08 Software Interrupt */
  91 000c 3CF09FE5 				LDR     PC,PAbt_Addr		/* 0x0C Prefetch Abort */
  92 0010 3CF09FE5 				LDR     PC,DAbt_Addr		/* 0x10 Data Abort */
  93 0014 0000A0E1 				NOP                 		/* 0x14 reserved  */
  94 0018 38F09FE5 				LDR     PC,IRQ_Addr			/* 0x18 IRQ */
  95              	fiqvec:                                 /* 0x1c FIQ */
  96              	/*------------------------------------------------------------------------------
  97              	//*- Function             : FIQ_Handler_Entry
  98              	//*- Treatments           : FIQ Controller Interrupt Handler.
  99              	//*- Called Functions     : AIC_FVR[interrupt] 
 100              	//*------------------------------------------------------------------------------*/
 101              	
 102              	FIQ_Handler_Entry:
 103              	
 104              	/*- Switch in SVC/User Mode to allow User Stack access for C code 	*/
 105              	/* because the FIQ is not yet acknowledged*/
 106              	
 107              	/*- Save and r0 in FIQ_Register */
 108 001c 0090A0E1 	            mov         r9,r0
 109 0020 040198E5 	            ldr         r0 , [r8, #AIC_FVR]
 110 0024 D3F021E3 	            msr         CPSR_c,#I_BIT | F_BIT | ARM_MODE_SVC
 111              	
 112              	/*- Save scratch/used registers and LR in User Stack */
 113 0028 0E502DE9 	            stmfd       sp!, { r1-r3, r12, lr}
 114              	
 115              	/*- Branch to the routine pointed by the AIC_FVR */
 116 002c 0FE0A0E1 	            mov         r14, pc
 117 0030 10FF2FE1 	            bx          r0
 118              	
 119              	/*- Restore scratch/used registers and LR from User Stack */
 120 0034 0E50BDE8 	            ldmia       sp!, { r1-r3, r12, lr}
 121              	
 122              	/*- Leave Interrupts disabled and switch back in FIQ mode */
 123 0038 D1F021E3 	            msr         CPSR_c, #I_BIT | F_BIT | ARM_MODE_FIQ
 124              	
 125              	/*- Restore the R0 ARM_MODE_SVC register */
 126 003c 0900A0E1 	            mov         r0,r9
 127              	
 128              	/*- Restore the Program Counter using the LR_fiq directly in the PC */
 129 0040 04F05EE2 	            subs        pc,lr,#4
 130              	
 131              	/* end of fiqhandler */
 132              	
 133 0044 04000000 	Reset_Addr:       .word     InitReset
 134 0048 5C000000 	Undef_Addr:       .word     Undef_Handler
 135              	/* SWI_Addr:         .word     SWI_Handler */
 136 004c 00000000 	SWI_Addr:         .word     SoftwareInterruptASM      /* in swi_handler.S */
 137 0050 60000000 	PAbt_Addr:        .word     PAbt_Handler
 138 0054 64000000 	DAbt_Addr:        .word     DAbt_Handler
 139 0058 00000000 	IRQ_Addr:         .word     IRQ_Handler_Entry
 140              	  
 141 005c 150000EA 	Undef_Handler:  B       Undef_Handler
 142              	/* SWI_Handler:    B       SWI_Handler */
 143 0060 160000EA 	PAbt_Handler:   B       PAbt_Handler
 144 0064 170000EA 	DAbt_Handler:   B       DAbt_Handler
 145              	
 146              	
 147              	        .arm
 148              	        .section .init, "ax"
 149              	        .global _startup
 150              	        .func   _startup
 151              	_startup:
 152              	reset: 
 153              	
 154              	.if (VECTREMAPPED)
 155              	/* mthomas: Dummy used during startup */
 156              					LDR PC,=Reset_Addr_F
 157              					NOP
 158              					NOP
 159              					NOP
 160              					NOP
 161              					NOP /*.word 0xdeadbeef*/ /* Reserved Address */
 162              					NOP
 163              					NOP
 164              	Reset_Addr_F:       .word     InitReset
 165              	.endif
 166              	
 167              	.RAM_TOP:
 168 0000 00000000 		.word	__TOP_STACK 
 169              	
 170              	InitReset:
 171              	
 172              	/*------------------------------------------------------------------------------
 173              	/*- Remapping
 174              	/*------------------------------------------------------------------------------*/
 175              	.if (VECTREMAPPED)
 176              			.print "RCR setting for remapping enabled"
 177              			.equ    MC_BASE,0xFFFFFF00  /* MC Base Address */
 178              			.equ    MC_RCR, 0x00        /* MC_RCR Offset */
 179              			
 180              	
 181              			/* store first word in RAM into r4 */
 182              			ldr r0,=__FIRST_IN_RAM
 183              			ldr r4,[r0]
 184              			/* load value at address 0 into R2 */
 185              			ldr r1,=0x00000000
 186              			ldr r2,[r1]	
 187              			/* xor value from address 0 (flip all bits), store in R3 */
 188              			ldr r3,=0xffffffff
 189              			eor r3, r2, r3
 190              			/* write xored value to first word in RAM 
 191              			if already remapped this will also change
 192              			the value at 0 */
 193              			str r3,[r0]
 194              			/* load from address 0 again into R3 */
 195              			ldr r3,[r1]
 196              			/* restore first value in RAM */
 197              			str r4,[r0]
 198              			
 199              			/* compare */
 200              			cmp r3, r2
 201              			bne already_remapped
 202              		
 203              			/* if both values have been equal the change of the
 204              			RAM-value had no effect on the value at 0x00000000 
 205              			so we are not remapping yet -> remap now: */
 206              			LDR     R0, =MC_BASE
 207              			MOV     R1, #1
 208              			STR     R1, [R0, #MC_RCR]
 209              			
 210              	already_remapped:
 211              	.endif
 212              	
 213              	
 214              	/*------------------------------------------------------------------------------
 215              	/*- Low level Init (PMC, AIC, ? ....) by C function AT91F_LowLevelInit
 216              	/*------------------------------------------------------------------------------*/
 217              	            .extern   AT91F_LowLevelInit
 218              	/*- minumum C initialization */
 219              	/*- call  AT91F_LowLevelInit( void) */
 220              	
 221 0004 0CD01FE5 	            ldr     sp, .RAM_TOP            /* temporary stack in internal RAM (**) */
 222              	/*--Call Low level init function in ABSOLUTE through the Interworking	*/
 223 0008 EC009FE5 	            ldr     r0,=AT91F_LowLevelInit
 224 000c 0FE0A0E1 	            mov     lr, pc
 225 0010 10FF2FE1 	            bx      r0
 226              	/*------------------------------------------------------------------------------
 227              	//*- Stack Sizes Definition
 228              	//*------------------------
 229              	//*- Interrupt Stack requires 2 words x 8 priority level x 4 bytes when using
 230              	//*- the vectoring. This assume that the IRQ management.
 231              	//*- The Interrupt Stack must be adjusted depending on the interrupt handlers.
 232              	//*- Fast Interrupt not requires stack If in your application it required you must
 233              	//*- be definehere.
 234              	//*- The System stack size is not defined and is limited by the free internal
 235              	//*- SRAM.
 236              	//*------------------------------------------------------------------------------*/
 237              	
 238              	/*------------------------------------------------------------------------------
 239              	//*- Top of Stack Definition
 240              	//*-------------------------
 241              	//*- Interrupt and Supervisor Stack are located at the top of internal memory in 
 242              	//*- order to speed the exception handling context saving and restoring.
 243              	//*- ARM_MODE_SVC (Application, C) Stack is located at the top of the external memory.
 244              	//*------------------------------------------------------------------------------*/
 245              	
 246              	          .EQU		IRQ_STACK_SIZE,    (3*8*4)
 247              	          .EQU		FIQ_STACK_SIZE,    (3*8*4)
 248              	          .EQU		ARM_MODE_FIQ,       0x11
 249              	          .EQU		ARM_MODE_IRQ,       0x12
 250              	          .EQU		ARM_MODE_SVC,       0x13
 251              	
 252              	          .EQU		I_BIT,              0x80
 253              	          .EQU		F_BIT,              0x40
 254              	
 255              	/*------------------------------------------------------------------------------
 256              	//*- Setup the stack for each mode
 257              	//*-------------------------------*/
 258 0014 0D00A0E1 	                mov     r0, sp /* see (**) */
 259              	
 260              	/*- Set up Fast Interrupt Mode and set FIQ Mode Stack*/
 261 0018 D1F021E3 	                msr     CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT
 262 001c 00D0A0E1 	                mov    sp, r0
 263 0020 600040E2 	                sub    r0, r0, #FIQ_STACK_SIZE
 264              	/*- Init the FIQ register*/
 265 0024 D4809FE5 	                ldr     r8, =AT91C_BASE_AIC
 266              	
 267              	/*- Set up Interrupt Mode and set IRQ Mode Stack*/
 268 0028 D2F021E3 	                msr     CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
 269 002c 00D0A0E1 	                mov     sp, r0                     /* Init stack IRQ */
 270 0030 600040E2 	                sub     r0, r0, #IRQ_STACK_SIZE
 271              	
 272              	/*- Set up Supervisor Mode and set Supervisor Mode Stack*/
 273              	//				/* start with INT and FIQ enabled */
 274              	//				msr     CPSR_c, #ARM_MODE_SVC 
 275              	
 276              					/* start with INT and FIQ disabled */
 277 0034 D3F021E3 					msr     CPSR_c, #ARM_MODE_SVC | I_BIT | F_BIT 
 278              	
 279 0038 00D0A0E1 					mov     sp, r0                     /* Init stack Sup */
 280              	
 281              	
 282              	/*- Enable interrupt & Set up Supervisor Mode and set Supervisor Mode Stack*/
 283              	
 284              	/* Relocate .data section (Copy from ROM to RAM) 
 285              	   This will also copy the .vectmapped and .fastrun */
 286 003c C0109FE5 	                LDR     R1, =_etext
 287 0040 C0209FE5 	                LDR     R2, =_data
 288 0044 C0309FE5 	                LDR     R3, =_edata
 289 0048 030052E1 	LoopRel:        CMP     R2, R3
 290 004c 04009134 	                LDRLO   R0, [R1], #4
 291 0050 04008234 	                STRLO   R0, [R2], #4
 292 0054 1000003A 	                BLO     LoopRel
 293              	
 294              	/* Clear .bss section (Zero init) */
 295 0058 0000A0E3 	                MOV     R0, #0
 296 005c AC109FE5 	                LDR     R1, =__bss_start__
 297 0060 AC209FE5 	                LDR     R2, =__bss_end__
 298 0064 020051E1 	LoopZI:         CMP     R1, R2
 299 0068 04008134 	                STRLO   R0, [R1], #4
 300 006c 1700003A 	                BLO     LoopZI
 301              	
 302              	
 303              	/* call C++ constructors of global objects */
 304 0070 A0009FE5 			LDR 	r0, =__ctors_start__
 305 0074 A0109FE5 			LDR 	r1, =__ctors_end__
 306              	ctor_loop:
 307 0078 010050E1 			CMP 	r0, r1
 308 007c 2400000A 			BEQ 	ctor_end
 309 0080 042090E4 			LDR 	r2, [r0], #4
 310 0084 03002DE9 			STMFD 	sp!, {r0-r1}
 311 0088 0FE0A0E1 			MOV 	lr, pc
 312              	/*		MOV 	pc, r2 */
 313 008c 12FF2FE1 			BX r2 /* mthomas 8/2006 */
 314 0090 0300BDE8 			LDMFD 	sp!, {r0-r1}
 315 0094 1C0000EA 			B 		ctor_loop
 316              	ctor_end:
 317              	
 318              	
 319              	/* call main() */
 320 0098 80E09FE5 			ldr	lr,=exit
 321 009c 80009FE5 			ldr	r0,=main
 322 00a0 10FF2FE1 			bx	r0
 323              	
 325              	        .endfunc
 326              	
 327              	/* "exit" dummy added by mthomas to avoid sbrk write read etc. needed
 328              	   by the newlib default "exit" */
 329              	        .global exit
 330              	        .func   exit
 331              	exit:
 332 00a4 270000EA 	        b    .
 334              	        .endfunc
 335              	
 336              	
 337              	
 338              	
 339              	/*------------------------------------------------------------------------------
 340              	//*- Manage exception
 341              	//*---------------
 342              	//*- This module The exception must be ensure in ARM mode
 343              	//*------------------------------------------------------------------------------
 344              	//*------------------------------------------------------------------------------
 345              	//*- Function             : IRQ_Handler_Entry
 346              	//*- Treatments           : IRQ Controller Interrupt Handler.
 347              	//*- Called Functions     : AIC_IVR[interrupt] 
 348              	//*------------------------------------------------------------------------------*/
 349              	
 350              	.if (VECTREMAPPED)
 351              	.print "IRQ_Handler_Entry in section .fastrun -> .data"
 352              	.section .fastrun, "ax"
 353              	.else
 354              	.print "IRQ_Handler_Entry in section .init -> .text"
 355              	.section .init, "ax"
 356              	.endif
 357              	
 358              	        .global IRQ_Handler_Entry
 359              	        .func   IRQ_Handler_Entry
 360              	IRQ_Handler_Entry:
 361              	/*---- Adjust and save return address on the stack */
 362 00a8 04E04EE2 	    sub     lr, lr, #4
 363 00ac 00402DE9 	    stmfd   sp!, {lr}
 364              	
 365              	/*---- Save r0 and SPSR on the stack */
 366 00b0 00E04FE1 	    mrs     r14, SPSR
 367 00b4 01402DE9 	    stmfd   sp!, {r0, r14}
 368              	
 369              	/*---- Write in the IVR to support Protect mode */
 370              	/*---- No effect in Normal Mode */
 371              	/*---- De-assert NIRQ and clear the source in Protect mode */
 372 00b8 40E09FE5 	    ldr     r14, =AT91C_BASE_AIC
 373 00bc 00019EE5 	    ldr     r0, [r14, #AIC_IVR]
 374 00c0 00E18EE5 	    str     r14, [r14, #AIC_IVR]
 375              	
 376              	/*---- Enable nested interrupts and switch to Supervisor mode */
 377 00c4 13F021E3 	    msr     CPSR_c, #ARM_MODE_SVC
 378              	
 379              	/*---- Save scratch/used registers and LR on the stack */
 380 00c8 0E502DE9 	    stmfd   sp!, {r1-r3, r12, r14}
 381              	
 382              	/*---- Branch to the routine pointed by AIC_IVR */
 383 00cc 0FE0A0E1 	    mov     r14, pc
 384 00d0 10FF2FE1 	    bx      r0
 385              	
 386              	/*---- Restore scratch/used registers and LR from the stack */
 387 00d4 0E50BDE8 	    ldmia   sp!, {r1-r3, r12, r14}
 388              	
 389              	/*---- Disable nested interrupts and switch back to IRQ mode */
 390 00d8 92F021E3 	    msr     CPSR_c, #I_BIT | ARM_MODE_IRQ
 391              	
 392              	/*---- Acknowledge interrupt by writing AIC_EOICR */
 393 00dc 1CE09FE5 	    ldr     r14, =AT91C_BASE_AIC
 394 00e0 30E18EE5 	    str     r14, [r14, #AIC_EOICR]
 395              	
 396              	/*---- Restore SPSR and r0 from the stack */
 397 00e4 0140BDE8 	    ldmia   sp!, {r0, r14}
 398 00e8 0EF06FE1 	    msr     SPSR_cxsf, r14
 399              	
 400              	/*---- Return from interrupt handler */
 401 00ec 0080FDE8 	    ldmia   sp!, {pc}^
 402              	
 404              	        .endfunc
 405              	
 406              	
 407              	/*---------------------------------------------------------------
 408              	//* ?EXEPTION_VECTOR
 409              	//* This module is only linked if needed for closing files.
 410              	//*---------------------------------------------------------------*/
 411              	        .global AT91F_Default_FIQ_handler
 412              	        .func   AT91F_Default_FIQ_handler
 413              	AT91F_Default_FIQ_handler:
 414 00f0 FEFFFFEA 	            b     AT91F_Default_FIQ_handler
 416              	        .endfunc
 417              	
 418              	        .global AT91F_Default_IRQ_handler
 419              	        .func   AT91F_Default_IRQ_handler
 420              	AT91F_Default_IRQ_handler:
 421 00f4 FEFFFFEA 	            b     AT91F_Default_IRQ_handler
 423              	        .endfunc
 424              	
 425              	        .global AT91F_Spurious_handler
 426              	        .func   AT91F_Spurious_handler
 427              	AT91F_Spurious_handler:
 428 00f8 FEFFFFEA 	            b     AT91F_Spurious_handler
 430              	        .endfunc
 431              	
 432 00fc 00000000 	        .end
 432      00F0FFFF 
 432      00000000 
 432      00000000 
 432      00000000 
DEFINED SYMBOLS
                            *ABS*:00000000 common/Cstartup.S
   common/Cstartup.S:32     *ABS*:00000000 RAM_MODE
   common/Cstartup.S:37     *ABS*:00000000 REMAP
   common/Cstartup.S:38     *ABS*:00000000 VECTREMAPPED
   common/Cstartup.S:65     *ABS*:00000100 AIC_IVR
   common/Cstartup.S:66     *ABS*:00000104 AIC_FVR
   common/Cstartup.S:67     *ABS*:00000130 AIC_EOICR
   common/Cstartup.S:68     *ABS*:fffff000 AT91C_BASE_AIC
   common/Cstartup.S:88     .vectorg:00000000 $a
   common/Cstartup.S:133    .vectorg:00000044 Reset_Addr
   common/Cstartup.S:134    .vectorg:00000048 Undef_Addr
   common/Cstartup.S:136    .vectorg:0000004c SWI_Addr
   common/Cstartup.S:137    .vectorg:00000050 PAbt_Addr
   common/Cstartup.S:138    .vectorg:00000054 DAbt_Addr
   common/Cstartup.S:139    .vectorg:00000058 IRQ_Addr
   common/Cstartup.S:95     .vectorg:0000001c fiqvec
   common/Cstartup.S:102    .vectorg:0000001c FIQ_Handler_Entry
                            *ABS*:00000080 I_BIT
                            *ABS*:00000040 F_BIT
                            *ABS*:00000013 ARM_MODE_SVC
                            *ABS*:00000011 ARM_MODE_FIQ
   common/Cstartup.S:133    .vectorg:00000044 $d
   common/Cstartup.S:170    .init:00000004 InitReset
   common/Cstartup.S:141    .vectorg:0000005c Undef_Handler
   common/Cstartup.S:143    .vectorg:00000060 PAbt_Handler
   common/Cstartup.S:144    .vectorg:00000064 DAbt_Handler
   common/Cstartup.S:360    .init:000000a8 IRQ_Handler_Entry
   common/Cstartup.S:141    .vectorg:0000005c $a
   common/Cstartup.S:151    .init:00000000 _startup
   common/Cstartup.S:152    .init:00000000 reset
   common/Cstartup.S:167    .init:00000000 .RAM_TOP
   common/Cstartup.S:168    .init:00000000 $d
   common/Cstartup.S:221    .init:00000004 $a
   common/Cstartup.S:246    *ABS*:00000060 IRQ_STACK_SIZE
   common/Cstartup.S:247    *ABS*:00000060 FIQ_STACK_SIZE
   common/Cstartup.S:249    *ABS*:00000012 ARM_MODE_IRQ
   common/Cstartup.S:289    .init:00000048 LoopRel
   common/Cstartup.S:298    .init:00000064 LoopZI
   common/Cstartup.S:306    .init:00000078 ctor_loop
   common/Cstartup.S:316    .init:00000098 ctor_end
   common/Cstartup.S:331    .init:000000a4 exit
   common/Cstartup.S:413    .init:000000f0 AT91F_Default_FIQ_handler
   common/Cstartup.S:420    .init:000000f4 AT91F_Default_IRQ_handler
   common/Cstartup.S:427    .init:000000f8 AT91F_Spurious_handler
   common/Cstartup.S:432    .init:000000fc $d

UNDEFINED SYMBOLS
SoftwareInterruptASM
__TOP_STACK
AT91F_LowLevelInit
_etext
_data
_edata
__bss_start__
__bss_end__
__ctors_start__
__ctors_end__
main
