   1              		.file	"load_cell.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	flashInit
  13              	flashInit:
  14              	.LFB285:
  15              		.file 1 "load_cell.c"
   1:load_cell.c   **** //*----------------------------------------------------------------------------
   2:load_cell.c   **** //*         ATMEL Microcontroller Software Support  -  ROUSSET  -
   3:load_cell.c   **** //*----------------------------------------------------------------------------
   4:load_cell.c   **** //* The software is delivered "AS IS" without warranty or condition of any
   5:load_cell.c   **** //* kind, either express, implied or statutory. This includes without
   6:load_cell.c   **** //* limitation any warranty or condition with respect to merchantability or
   7:load_cell.c   **** //* fitness for any particular purpose, or against the infringements of
   8:load_cell.c   **** //* intellectual property rights of others.
   9:load_cell.c   **** //*----------------------------------------------------------------------------
  10:load_cell.c   **** //* File Name           : main.c
  11:load_cell.c   **** //* Object              : main application written in C
  12:load_cell.c   **** //* Creation            : JPP   16/Jun/2004
  13:load_cell.c   **** //*----------------------------------------------------------------------------
  14:load_cell.c   **** 
  15:load_cell.c   **** // Include Standard files
  16:load_cell.c   **** #include "stdio.h"
  17:load_cell.c   **** #include "string.h"
  18:load_cell.c   **** 
  19:load_cell.c   **** #include "fastfunc.h"
  20:load_cell.c   **** #include "Board.h"
  21:load_cell.c   **** #include "cdc_enumerate.h"
  22:load_cell.c   **** #include "adc.h"
  23:load_cell.c   **** #include "system.h"
  24:load_cell.c   **** #include "mmc.h"
  25:load_cell.c   **** 
  26:load_cell.c   **** /* Global variables */
  27:load_cell.c   **** #define SPEED       (MCKKHz/10)
  28:load_cell.c   **** unsigned int LedSpeed = SPEED *50;
  29:load_cell.c   **** #define MSG_SIZE        1000
  30:load_cell.c   **** extern void Usart_init ( void );
  31:load_cell.c   **** extern void AT91F_US_Put( char *buffer); // \arg pointer to a string ending by \0
  32:load_cell.c   **** extern void Trace_Toggel_LED( unsigned int led);
  33:load_cell.c   **** unsigned char res[MSG_SIZE];
  34:load_cell.c   **** unsigned char pos[MSG_SIZE];
  35:load_cell.c   **** unsigned char cmd[MSG_SIZE];
  36:load_cell.c   **** unsigned char msg[MSG_SIZE];
  37:load_cell.c   **** 
  38:load_cell.c   **** unsigned char settings[128];
  39:load_cell.c   **** 
  40:load_cell.c   **** int maxPos = 900;
  41:load_cell.c   **** int minPos = 300;
  42:load_cell.c   **** int curPos = 600;
  43:load_cell.c   **** 
  44:load_cell.c   **** int maxForce = 100000;
  45:load_cell.c   **** int minForce = 66000;
  46:load_cell.c   **** int curForce = 66000;
  47:load_cell.c   **** 
  48:load_cell.c   **** int pressure;
  49:load_cell.c   **** int position;
  50:load_cell.c   **** int direction;
  51:load_cell.c   **** unsigned char reading = 0;
  52:load_cell.c   **** unsigned char dataReading = 0;
  53:load_cell.c   **** 
  54:load_cell.c   **** 
  55:load_cell.c   **** //AAT Settings
  56:load_cell.c   **** unsigned char aatDiag = 0;
  57:load_cell.c   **** unsigned char aatDiagStep = 0;
  58:load_cell.c   **** int minDiagForce = 90000;
  59:load_cell.c   **** int lockDiagForce = 100000;
  60:load_cell.c   **** int lockDiagPressure = 0;
  61:load_cell.c   **** int diagForce = 80000;
  62:load_cell.c   **** 
  63:load_cell.c   **** int averager = 0;
  64:load_cell.c   **** int averager_force = 0;
  65:load_cell.c   **** 
  66:load_cell.c   **** int test_read = 0;
  67:load_cell.c   **** int set_zero = 0;
  68:load_cell.c   **** 
  69:load_cell.c   **** int green_led_off = 0;
  70:load_cell.c   **** int green_led_on = 0;
  71:load_cell.c   **** 
  72:load_cell.c   **** char CDC = 0;
  73:load_cell.c   **** 
  74:load_cell.c   **** // external buffer which is use to read/write in MMC card
  75:load_cell.c   **** extern unsigned char mmc_buffer[512];
  76:load_cell.c   **** int mmc_buffer_index = 0;
  77:load_cell.c   **** int mmc_block_index = 0;
  78:load_cell.c   **** unsigned char mmc_buffer_out[512];
  79:load_cell.c   **** 
  80:load_cell.c   **** unsigned char storingOnMMC = 0;
  81:load_cell.c   **** 
  82:load_cell.c   **** 
  83:load_cell.c   **** // We will store our data in the last page of Flash.
  84:load_cell.c   **** #define OUR_FLASH_ADDR (AT91C_IFLASH + AT91C_IFLASH_SIZE - AT91C_IFLASH_PAGE_SIZE)
  85:load_cell.c   **** #define AT91C_MC_WRITE_KEY  ((unsigned)0x5A << 24) // Value to enable flash commands.
  86:load_cell.c   **** 
  87:load_cell.c   **** // ***************************************************************
  88:load_cell.c   **** // ** flashInit - Sets up the flash writing peripheral. Call this
  89:load_cell.c   **** // **             before you do any flash writes.
  90:load_cell.c   **** // **
  91:load_cell.c   **** void flashInit()
  92:load_cell.c   **** {
  16              		.loc 1 92 0
  17              		@ args = 0, pretend = 0, frame = 4
  18              		@ frame_needed = 0, uses_anonymous_args = 0
  19              		@ link register save eliminated.
  20 0000 04D04DE2 		sub	sp, sp, #4
  21              	.LCFI0:
  93:load_cell.c   **** // Get base location of memory controller peripheral.
  94:load_cell.c   ****     volatile AT91PS_MC mc = AT91C_BASE_MC;
  22              		.loc 1 94 0
  23 0004 FF30E0E3 		mvn	r3, #255
  24 0008 00308DE5 		str	r3, [sp, #0]
  25              	.LVL0:
  95:load_cell.c   **** 
  96:load_cell.c   **** // Enable the auto-erase feature and set up flash write timing.
  97:load_cell.c   ****     mc->MC_FMR = AT91C_MC_FWS_1FWS | (1 + (((MCK * 15) / 10000000)) << 16);
  26              		.loc 1 97 0
  27 000c 00209DE5 		ldr	r2, [sp, #0]
  28 0010 08309FE5 		ldr	r3, .L3
  29              		.loc 1 92 0
  30              		@ lr needed for prologue
  31              		.loc 1 97 0
  32 0014 603082E5 		str	r3, [r2, #96]
  98:load_cell.c   **** }
  33              		.loc 1 98 0
  34 0018 04D08DE2 		add	sp, sp, #4
  35 001c 1EFF2FE1 		bx	lr
  36              	.L4:
  37              		.align	2
  38              	.L3:
  39 0020 00014800 		.word	4718848
  40              	.LFE285:
  42              		.align	2
  43              		.global	Delay
  45              	Delay:
  46              	.LFB292:
  99:load_cell.c   **** 
 100:load_cell.c   **** 
 101:load_cell.c   **** struct _AT91S_CDC   pCDC;
 102:load_cell.c   **** 
 103:load_cell.c   **** void Init_PWM(void)
 104:load_cell.c   **** {
 105:load_cell.c   ****   AT91F_PWMC_InterruptDisable(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 106:load_cell.c   ****   AT91F_PMC_EnablePeriphClock( AT91C_BASE_PMC, 1 << AT91C_ID_PIOA );
 107:load_cell.c   ****   AT91F_PWMC_CH0_CfgPIO();
 108:load_cell.c   ****   AT91F_PWMC_CfgPMC();    
 109:load_cell.c   ****   AT91F_PWMC_StopChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 110:load_cell.c   ****   AT91F_PWMC_CfgChannel(AT91C_BASE_PWMC, 0, 1 | AT91C_PWMC_CPOL, 100000, 66000);
 111:load_cell.c   ****   AT91F_PWMC_UpdateChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0, 0);
 112:load_cell.c   ****   AT91F_PWMC_StopChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 113:load_cell.c   ****   AT91F_PIO_CfgPeriph(AT91C_BASE_PIOA, 0, AT91C_PA23_PWM0);
 114:load_cell.c   ****   AT91F_PWMC_StartChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 115:load_cell.c   **** }
 116:load_cell.c   **** 
 117:load_cell.c   **** //*----------------------------------------------------------------------------
 118:load_cell.c   **** //* \fn    AT91F_USB_Open
 119:load_cell.c   **** //* \brief This function Open the USB device
 120:load_cell.c   **** //*----------------------------------------------------------------------------
 121:load_cell.c   **** void AT91F_USB_Open(void)
 122:load_cell.c   **** {
 123:load_cell.c   ****     // Set the PLL USB Divider
 124:load_cell.c   ****     AT91C_BASE_CKGR->CKGR_PLLR |= AT91C_CKGR_USBDIV_1 ;
 125:load_cell.c   **** 
 126:load_cell.c   ****     // Specific Chip USB Initialisation
 127:load_cell.c   ****     // Enables the 48MHz USB clock UDPCK and System Peripheral USB Clock
 128:load_cell.c   ****     AT91C_BASE_PMC->PMC_SCER = AT91C_PMC_UDP;
 129:load_cell.c   ****     AT91C_BASE_PMC->PMC_PCER = (1 << AT91C_ID_UDP);
 130:load_cell.c   **** 
 131:load_cell.c   ****     // Enable UDP PullUp (USB_DP_PUP) : enable & Clear of the corresponding PIO
 132:load_cell.c   ****     // Set in PIO mode and Configure in Output
 133:load_cell.c   ****     AT91F_PIO_CfgOutput(AT91C_BASE_PIOA,AT91C_PIO_PA16);
 134:load_cell.c   ****     // Clear for set the Pul up resistor
 135:load_cell.c   ****     AT91F_PIO_ClearOutput(AT91C_BASE_PIOA,AT91C_PIO_PA16);
 136:load_cell.c   **** 
 137:load_cell.c   ****     // CDC Open by structure initialization
 138:load_cell.c   ****     AT91F_CDC_Open(&pCDC, AT91C_BASE_UDP);
 139:load_cell.c   **** }
 140:load_cell.c   **** 
 141:load_cell.c   **** //*--------------------------------------------------------------------------------------
 142:load_cell.c   **** //* Function Name       : change_speed
 143:load_cell.c   **** //* Object              : Adjust "LedSpeed" value depending on SW1 and SW2 are pressed or not
 144:load_cell.c   **** //* Input Parameters    : none
 145:load_cell.c   **** //* Output Parameters   : Update of LedSpeed value.
 146:load_cell.c   **** //*--------------------------------------------------------------------------------------
 147:load_cell.c   **** static void change_speed ( void )
 148:load_cell.c   **** {//* Begin
 149:load_cell.c   ****     if ( (AT91F_PIO_GetInput(AT91C_BASE_PIOA) & SW1_MASK) == 0 )
 150:load_cell.c   ****     {
 151:load_cell.c   ****         if ( LedSpeed > SPEED ) LedSpeed -=SPEED ;
 152:load_cell.c   ****     }
 153:load_cell.c   ****     if ( (AT91F_PIO_GetInput(AT91C_BASE_PIOA) & SW2_MASK) == 0 )
 154:load_cell.c   ****     {
 155:load_cell.c   ****         if ( LedSpeed < MCK ) LedSpeed +=SPEED ;
 156:load_cell.c   ****     }
 157:load_cell.c   **** }//* End
 158:load_cell.c   **** 
 159:load_cell.c   **** void clearLEDs()
 160:load_cell.c   **** {
 161:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 162:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 163:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 164:load_cell.c   **** }
 165:load_cell.c   **** 
 166:load_cell.c   **** void blinkingGreen(int delay)
 167:load_cell.c   **** {
 168:load_cell.c   ****     /*LED3 - GREEN*/
 169:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED3);
 170:load_cell.c   ****     Delay(delay);
 171:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 172:load_cell.c   ****     Delay(delay);
 173:load_cell.c   **** }
 174:load_cell.c   **** 
 175:load_cell.c   **** void startBlinking(int delay)
 176:load_cell.c   **** {
 177:load_cell.c   ****     /* START BLINKING LED */
 178:load_cell.c   ****     /*LED1 - RED*/
 179:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED1);
 180:load_cell.c   ****     Delay(delay);
 181:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 182:load_cell.c   ****     Delay(delay);
 183:load_cell.c   ****     /*LED2 - YELLOW*/
 184:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED2);
 185:load_cell.c   ****     Delay(delay);
 186:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 187:load_cell.c   ****     Delay(delay);
 188:load_cell.c   ****     /*LED3 - GREEN*/
 189:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED3);
 190:load_cell.c   ****     Delay(delay);
 191:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 192:load_cell.c   ****     Delay(delay);
 193:load_cell.c   **** }
 194:load_cell.c   **** 
 195:load_cell.c   **** void Delay(delayVal)
 196:load_cell.c   **** {
  47              		.loc 1 196 0
  48              		@ args = 0, pretend = 0, frame = 4
  49              		@ frame_needed = 0, uses_anonymous_args = 0
  50              		@ link register save eliminated.
  51              	.LVL1:
  52 0024 04D04DE2 		sub	sp, sp, #4
  53              	.LCFI1:
 197:load_cell.c   ****   volatile unsigned int waiting_time ;
 198:load_cell.c   ****   for(waiting_time = 0; waiting_time < delayVal; waiting_time++) ;
  54              		.loc 1 198 0
  55 0028 0030A0E3 		mov	r3, #0
  56              		.loc 1 196 0
  57              		@ lr needed for prologue
  58 002c 0C0000EA 		b	.L10
  59              	.LVL2:
  60              	.L7:
  61              		.loc 1 198 0
  62 0030 00309DE5 		ldr	r3, [sp, #0]
  63 0034 013083E2 		add	r3, r3, #1
  64              	.L10:
  65 0038 00308DE5 		str	r3, [sp, #0]
  66 003c 00309DE5 		ldr	r3, [sp, #0]
  67 0040 000053E1 		cmp	r3, r0
  68 0044 0A00003A 		bcc	.L7
 199:load_cell.c   **** }
  69              		.loc 1 199 0
  70 0048 04D08DE2 		add	sp, sp, #4
  71 004c 1EFF2FE1 		bx	lr
  72              	.LFE292:
  74              		.align	2
  75              		.global	printTrace
  77              	printTrace:
  78              	.LFB298:
 200:load_cell.c   **** 
 201:load_cell.c   **** void setForce(int force)
 202:load_cell.c   **** {
 203:load_cell.c   ****     AT91F_PWMC_StopChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 204:load_cell.c   ****     AT91F_PWMC_CfgChannel(AT91C_BASE_PWMC, 0, 1 | AT91C_PWMC_CPOL, 100000, force);
 205:load_cell.c   ****     AT91F_PWMC_UpdateChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0, 0);
 206:load_cell.c   ****     AT91F_PWMC_StartChannel(AT91C_BASE_PWMC, AT91C_PWMC_CHID0);
 207:load_cell.c   **** }
 208:load_cell.c   **** 
 209:load_cell.c   **** void liftUp(int force)
 210:load_cell.c   **** {
 211:load_cell.c   ****     setForce(force);
 212:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, DIRC);
 213:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, DIRD);
 214:load_cell.c   ****     direction = -1;
 215:load_cell.c   **** }
 216:load_cell.c   **** 
 217:load_cell.c   **** void lowerDown(int force)
 218:load_cell.c   **** {
 219:load_cell.c   ****     setForce(force);
 220:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, DIRD);
 221:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, DIRC);
 222:load_cell.c   ****     direction = 1;
 223:load_cell.c   **** }
 224:load_cell.c   **** 
 225:load_cell.c   **** void releasePosition()
 226:load_cell.c   **** {
 227:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, DIRD);
 228:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, DIRC);
 229:load_cell.c   **** }
 230:load_cell.c   **** 
 231:load_cell.c   **** void setPosition(int force)
 232:load_cell.c   **** {
 233:load_cell.c   ****     setForce(force);
 234:load_cell.c   ****     if (abs(curPos - position) > 5)
 235:load_cell.c   ****     {
 236:load_cell.c   ****         if (curPos > position)
 237:load_cell.c   ****         {
 238:load_cell.c   ****             lowerDown(force);
 239:load_cell.c   ****         }
 240:load_cell.c   ****         if (curPos < position)
 241:load_cell.c   ****         {
 242:load_cell.c   ****             liftUp(force);
 243:load_cell.c   ****         }
 244:load_cell.c   ****     }
 245:load_cell.c   ****     else
 246:load_cell.c   ****     {
 247:load_cell.c   ****         releasePosition();
 248:load_cell.c   ****     }
 249:load_cell.c   **** }
 250:load_cell.c   **** 
 251:load_cell.c   **** void printTrace(char * trace)
 252:load_cell.c   **** {
  79              		.loc 1 252 0
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              	.LVL3:
  83 0050 30402DE9 		stmfd	sp!, {r4, r5, lr}
  84              	.LCFI2:
 253:load_cell.c   ****     if (dataReading == 0)
  85              		.loc 1 253 0
  86 0054 3C309FE5 		ldr	r3, .L16
  87 0058 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  88 005c 000053E3 		cmp	r3, #0
  89              		.loc 1 252 0
  90 0060 0040A0E1 		mov	r4, r0
  91              		.loc 1 253 0
  92 0064 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
  93              	.LVL4:
 254:load_cell.c   ****     {
 255:load_cell.c   ****         if (CDC == 1)
  94              		.loc 1 255 0
  95 0068 2C309FE5 		ldr	r3, .L16+4
  96 006c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  97 0070 010053E3 		cmp	r3, #1
 256:load_cell.c   ****         {
 257:load_cell.c   ****             pCDC.Write(&pCDC, trace, strlen(trace));
  98              		.loc 1 257 0
  99 0074 24509FE5 		ldr	r5, .L16+8
 100              		.loc 1 255 0
 101 0078 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 102              		.loc 1 257 0
 103 007c FEFFFFEB 		bl	strlen
 104 0080 0410A0E1 		mov	r1, r4
 105 0084 0020A0E1 		mov	r2, r0
 106 0088 0500A0E1 		mov	r0, r5
 107 008c 0FE0A0E1 		mov	lr, pc
 108 0090 10F095E5 		ldr	pc, [r5, #16]
 109 0094 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 110              	.L17:
 111              		.align	2
 112              	.L16:
 113 0098 00000000 		.word	dataReading
 114 009c 00000000 		.word	CDC
 115 00a0 00000000 		.word	pCDC
 116              	.LFE298:
 118              		.align	2
 119              		.global	clearMMCCard
 121              	clearMMCCard:
 122              	.LFB299:
 258:load_cell.c   ****         }
 259:load_cell.c   ****     }
 260:load_cell.c   **** }
 261:load_cell.c   **** 
 262:load_cell.c   **** void clearMMCCard()
 263:load_cell.c   **** {
 123              		.loc 1 263 0
 124              		@ args = 0, pretend = 0, frame = 0
 125              		@ frame_needed = 0, uses_anonymous_args = 0
 126 00a4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 127              	.LCFI3:
 264:load_cell.c   ****     if (initMMC() == MMC_SUCCESS) // card found
 128              		.loc 1 264 0
 129 00a8 FEFFFFEB 		bl	initMMC
 130 00ac 005050E2 		subs	r5, r0, #0
 131 00b0 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 132              	.LBB2:
 265:load_cell.c   ****     {
 266:load_cell.c   ****       //card_state |= 1;
 267:load_cell.c   ****       memset(&mmc_buffer,0,512);
 133              		.loc 1 267 0
 134 00b4 48409FE5 		ldr	r4, .L24
 135 00b8 0510A0E1 		mov	r1, r5
 136 00bc 022CA0E3 		mov	r2, #512
 137 00c0 0400A0E1 		mov	r0, r4
 138 00c4 FEFFFFEB 		bl	memset
 268:load_cell.c   ****       mmcReadRegister (10, 16);
 139              		.loc 1 268 0
 140 00c8 0A00A0E3 		mov	r0, #10
 141 00cc 1010A0E3 		mov	r1, #16
 142 00d0 FEFFFFEB 		bl	mmcReadRegister
 269:load_cell.c   ****       mmc_buffer[7]=0;
 143              		.loc 1 269 0
 144 00d4 0750C4E5 		strb	r5, [r4, #7]
 145 00d8 0540A0E1 		mov	r4, r5
 146              	.L21:
 270:load_cell.c   **** 
 271:load_cell.c   ****       /*Clear first 1000 blocks*/
 272:load_cell.c   ****       int blockClearCnt;
 273:load_cell.c   ****       for (blockClearCnt = 0; blockClearCnt < 2048; blockClearCnt++)
 274:load_cell.c   ****       {
 275:load_cell.c   ****           memset(&mmc_buffer,'0',512);
 147              		.loc 1 275 0
 148 00dc 3010A0E3 		mov	r1, #48
 149 00e0 022CA0E3 		mov	r2, #512
 150 00e4 18009FE5 		ldr	r0, .L24
 151 00e8 FEFFFFEB 		bl	memset
 276:load_cell.c   ****           mmcWriteBlock(512 * blockClearCnt);
 152              		.loc 1 276 0
 153 00ec 0400A0E1 		mov	r0, r4
 154 00f0 024C84E2 		add	r4, r4, #512
 155 00f4 FEFFFFEB 		bl	mmcWriteBlock
 156              		.loc 1 273 0
 157 00f8 010654E3 		cmp	r4, #1048576
 158 00fc 3500001A 		bne	.L21
 159 0100 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 160              	.L25:
 161              		.align	2
 162              	.L24:
 163 0104 00000000 		.word	mmc_buffer
 164              	.LBE2:
 165              	.LFE299:
 167              		.align	2
 168              		.global	putCharToMMCBuffer
 170              	putCharToMMCBuffer:
 171              	.LFB301:
 277:load_cell.c   ****       }
 278:load_cell.c   **** 
 279:load_cell.c   ****       /*
 280:load_cell.c   ****       // Fill first Block (0) with 'A'
 281:load_cell.c   ****       memset(&mmc_buffer,'0',512);    //set breakpoint and trace mmc_buffer contents
 282:load_cell.c   ****       mmcWriteBlock(0);
 283:load_cell.c   ****       // Fill second Block (1)-AbsAddr 512 with 'B'
 284:load_cell.c   ****       memset(&mmc_buffer,'1',512);
 285:load_cell.c   ****       mmcWriteBlock(512);
 286:load_cell.c   **** 
 287:load_cell.c   ****       // Read first Block back to buffer
 288:load_cell.c   ****       memset(&mmc_buffer,0x00,512);
 289:load_cell.c   ****       mmcReadBlock(0,512);
 290:load_cell.c   **** 
 291:load_cell.c   ****       // Read first Block back to buffer
 292:load_cell.c   ****       memset(&mmc_buffer,0x00,512);
 293:load_cell.c   ****       mmcReadBlock(512,512);
 294:load_cell.c   ****       */
 295:load_cell.c   ****     }
 296:load_cell.c   **** }
 297:load_cell.c   **** 
 298:load_cell.c   **** void parseSettings(char data[MSG_SIZE])
 299:load_cell.c   **** {
 300:load_cell.c   ****     int i;
 301:load_cell.c   ****     int  settings_size;
 302:load_cell.c   **** 
 303:load_cell.c   ****     char cmdDelim[] = "#";
 304:load_cell.c   ****     char *cmdParts = NULL;
 305:load_cell.c   **** 
 306:load_cell.c   ****     cmdParts = strtok( data, cmdDelim );
 307:load_cell.c   **** 
 308:load_cell.c   ****     if (strcmp(cmdParts, "TEST") == 0)
 309:load_cell.c   ****     {
 310:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 311:load_cell.c   ****         if (strcmp(cmdParts, "TEST") == 0)
 312:load_cell.c   ****         {
 313:load_cell.c   ****             //INITIAL TEST
 314:load_cell.c   ****             printTrace("INITIAL TEST\r\n");
 315:load_cell.c   ****             for (i = 0; i < 15; i++)
 316:load_cell.c   ****             {
 317:load_cell.c   ****                 startBlinking(50000);
 318:load_cell.c   ****             }
 319:load_cell.c   ****         }
 320:load_cell.c   ****         if (strcmp(cmdParts, "START") == 0)
 321:load_cell.c   ****         {
 322:load_cell.c   ****             printTrace("TEST READING ACTIVATED\r\n");
 323:load_cell.c   ****             test_read = 1;
 324:load_cell.c   ****         }
 325:load_cell.c   ****         if (strcmp(cmdParts, "STOP") == 0)
 326:load_cell.c   ****         {
 327:load_cell.c   ****             printTrace("TEST READING STOPPED\r\n");
 328:load_cell.c   ****             test_read = 0;
 329:load_cell.c   ****         }
 330:load_cell.c   ****     }
 331:load_cell.c   **** 
 332:load_cell.c   ****     if (strcmp(cmdParts, "ZERO") == 0)
 333:load_cell.c   ****     {
 334:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 335:load_cell.c   ****         if (strcmp(cmdParts, "SET") == 0)
 336:load_cell.c   ****         {
 337:load_cell.c   ****             set_zero = pressure;
 338:load_cell.c   ****         }
 339:load_cell.c   ****         if (strcmp(cmdParts, "UNSET") == 0)
 340:load_cell.c   ****         {
 341:load_cell.c   ****             set_zero = 0;
 342:load_cell.c   ****         }
 343:load_cell.c   ****     }
 344:load_cell.c   ****     /*
 345:load_cell.c   ****     //AAT process
 346:load_cell.c   ****     if (strcmp(cmdParts, "DIAG") == 0)
 347:load_cell.c   ****     {
 348:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 349:load_cell.c   ****         if (strcmp(cmdParts, "START") == 0)
 350:load_cell.c   ****         {
 351:load_cell.c   ****             aatDiag = 1;
 352:load_cell.c   ****             aatDiagStep = 0;
 353:load_cell.c   ****         }
 354:load_cell.c   ****         if (strcmp(cmdParts, "STOP") == 0)
 355:load_cell.c   ****         {
 356:load_cell.c   ****             aatDiag = 0;
 357:load_cell.c   ****         }
 358:load_cell.c   ****         if (strcmp(cmdParts, "STEP4") == 0)
 359:load_cell.c   ****         {
 360:load_cell.c   ****             printTrace("DIAG#3#DONE\r\n");
 361:load_cell.c   ****             AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED3);
 362:load_cell.c   ****             aatDiagStep = 4;
 363:load_cell.c   ****             diagForce = maxForce;
 364:load_cell.c   ****         }
 365:load_cell.c   ****     }
 366:load_cell.c   ****     if (strcmp(cmdParts, "POSITION") == 0)
 367:load_cell.c   ****     {
 368:load_cell.c   ****         // POSITION SETTING
 369:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 370:load_cell.c   ****         if (strcmp(cmdParts, "MAX") == 0)
 371:load_cell.c   ****         {
 372:load_cell.c   ****             //MAX POSITION
 373:load_cell.c   ****             maxPos = atoi(strtok( NULL, cmdDelim ));
 374:load_cell.c   ****             sprintf((char *)msg,"MAX POSITION IS SET TO: %d\r\n", maxPos);
 375:load_cell.c   ****             printTrace(msg);
 376:load_cell.c   ****         }
 377:load_cell.c   ****         if (strcmp(cmdParts, "MIN") == 0)
 378:load_cell.c   ****         {
 379:load_cell.c   ****             //MIN POSITION
 380:load_cell.c   ****             minPos = atoi(strtok( NULL, cmdDelim ));
 381:load_cell.c   ****             sprintf((char *)msg,"MIN POSITION IS SET TO: %d\r\n", minPos);
 382:load_cell.c   ****             printTrace(msg);
 383:load_cell.c   ****         }
 384:load_cell.c   ****         if (strcmp(cmdParts, "SET") == 0)
 385:load_cell.c   ****         {
 386:load_cell.c   ****             //CUR POSITION
 387:load_cell.c   ****             curPos = atoi(strtok( NULL, cmdDelim ));
 388:load_cell.c   ****             sprintf((char *)msg,"CURRENT POSITION IS SET TO: %d\r\n", curPos);
 389:load_cell.c   ****             printTrace(msg);
 390:load_cell.c   ****         }
 391:load_cell.c   ****     }
 392:load_cell.c   ****     if (strcmp(cmdParts, "FORCE") == 0)
 393:load_cell.c   ****     {
 394:load_cell.c   ****         // FORCE SETTING
 395:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 396:load_cell.c   ****         if (strcmp(cmdParts, "MAX") == 0)
 397:load_cell.c   ****         {
 398:load_cell.c   ****             //MAX FORCE
 399:load_cell.c   ****             maxForce = atoi(strtok( NULL, cmdDelim ));
 400:load_cell.c   ****             sprintf((char *)msg,"MAX FORCE IS SET TO: %d\r\n", maxForce);
 401:load_cell.c   ****             printTrace(msg);
 402:load_cell.c   ****         }
 403:load_cell.c   ****         if (strcmp(cmdParts, "MIN") == 0)
 404:load_cell.c   ****         {
 405:load_cell.c   ****             //MIN FORCE
 406:load_cell.c   ****             minForce = atoi(strtok( NULL, cmdDelim ));
 407:load_cell.c   ****             sprintf((char *)msg,"MIN FORCE IS SET TO: %d\r\n", minForce);
 408:load_cell.c   ****             printTrace(msg);
 409:load_cell.c   ****         }
 410:load_cell.c   ****         if (strcmp(cmdParts, "SET") == 0)
 411:load_cell.c   ****         {
 412:load_cell.c   ****             //CUR FORCE
 413:load_cell.c   ****             curForce = atoi(strtok( NULL, cmdDelim ));
 414:load_cell.c   ****             sprintf((char *)msg,"CURRENT FORCE IS SET TO: %d\r\n", curForce);
 415:load_cell.c   ****             printTrace(msg);
 416:load_cell.c   ****         }
 417:load_cell.c   ****         //AAT process
 418:load_cell.c   ****         if (strcmp(cmdParts, "DIAGMIN") == 0)
 419:load_cell.c   ****         {
 420:load_cell.c   ****             //CUR FORCE
 421:load_cell.c   ****             minDiagForce = atoi(strtok( NULL, cmdDelim ));
 422:load_cell.c   ****             sprintf((char *)msg,"MINIMUM DIAG FORCE IS SET TO: %d\r\n", minDiagForce);
 423:load_cell.c   ****             printTrace(msg);
 424:load_cell.c   ****         }
 425:load_cell.c   ****         if (strcmp(cmdParts, "DIAGLOCK") == 0)
 426:load_cell.c   ****         {
 427:load_cell.c   ****             //CUR FORCE
 428:load_cell.c   ****             lockDiagForce = atoi(strtok( NULL, cmdDelim ));
 429:load_cell.c   ****             sprintf((char *)msg,"LOCK DIAG FORCE IS SET TO: %d\r\n", lockDiagForce);
 430:load_cell.c   ****             printTrace(msg);
 431:load_cell.c   ****         }
 432:load_cell.c   ****     }
 433:load_cell.c   ****     //AAT setting
 434:load_cell.c   ****     if (strcmp(cmdParts, "PRESSURE") == 0)
 435:load_cell.c   ****     {
 436:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 437:load_cell.c   ****         if (strcmp(cmdParts, "SETLOCK") == 0)
 438:load_cell.c   ****         {
 439:load_cell.c   ****             //LOCK PRESSURE
 440:load_cell.c   ****             lockDiagPressure = pressure;
 441:load_cell.c   ****             sprintf((char *)msg,"LOCK PRESSURE IS SET TO: %d\r\n", lockDiagPressure);
 442:load_cell.c   ****             printTrace(msg);
 443:load_cell.c   ****         }
 444:load_cell.c   ****     }
 445:load_cell.c   ****     if (strcmp(cmdParts, "SETTINGS") == 0)
 446:load_cell.c   ****     {
 447:load_cell.c   ****         //SETTINGS
 448:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 449:load_cell.c   ****         if (strcmp(cmdParts, "GET") == 0)
 450:load_cell.c   ****         {
 451:load_cell.c   ****             sprintf((char *)msg,"SETTINGS: %-80s\r\n", OUR_FLASH_ADDR);
 452:load_cell.c   ****             printTrace(msg);
 453:load_cell.c   ****         }
 454:load_cell.c   ****         if (strcmp(cmdParts, "SET") == 0)
 455:load_cell.c   ****         {
 456:load_cell.c   ****             for(int r = 0; r < 128; r++)
 457:load_cell.c   ****             {
 458:load_cell.c   ****                 settings[r] = '\0';
 459:load_cell.c   ****             }
 460:load_cell.c   ****             sprintf((char *)settings,"POSITION#MIN#%d~POSITION#MAX#%d~POSITION#SET#%d~FORCE#MIN#%d~
 461:load_cell.c   ****             settings_size = strlen(settings) + 1;
 462:load_cell.c   ****             flashWrite(OUR_FLASH_ADDR, settings, settings_size);
 463:load_cell.c   ****             printTrace(settings);
 464:load_cell.c   ****             sprintf((char *)msg,"\r\nWrote %d bytes to flash at address 0x%08X.\r\n", (3 + settings
 465:load_cell.c   ****             printTrace(msg);
 466:load_cell.c   ****         }
 467:load_cell.c   ****     }
 468:load_cell.c   ****     if (strcmp(cmdParts, "READINGS") == 0)
 469:load_cell.c   ****     {
 470:load_cell.c   ****         // READINGS
 471:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 472:load_cell.c   ****         if (strcmp(cmdParts, "START") == 0)
 473:load_cell.c   ****         {
 474:load_cell.c   ****             //START
 475:load_cell.c   ****             cmdParts = strtok( NULL, cmdDelim );
 476:load_cell.c   ****             if (strcmp(cmdParts, "TRACE") == 0)
 477:load_cell.c   ****             {
 478:load_cell.c   ****                 sprintf((char *)msg,"READINGS STARTED\r\n", maxPos);
 479:load_cell.c   ****                 printTrace(msg);
 480:load_cell.c   ****                 dataReading = 0;
 481:load_cell.c   ****             }
 482:load_cell.c   ****             if (strcmp(cmdParts, "DATA") == 0)
 483:load_cell.c   ****             {
 484:load_cell.c   ****                 dataReading = 1;
 485:load_cell.c   ****             }
 486:load_cell.c   ****             reading = 1;
 487:load_cell.c   ****         }
 488:load_cell.c   ****         if (strcmp(cmdParts, "STOP") == 0)
 489:load_cell.c   ****         {
 490:load_cell.c   ****             //STOP
 491:load_cell.c   ****             sprintf((char *)msg,"READINGS STOPPED\r\n", minPos);
 492:load_cell.c   ****             printTrace(msg);
 493:load_cell.c   ****             reading = 0;
 494:load_cell.c   ****         }
 495:load_cell.c   ****     }
 496:load_cell.c   ****     if (strcmp(cmdParts, "VALUES") == 0)
 497:load_cell.c   ****     {
 498:load_cell.c   ****         // GET CURRENT VALUES
 499:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 500:load_cell.c   ****         if (strcmp(cmdParts, "GET") == 0)
 501:load_cell.c   ****         {
 502:load_cell.c   ****             sprintf((char *)msg,"POSITION#MIN#%d~POSITION#MAX#%d~POSITION#SET#%d~FORCE#MIN#%d~FORCE
 503:load_cell.c   ****             printTrace(msg);
 504:load_cell.c   ****         }
 505:load_cell.c   ****     }
 506:load_cell.c   ****     if (strcmp(cmdParts, "LED") == 0)
 507:load_cell.c   ****     {
 508:load_cell.c   ****         // LEDs control
 509:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 510:load_cell.c   ****         if (strcmp(cmdParts, "RED") == 0)
 511:load_cell.c   ****         {
 512:load_cell.c   ****             //GREEN LED
 513:load_cell.c   ****             cmdParts = strtok( NULL, cmdDelim );
 514:load_cell.c   ****             if (strcmp(cmdParts, "ON") == 0)
 515:load_cell.c   ****             {
 516:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED1);
 517:load_cell.c   ****             }
 518:load_cell.c   ****             if (strcmp(cmdParts, "OFF") == 0)
 519:load_cell.c   ****             {
 520:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 521:load_cell.c   ****             }
 522:load_cell.c   ****             if (strcmp(cmdParts, "SET") == 0)
 523:load_cell.c   ****             {
 524:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED1);
 525:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 526:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 527:load_cell.c   ****             }
 528:load_cell.c   ****         }
 529:load_cell.c   ****         if (strcmp(cmdParts, "YELLOW") == 0)
 530:load_cell.c   ****         {ne MMC_SUCCESS           0x00
 531:load_cell.c   ****             //YELLOW LED
 532:load_cell.c   ****             cmdParts = strtok( NULL, cmdDelim );
 533:load_cell.c   ****             if (strcmp(cmdParts, "ON") == 0)
 534:load_cell.c   ****             {
 535:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED2);
 536:load_cell.c   ****             }
 537:load_cell.c   ****             if (strcmp(cmdParts, "OFF") == 0)
 538:load_cell.c   ****             {
 539:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 540:load_cell.c   ****             }
 541:load_cell.c   ****             if (strcmp(cmdParts, "SET") == 0)
 542:load_cell.c   ****             {
 543:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED2);
 544:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 545:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 546:load_cell.c   ****             }
 547:load_cell.c   ****         }
 548:load_cell.c   ****         if (strcmp(cmdParts, "GREEN") == 0)
 549:load_cell.c   ****         {
 550:load_cell.c   ****             //RED LED
 551:load_cell.c   ****             cmdParts = strtok( NULL, cmdDelim );
 552:load_cell.c   ****             if (strcmp(cmdParts, "ON") == 0)
 553:load_cell.c   ****             {
 554:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED3);
 555:load_cell.c   ****             }
 556:load_cell.c   ****             if (strcmp(cmdParts, "OFF") == 0)
 557:load_cell.c   ****             {
 558:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 559:load_cell.c   ****             }
 560:load_cell.c   ****             if (strcmp(cmdParts, "SET") == 0)
 561:load_cell.c   ****             {
 562:load_cell.c   ****                 AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED3);
 563:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 564:load_cell.c   ****                 AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 565:load_cell.c   ****             }
 566:load_cell.c   ****         }
 567:load_cell.c   ****         if (strcmp(cmdParts, "ALLOFF") == 0)
 568:load_cell.c   ****         {
 569:load_cell.c   ****             AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 570:load_cell.c   ****             AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 571:load_cell.c   ****             AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 572:load_cell.c   ****         }
 573:load_cell.c   ****     }
 574:load_cell.c   ****     */
 575:load_cell.c   ****     if (strcmp(cmdParts, "MMC") == 0)
 576:load_cell.c   ****     {
 577:load_cell.c   ****         cmdParts = strtok( NULL, cmdDelim );
 578:load_cell.c   ****         if (strcmp(cmdParts, "READ") == 0)
 579:load_cell.c   ****         {
 580:load_cell.c   ****             //INITIAL TEST
 581:load_cell.c   ****             printTrace("STORED MMC VALUES:\r\n");
 582:load_cell.c   ****             int blockIndex;
 583:load_cell.c   ****             for (blockIndex = 0; blockIndex < 2048; blockIndex++)
 584:load_cell.c   ****             {
 585:load_cell.c   ****                 memset(&mmc_buffer, 0x00, 512);
 586:load_cell.c   ****                 mmcReadBlock(blockIndex * 512, 512);
 587:load_cell.c   ****                 pCDC.Write(&pCDC, mmc_buffer, 512);
 588:load_cell.c   ****             }
 589:load_cell.c   ****             printTrace("\r\n");
 590:load_cell.c   ****             Delay(2500000);
 591:load_cell.c   ****         }
 592:load_cell.c   ****         if (strcmp(cmdParts, "CLEAR") == 0)
 593:load_cell.c   ****         {
 594:load_cell.c   ****             printTrace("CLEARING SD CARD...\r\n");
 595:load_cell.c   ****             clearMMCCard();
 596:load_cell.c   ****             printTrace("CLEARING DONE\r\n");
 597:load_cell.c   ****         }
 598:load_cell.c   ****         if (strcmp(cmdParts, "START") == 0)
 599:load_cell.c   ****         {
 600:load_cell.c   ****             storingOnMMC = 1;
 601:load_cell.c   ****         }
 602:load_cell.c   ****         if (strcmp(cmdParts, "STOP") == 0)
 603:load_cell.c   ****         {
 604:load_cell.c   ****             storingOnMMC = 0;
 605:load_cell.c   ****         }
 606:load_cell.c   ****     }
 607:load_cell.c   **** }
 608:load_cell.c   **** 
 609:load_cell.c   **** void putCharToMMCBuffer(char c)
 610:load_cell.c   **** {
 172              		.loc 1 610 0
 173              		@ args = 0, pretend = 0, frame = 0
 174              		@ frame_needed = 0, uses_anonymous_args = 0
 175              	.LVL5:
 611:load_cell.c   ****     if (mmc_buffer_index < 512)
 176              		.loc 1 611 0
 177 0108 64209FE5 		ldr	r2, .L31
 178 010c 003092E5 		ldr	r3, [r2, #0]
 179              		.loc 1 610 0
 180 0110 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 181              	.LCFI4:
 182 0114 5C509FE5 		ldr	r5, .L31+4
 183              		.loc 1 611 0
 184 0118 020C53E3 		cmp	r3, #512
 612:load_cell.c   ****     {
 613:load_cell.c   ****         mmc_buffer[mmc_buffer_index] = c;
 614:load_cell.c   ****         mmc_buffer_index++;
 185              		.loc 1 614 0
 186 011c 011083E2 		add	r1, r3, #1
 187              		.loc 1 610 0
 188 0120 FF0000E2 		and	r0, r0, #255
 615:load_cell.c   ****     }
 616:load_cell.c   ****     else
 617:load_cell.c   ****     {
 618:load_cell.c   ****         mmc_buffer_index = 0;
 619:load_cell.c   ****         mmcWriteBlock(mmc_block_index);
 189              		.loc 1 619 0
 190 0124 50409FE5 		ldr	r4, .L31+8
 191              		.loc 1 618 0
 192 0128 0060A0E3 		mov	r6, #0
 193              		.loc 1 613 0
 194 012c 0300C5B7 		strltb	r0, [r5, r3]
 195              		.loc 1 614 0
 196 0130 001082B5 		strlt	r1, [r2, #0]
 197              		.loc 1 611 0
 198 0134 7080BDB8 		ldmltfd	sp!, {r4, r5, r6, pc}
 199              		.loc 1 618 0
 200 0138 006082E5 		str	r6, [r2, #0]
 201              		.loc 1 619 0
 202 013c 000094E5 		ldr	r0, [r4, #0]
 203              	.LVL6:
 204 0140 FEFFFFEB 		bl	mmcWriteBlock
 620:load_cell.c   ****         mmc_block_index += 512;
 205              		.loc 1 620 0
 206 0144 003094E5 		ldr	r3, [r4, #0]
 621:load_cell.c   **** 
 622:load_cell.c   ****         memset(&mmc_buffer, 0x00, 512);
 207              		.loc 1 622 0
 208 0148 0610A0E1 		mov	r1, r6
 209              		.loc 1 620 0
 210 014c 023C83E2 		add	r3, r3, #512
 211              		.loc 1 622 0
 212 0150 0500A0E1 		mov	r0, r5
 213 0154 022CA0E3 		mov	r2, #512
 214              		.loc 1 620 0
 215 0158 003084E5 		str	r3, [r4, #0]
 216              		.loc 1 622 0
 217 015c FEFFFFEB 		bl	memset
 623:load_cell.c   ****         mmcReadBlock(mmc_block_index - 512, 512);
 218              		.loc 1 623 0
 219 0160 000094E5 		ldr	r0, [r4, #0]
 220 0164 021CA0E3 		mov	r1, #512
 221 0168 020C40E2 		sub	r0, r0, #512
 624:load_cell.c   ****         //pCDC.Write(&pCDC, mmc_buffer, 512);
 625:load_cell.c   ****     }
 626:load_cell.c   **** }
 222              		.loc 1 626 0
 223 016c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 224              		.loc 1 623 0
 225 0170 FEFFFFEA 		b	mmcReadBlock
 226              	.L32:
 227              		.align	2
 228              	.L31:
 229 0174 00000000 		.word	mmc_buffer_index
 230 0178 00000000 		.word	mmc_buffer
 231 017c 00000000 		.word	mmc_block_index
 232              	.LFE301:
 234              		.align	2
 235              		.global	AT91F_USB_Open
 237              	AT91F_USB_Open:
 238              	.LFB287:
 239              		.loc 1 122 0
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		.loc 1 124 0
 243 0180 032CE0E3 		mvn	r2, #768
 244 0184 D33012E5 		ldr	r3, [r2, #-211]
 245              		.loc 1 122 0
 246 0188 04E02DE5 		str	lr, [sp, #-4]!
 247              	.LCFI5:
 248              		.loc 1 124 0
 249 018c 013283E3 		orr	r3, r3, #268435456
 250 0190 D33002E5 		str	r3, [r2, #-211]
 251              		.loc 1 138 0
 252 0194 2C009FE5 		ldr	r0, .L35
 253              		.loc 1 128 0
 254 0198 8030A0E3 		mov	r3, #128
 255              		.loc 1 138 0
 256 019c 28109FE5 		ldr	r1, .L35+4
 257              		.loc 1 128 0
 258 01a0 FF3002E5 		str	r3, [r2, #-255]
 259              	.LBB7:
 260              	.LBB8:
 261              		.file 2 "lib_AT91SAM7S64.h"
   1:lib_AT91SAM7S64.h **** //* ----------------------------------------------------------------------------
   2:lib_AT91SAM7S64.h **** //*         ATMEL Microcontroller Software Support  -  ROUSSET  -
   3:lib_AT91SAM7S64.h **** //* ----------------------------------------------------------------------------
   4:lib_AT91SAM7S64.h **** //* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
   5:lib_AT91SAM7S64.h **** //* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   6:lib_AT91SAM7S64.h **** //* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
   7:lib_AT91SAM7S64.h **** //* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
   8:lib_AT91SAM7S64.h **** //* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   9:lib_AT91SAM7S64.h **** //* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  10:lib_AT91SAM7S64.h **** //* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  11:lib_AT91SAM7S64.h **** //* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  12:lib_AT91SAM7S64.h **** //* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  13:lib_AT91SAM7S64.h **** //* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  14:lib_AT91SAM7S64.h **** //* ----------------------------------------------------------------------------
  15:lib_AT91SAM7S64.h **** //* File Name           : lib_AT91SAM7S64.h
  16:lib_AT91SAM7S64.h **** //* Object              : AT91SAM7S64 inlined functions
  17:lib_AT91SAM7S64.h **** //* Generated           : AT91 SW Application Group  03/08/2005 (15:46:05)
  18:lib_AT91SAM7S64.h **** //*
  19:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_dbgu.h/1.1/Fri Jan 31 12:18:40 2003//
  20:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_pmc_SAM7S.h/1.1/Tue Feb  1 08:32:10 2005//
  21:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_VREG_6085B.h/1.1/Tue Feb  1 16:20:47 2005//
  22:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_rstc_6098A.h/1.1/Wed Oct  6 10:39:20 2004//
  23:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_ssc.h/1.4/Fri Jan 31 12:19:20 2003//
  24:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_wdtc_6080A.h/1.1/Wed Oct  6 10:38:30 2004//
  25:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_usart.h/1.5/Thu Nov 21 16:01:54 2002//
  26:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_spi2.h/1.1/Mon Aug 25 14:23:52 2003//
  27:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_pitc_6079A.h/1.2/Tue Nov  9 14:43:56 2004//
  28:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_aic.h/1.3/Fri Jul 12 08:46:12 2002//
  29:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_twi.h/1.3/Mon Jul 19 14:27:58 2004//
  30:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_adc.h/1.6/Fri Oct 17 09:12:38 2003//
  31:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_rttc_6081A.h/1.1/Wed Oct  6 10:39:38 2004//
  32:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_udp.h/1.4/Wed Feb 16 08:39:34 2005//
  33:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_tc_1753b.h/1.1/Fri Jan 31 12:20:02 2003//
  34:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_MC_SAM7S.h/1.1/Thu Mar 25 15:19:14 2004//
  35:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_pio.h/1.3/Fri Jan 31 12:18:56 2003//
  36:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_PWM_SAM.h/1.3/Thu Jan 22 10:10:50 2004//
  37:lib_AT91SAM7S64.h **** //* CVS Reference       : /lib_pdc.h/1.2/Tue Jul  2 13:29:40 2002//
  38:lib_AT91SAM7S64.h **** //* ----------------------------------------------------------------------------
  39:lib_AT91SAM7S64.h **** 
  40:lib_AT91SAM7S64.h **** #ifndef lib_AT91SAM7S64_H
  41:lib_AT91SAM7S64.h **** #define lib_AT91SAM7S64_H
  42:lib_AT91SAM7S64.h **** 
  43:lib_AT91SAM7S64.h **** /* *****************************************************************************
  44:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR AIC
  45:lib_AT91SAM7S64.h ****    ***************************************************************************** */
  46:lib_AT91SAM7S64.h **** #define AT91C_AIC_BRANCH_OPCODE ((void (*) ()) 0xE51FFF20) // ldr, pc, [pc, #-&F20]
  47:lib_AT91SAM7S64.h **** 
  48:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  49:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_ConfigureIt
  50:lib_AT91SAM7S64.h **** //* \brief Interrupt Handler Initialization
  51:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  52:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_AIC_ConfigureIt (
  53:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
  54:lib_AT91SAM7S64.h **** 	unsigned int irq_id,     // \arg interrupt number to initialize
  55:lib_AT91SAM7S64.h **** 	unsigned int priority,   // \arg priority to give to the interrupt
  56:lib_AT91SAM7S64.h **** 	unsigned int src_type,   // \arg activation and sense of activation
  57:lib_AT91SAM7S64.h **** 	void (*newHandler) (void) ) // \arg address of the interrupt handler
  58:lib_AT91SAM7S64.h **** {
  59:lib_AT91SAM7S64.h **** 	unsigned int oldHandler;
  60:lib_AT91SAM7S64.h ****     unsigned int mask ;
  61:lib_AT91SAM7S64.h **** 
  62:lib_AT91SAM7S64.h ****     oldHandler = pAic->AIC_SVR[irq_id];
  63:lib_AT91SAM7S64.h **** 
  64:lib_AT91SAM7S64.h ****     mask = 0x1 << irq_id ;
  65:lib_AT91SAM7S64.h ****     //* Disable the interrupt on the interrupt controller
  66:lib_AT91SAM7S64.h ****     pAic->AIC_IDCR = mask ;
  67:lib_AT91SAM7S64.h ****     //* Save the interrupt handler routine pointer and the interrupt priority
  68:lib_AT91SAM7S64.h ****     pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
  69:lib_AT91SAM7S64.h ****     //* Store the Source Mode Register
  70:lib_AT91SAM7S64.h ****     pAic->AIC_SMR[irq_id] = src_type | priority  ;
  71:lib_AT91SAM7S64.h ****     //* Clear the interrupt on the interrupt controller
  72:lib_AT91SAM7S64.h ****     pAic->AIC_ICCR = mask ;
  73:lib_AT91SAM7S64.h **** 
  74:lib_AT91SAM7S64.h **** 	return oldHandler;
  75:lib_AT91SAM7S64.h **** }
  76:lib_AT91SAM7S64.h **** 
  77:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  78:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_EnableIt
  79:lib_AT91SAM7S64.h **** //* \brief Enable corresponding IT number
  80:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  81:lib_AT91SAM7S64.h **** __inline void AT91F_AIC_EnableIt (
  82:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  83:lib_AT91SAM7S64.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  84:lib_AT91SAM7S64.h **** {
  85:lib_AT91SAM7S64.h ****     //* Enable the interrupt on the interrupt controller
  86:lib_AT91SAM7S64.h ****     pAic->AIC_IECR = 0x1 << irq_id ;
  87:lib_AT91SAM7S64.h **** }
  88:lib_AT91SAM7S64.h **** 
  89:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  90:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_DisableIt
  91:lib_AT91SAM7S64.h **** //* \brief Disable corresponding IT number
  92:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
  93:lib_AT91SAM7S64.h **** __inline void AT91F_AIC_DisableIt (
  94:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
  95:lib_AT91SAM7S64.h **** 	unsigned int irq_id ) // \arg interrupt number to initialize
  96:lib_AT91SAM7S64.h **** {
  97:lib_AT91SAM7S64.h ****     unsigned int mask = 0x1 << irq_id;
  98:lib_AT91SAM7S64.h ****     //* Disable the interrupt on the interrupt controller
  99:lib_AT91SAM7S64.h ****     pAic->AIC_IDCR = mask ;
 100:lib_AT91SAM7S64.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 101:lib_AT91SAM7S64.h ****     pAic->AIC_ICCR = mask ;
 102:lib_AT91SAM7S64.h **** }
 103:lib_AT91SAM7S64.h **** 
 104:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 105:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_ClearIt
 106:lib_AT91SAM7S64.h **** //* \brief Clear corresponding IT number
 107:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 108:lib_AT91SAM7S64.h **** __inline void AT91F_AIC_ClearIt (
 109:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 110:lib_AT91SAM7S64.h **** 	unsigned int irq_id) // \arg interrupt number to initialize
 111:lib_AT91SAM7S64.h **** {
 112:lib_AT91SAM7S64.h ****     //* Clear the interrupt on the Interrupt Controller ( if one is pending )
 113:lib_AT91SAM7S64.h ****     pAic->AIC_ICCR = (0x1 << irq_id);
 114:lib_AT91SAM7S64.h **** }
 115:lib_AT91SAM7S64.h **** 
 116:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 117:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_AcknowledgeIt
 118:lib_AT91SAM7S64.h **** //* \brief Acknowledge corresponding IT number
 119:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 120:lib_AT91SAM7S64.h **** __inline void AT91F_AIC_AcknowledgeIt (
 121:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic)     // \arg pointer to the AIC registers
 122:lib_AT91SAM7S64.h **** {
 123:lib_AT91SAM7S64.h ****     pAic->AIC_EOICR = pAic->AIC_EOICR;
 124:lib_AT91SAM7S64.h **** }
 125:lib_AT91SAM7S64.h **** 
 126:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 127:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_SetExceptionVector
 128:lib_AT91SAM7S64.h **** //* \brief Configure vector handler
 129:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 130:lib_AT91SAM7S64.h **** __inline unsigned int  AT91F_AIC_SetExceptionVector (
 131:lib_AT91SAM7S64.h **** 	unsigned int *pVector, // \arg pointer to the AIC registers
 132:lib_AT91SAM7S64.h **** 	void (*Handler) () )   // \arg Interrupt Handler
 133:lib_AT91SAM7S64.h **** {
 134:lib_AT91SAM7S64.h **** 	unsigned int oldVector = *pVector;
 135:lib_AT91SAM7S64.h **** 
 136:lib_AT91SAM7S64.h **** 	if ((unsigned int) Handler == (unsigned int) AT91C_AIC_BRANCH_OPCODE)
 137:lib_AT91SAM7S64.h **** 		*pVector = (unsigned int) AT91C_AIC_BRANCH_OPCODE;
 138:lib_AT91SAM7S64.h **** 	else
 139:lib_AT91SAM7S64.h **** 		*pVector = (((((unsigned int) Handler) - ((unsigned int) pVector) - 0x8) >> 2) & 0x00FFFFFF) | 0x
 140:lib_AT91SAM7S64.h **** 
 141:lib_AT91SAM7S64.h **** 	return oldVector;
 142:lib_AT91SAM7S64.h **** }
 143:lib_AT91SAM7S64.h **** 
 144:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 145:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_Trig
 146:lib_AT91SAM7S64.h **** //* \brief Trig an IT
 147:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 148:lib_AT91SAM7S64.h **** __inline void  AT91F_AIC_Trig (
 149:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 150:lib_AT91SAM7S64.h **** 	unsigned int irq_id) // \arg interrupt number
 151:lib_AT91SAM7S64.h **** {
 152:lib_AT91SAM7S64.h **** 	pAic->AIC_ISCR = (0x1 << irq_id) ;
 153:lib_AT91SAM7S64.h **** }
 154:lib_AT91SAM7S64.h **** 
 155:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 156:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_IsActive
 157:lib_AT91SAM7S64.h **** //* \brief Test if an IT is active
 158:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 159:lib_AT91SAM7S64.h **** __inline unsigned int  AT91F_AIC_IsActive (
 160:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 161:lib_AT91SAM7S64.h **** 	unsigned int irq_id) // \arg Interrupt Number
 162:lib_AT91SAM7S64.h **** {
 163:lib_AT91SAM7S64.h **** 	return (pAic->AIC_ISR & (0x1 << irq_id));
 164:lib_AT91SAM7S64.h **** }
 165:lib_AT91SAM7S64.h **** 
 166:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 167:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_IsPending
 168:lib_AT91SAM7S64.h **** //* \brief Test if an IT is pending
 169:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 170:lib_AT91SAM7S64.h **** __inline unsigned int  AT91F_AIC_IsPending (
 171:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
 172:lib_AT91SAM7S64.h **** 	unsigned int irq_id) // \arg Interrupt Number
 173:lib_AT91SAM7S64.h **** {
 174:lib_AT91SAM7S64.h **** 	return (pAic->AIC_IPR & (0x1 << irq_id));
 175:lib_AT91SAM7S64.h **** }
 176:lib_AT91SAM7S64.h **** 
 177:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 178:lib_AT91SAM7S64.h **** //* \fn    AT91F_AIC_Open
 179:lib_AT91SAM7S64.h **** //* \brief Set exception vectors and AIC registers to default values
 180:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 181:lib_AT91SAM7S64.h **** __inline void AT91F_AIC_Open(
 182:lib_AT91SAM7S64.h **** 	AT91PS_AIC pAic,        // \arg pointer to the AIC registers
 183:lib_AT91SAM7S64.h **** 	void (*IrqHandler) (),  // \arg Default IRQ vector exception
 184:lib_AT91SAM7S64.h **** 	void (*FiqHandler) (),  // \arg Default FIQ vector exception
 185:lib_AT91SAM7S64.h **** 	void (*DefaultHandler)  (), // \arg Default Handler set in ISR
 186:lib_AT91SAM7S64.h **** 	void (*SpuriousHandler) (), // \arg Default Spurious Handler
 187:lib_AT91SAM7S64.h **** 	unsigned int protectMode)   // \arg Debug Control Register
 188:lib_AT91SAM7S64.h **** {
 189:lib_AT91SAM7S64.h **** 	int i;
 190:lib_AT91SAM7S64.h **** 
 191:lib_AT91SAM7S64.h **** 	// Disable all interrupts and set IVR to the default handler
 192:lib_AT91SAM7S64.h **** 	for (i = 0; i < 32; ++i) {
 193:lib_AT91SAM7S64.h **** 		AT91F_AIC_DisableIt(pAic, i);
 194:lib_AT91SAM7S64.h **** 		AT91F_AIC_ConfigureIt(pAic, i, AT91C_AIC_PRIOR_LOWEST, AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE, Def
 195:lib_AT91SAM7S64.h **** 	}
 196:lib_AT91SAM7S64.h **** 
 197:lib_AT91SAM7S64.h **** 	// Set the IRQ exception vector
 198:lib_AT91SAM7S64.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x18, IrqHandler);
 199:lib_AT91SAM7S64.h **** 	// Set the Fast Interrupt exception vector
 200:lib_AT91SAM7S64.h **** 	AT91F_AIC_SetExceptionVector((unsigned int *) 0x1C, FiqHandler);
 201:lib_AT91SAM7S64.h **** 
 202:lib_AT91SAM7S64.h **** 	pAic->AIC_SPU = (unsigned int) SpuriousHandler;
 203:lib_AT91SAM7S64.h **** 	pAic->AIC_DCR = protectMode;
 204:lib_AT91SAM7S64.h **** }
 205:lib_AT91SAM7S64.h **** /* *****************************************************************************
 206:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR PDC
 207:lib_AT91SAM7S64.h ****    ***************************************************************************** */
 208:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 209:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_SetNextRx
 210:lib_AT91SAM7S64.h **** //* \brief Set the next receive transfer descriptor
 211:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 212:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_SetNextRx (
 213:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,     // \arg pointer to a PDC controller
 214:lib_AT91SAM7S64.h **** 	char *address,       // \arg address to the next bloc to be received
 215:lib_AT91SAM7S64.h **** 	unsigned int bytes)  // \arg number of bytes to be received
 216:lib_AT91SAM7S64.h **** {
 217:lib_AT91SAM7S64.h **** 	pPDC->PDC_RNPR = (unsigned int) address;
 218:lib_AT91SAM7S64.h **** 	pPDC->PDC_RNCR = bytes;
 219:lib_AT91SAM7S64.h **** }
 220:lib_AT91SAM7S64.h **** 
 221:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 222:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_SetNextTx
 223:lib_AT91SAM7S64.h **** //* \brief Set the next transmit transfer descriptor
 224:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 225:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_SetNextTx (
 226:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 227:lib_AT91SAM7S64.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 228:lib_AT91SAM7S64.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 229:lib_AT91SAM7S64.h **** {
 230:lib_AT91SAM7S64.h **** 	pPDC->PDC_TNPR = (unsigned int) address;
 231:lib_AT91SAM7S64.h **** 	pPDC->PDC_TNCR = bytes;
 232:lib_AT91SAM7S64.h **** }
 233:lib_AT91SAM7S64.h **** 
 234:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 235:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_SetRx
 236:lib_AT91SAM7S64.h **** //* \brief Set the receive transfer descriptor
 237:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 238:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_SetRx (
 239:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 240:lib_AT91SAM7S64.h **** 	char *address,         // \arg address to the next bloc to be received
 241:lib_AT91SAM7S64.h **** 	unsigned int bytes)    // \arg number of bytes to be received
 242:lib_AT91SAM7S64.h **** {
 243:lib_AT91SAM7S64.h **** 	pPDC->PDC_RPR = (unsigned int) address;
 244:lib_AT91SAM7S64.h **** 	pPDC->PDC_RCR = bytes;
 245:lib_AT91SAM7S64.h **** }
 246:lib_AT91SAM7S64.h **** 
 247:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 248:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_SetTx
 249:lib_AT91SAM7S64.h **** //* \brief Set the transmit transfer descriptor
 250:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 251:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_SetTx (
 252:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
 253:lib_AT91SAM7S64.h **** 	char *address,         // \arg address to the next bloc to be transmitted
 254:lib_AT91SAM7S64.h **** 	unsigned int bytes)    // \arg number of bytes to be transmitted
 255:lib_AT91SAM7S64.h **** {
 256:lib_AT91SAM7S64.h **** 	pPDC->PDC_TPR = (unsigned int) address;
 257:lib_AT91SAM7S64.h **** 	pPDC->PDC_TCR = bytes;
 258:lib_AT91SAM7S64.h **** }
 259:lib_AT91SAM7S64.h **** 
 260:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 261:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_EnableTx
 262:lib_AT91SAM7S64.h **** //* \brief Enable transmit
 263:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 264:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_EnableTx (
 265:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 266:lib_AT91SAM7S64.h **** {
 267:lib_AT91SAM7S64.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
 268:lib_AT91SAM7S64.h **** }
 269:lib_AT91SAM7S64.h **** 
 270:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 271:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_EnableRx
 272:lib_AT91SAM7S64.h **** //* \brief Enable receive
 273:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 274:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_EnableRx (
 275:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 276:lib_AT91SAM7S64.h **** {
 277:lib_AT91SAM7S64.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTEN;
 278:lib_AT91SAM7S64.h **** }
 279:lib_AT91SAM7S64.h **** 
 280:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 281:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_DisableTx
 282:lib_AT91SAM7S64.h **** //* \brief Disable transmit
 283:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 284:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_DisableTx (
 285:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 286:lib_AT91SAM7S64.h **** {
 287:lib_AT91SAM7S64.h **** 	pPDC->PDC_PTCR = AT91C_PDC_TXTDIS;
 288:lib_AT91SAM7S64.h **** }
 289:lib_AT91SAM7S64.h **** 
 290:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 291:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_DisableRx
 292:lib_AT91SAM7S64.h **** //* \brief Disable receive
 293:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 294:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_DisableRx (
 295:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 296:lib_AT91SAM7S64.h **** {
 297:lib_AT91SAM7S64.h **** 	pPDC->PDC_PTCR = AT91C_PDC_RXTDIS;
 298:lib_AT91SAM7S64.h **** }
 299:lib_AT91SAM7S64.h **** 
 300:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 301:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_IsTxEmpty
 302:lib_AT91SAM7S64.h **** //* \brief Test if the current transfer descriptor has been sent
 303:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 304:lib_AT91SAM7S64.h **** __inline int AT91F_PDC_IsTxEmpty ( // \return return 1 if transfer is complete
 305:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 306:lib_AT91SAM7S64.h **** {
 307:lib_AT91SAM7S64.h **** 	return !(pPDC->PDC_TCR);
 308:lib_AT91SAM7S64.h **** }
 309:lib_AT91SAM7S64.h **** 
 310:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 311:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_IsNextTxEmpty
 312:lib_AT91SAM7S64.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 313:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 314:lib_AT91SAM7S64.h **** __inline int AT91F_PDC_IsNextTxEmpty ( // \return return 1 if transfer is complete
 315:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 316:lib_AT91SAM7S64.h **** {
 317:lib_AT91SAM7S64.h **** 	return !(pPDC->PDC_TNCR);
 318:lib_AT91SAM7S64.h **** }
 319:lib_AT91SAM7S64.h **** 
 320:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 321:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_IsRxEmpty
 322:lib_AT91SAM7S64.h **** //* \brief Test if the current transfer descriptor has been filled
 323:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 324:lib_AT91SAM7S64.h **** __inline int AT91F_PDC_IsRxEmpty ( // \return return 1 if transfer is complete
 325:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 326:lib_AT91SAM7S64.h **** {
 327:lib_AT91SAM7S64.h **** 	return !(pPDC->PDC_RCR);
 328:lib_AT91SAM7S64.h **** }
 329:lib_AT91SAM7S64.h **** 
 330:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 331:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_IsNextRxEmpty
 332:lib_AT91SAM7S64.h **** //* \brief Test if the next transfer descriptor has been moved to the current td
 333:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 334:lib_AT91SAM7S64.h **** __inline int AT91F_PDC_IsNextRxEmpty ( // \return return 1 if transfer is complete
 335:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
 336:lib_AT91SAM7S64.h **** {
 337:lib_AT91SAM7S64.h **** 	return !(pPDC->PDC_RNCR);
 338:lib_AT91SAM7S64.h **** }
 339:lib_AT91SAM7S64.h **** 
 340:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 341:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_Open
 342:lib_AT91SAM7S64.h **** //* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
 343:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 344:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_Open (
 345:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 346:lib_AT91SAM7S64.h **** {
 347:lib_AT91SAM7S64.h ****     //* Disable the RX and TX PDC transfer requests
 348:lib_AT91SAM7S64.h **** 	AT91F_PDC_DisableRx(pPDC);
 349:lib_AT91SAM7S64.h **** 	AT91F_PDC_DisableTx(pPDC);
 350:lib_AT91SAM7S64.h **** 
 351:lib_AT91SAM7S64.h **** 	//* Reset all Counter register Next buffer first
 352:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 353:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 354:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 355:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 356:lib_AT91SAM7S64.h **** 
 357:lib_AT91SAM7S64.h ****     //* Enable the RX and TX PDC transfer requests
 358:lib_AT91SAM7S64.h **** 	AT91F_PDC_EnableRx(pPDC);
 359:lib_AT91SAM7S64.h **** 	AT91F_PDC_EnableTx(pPDC);
 360:lib_AT91SAM7S64.h **** }
 361:lib_AT91SAM7S64.h **** 
 362:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 363:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_Close
 364:lib_AT91SAM7S64.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 365:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 366:lib_AT91SAM7S64.h **** __inline void AT91F_PDC_Close (
 367:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
 368:lib_AT91SAM7S64.h **** {
 369:lib_AT91SAM7S64.h ****     //* Disable the RX and TX PDC transfer requests
 370:lib_AT91SAM7S64.h **** 	AT91F_PDC_DisableRx(pPDC);
 371:lib_AT91SAM7S64.h **** 	AT91F_PDC_DisableTx(pPDC);
 372:lib_AT91SAM7S64.h **** 
 373:lib_AT91SAM7S64.h **** 	//* Reset all Counter register Next buffer first
 374:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
 375:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
 376:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
 377:lib_AT91SAM7S64.h **** 	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
 378:lib_AT91SAM7S64.h **** 
 379:lib_AT91SAM7S64.h **** }
 380:lib_AT91SAM7S64.h **** 
 381:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 382:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_SendFrame
 383:lib_AT91SAM7S64.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 384:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 385:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PDC_SendFrame(
 386:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,
 387:lib_AT91SAM7S64.h **** 	char *pBuffer,
 388:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
 389:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
 390:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
 391:lib_AT91SAM7S64.h **** {
 392:lib_AT91SAM7S64.h **** 	if (AT91F_PDC_IsTxEmpty(pPDC)) {
 393:lib_AT91SAM7S64.h **** 		//* Buffer and next buffer can be initialized
 394:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetTx(pPDC, pBuffer, szBuffer);
 395:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetNextTx(pPDC, pNextBuffer, szNextBuffer);
 396:lib_AT91SAM7S64.h **** 		return 2;
 397:lib_AT91SAM7S64.h **** 	}
 398:lib_AT91SAM7S64.h **** 	else if (AT91F_PDC_IsNextTxEmpty(pPDC)) {
 399:lib_AT91SAM7S64.h **** 		//* Only one buffer can be initialized
 400:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetNextTx(pPDC, pBuffer, szBuffer);
 401:lib_AT91SAM7S64.h **** 		return 1;
 402:lib_AT91SAM7S64.h **** 	}
 403:lib_AT91SAM7S64.h **** 	else {
 404:lib_AT91SAM7S64.h **** 		//* All buffer are in use...
 405:lib_AT91SAM7S64.h **** 		return 0;
 406:lib_AT91SAM7S64.h **** 	}
 407:lib_AT91SAM7S64.h **** }
 408:lib_AT91SAM7S64.h **** 
 409:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 410:lib_AT91SAM7S64.h **** //* \fn    AT91F_PDC_ReceiveFrame
 411:lib_AT91SAM7S64.h **** //* \brief Close PDC: disable TX and RX reset transfer descriptors
 412:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 413:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PDC_ReceiveFrame (
 414:lib_AT91SAM7S64.h **** 	AT91PS_PDC pPDC,
 415:lib_AT91SAM7S64.h **** 	char *pBuffer,
 416:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
 417:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
 418:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
 419:lib_AT91SAM7S64.h **** {
 420:lib_AT91SAM7S64.h **** 	if (AT91F_PDC_IsRxEmpty(pPDC)) {
 421:lib_AT91SAM7S64.h **** 		//* Buffer and next buffer can be initialized
 422:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetRx(pPDC, pBuffer, szBuffer);
 423:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetNextRx(pPDC, pNextBuffer, szNextBuffer);
 424:lib_AT91SAM7S64.h **** 		return 2;
 425:lib_AT91SAM7S64.h **** 	}
 426:lib_AT91SAM7S64.h **** 	else if (AT91F_PDC_IsNextRxEmpty(pPDC)) {
 427:lib_AT91SAM7S64.h **** 		//* Only one buffer can be initialized
 428:lib_AT91SAM7S64.h **** 		AT91F_PDC_SetNextRx(pPDC, pBuffer, szBuffer);
 429:lib_AT91SAM7S64.h **** 		return 1;
 430:lib_AT91SAM7S64.h **** 	}
 431:lib_AT91SAM7S64.h **** 	else {
 432:lib_AT91SAM7S64.h **** 		//* All buffer are in use...
 433:lib_AT91SAM7S64.h **** 		return 0;
 434:lib_AT91SAM7S64.h **** 	}
 435:lib_AT91SAM7S64.h **** }
 436:lib_AT91SAM7S64.h **** /* *****************************************************************************
 437:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR DBGU
 438:lib_AT91SAM7S64.h ****    ***************************************************************************** */
 439:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 440:lib_AT91SAM7S64.h **** //* \fn    AT91F_DBGU_InterruptEnable
 441:lib_AT91SAM7S64.h **** //* \brief Enable DBGU Interrupt
 442:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 443:lib_AT91SAM7S64.h **** __inline void AT91F_DBGU_InterruptEnable(
 444:lib_AT91SAM7S64.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 445:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  dbgu interrupt to be enabled
 446:lib_AT91SAM7S64.h **** {
 447:lib_AT91SAM7S64.h ****         pDbgu->DBGU_IER = flag;
 448:lib_AT91SAM7S64.h **** }
 449:lib_AT91SAM7S64.h **** 
 450:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 451:lib_AT91SAM7S64.h **** //* \fn    AT91F_DBGU_InterruptDisable
 452:lib_AT91SAM7S64.h **** //* \brief Disable DBGU Interrupt
 453:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 454:lib_AT91SAM7S64.h **** __inline void AT91F_DBGU_InterruptDisable(
 455:lib_AT91SAM7S64.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 456:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  dbgu interrupt to be disabled
 457:lib_AT91SAM7S64.h **** {
 458:lib_AT91SAM7S64.h ****         pDbgu->DBGU_IDR = flag;
 459:lib_AT91SAM7S64.h **** }
 460:lib_AT91SAM7S64.h **** 
 461:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 462:lib_AT91SAM7S64.h **** //* \fn    AT91F_DBGU_GetInterruptMaskStatus
 463:lib_AT91SAM7S64.h **** //* \brief Return DBGU Interrupt Mask Status
 464:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 465:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_DBGU_GetInterruptMaskStatus( // \return DBGU Interrupt Mask Status
 466:lib_AT91SAM7S64.h ****         AT91PS_DBGU pDbgu) // \arg  pointer to a DBGU controller
 467:lib_AT91SAM7S64.h **** {
 468:lib_AT91SAM7S64.h ****         return pDbgu->DBGU_IMR;
 469:lib_AT91SAM7S64.h **** }
 470:lib_AT91SAM7S64.h **** 
 471:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 472:lib_AT91SAM7S64.h **** //* \fn    AT91F_DBGU_IsInterruptMasked
 473:lib_AT91SAM7S64.h **** //* \brief Test if DBGU Interrupt is Masked 
 474:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 475:lib_AT91SAM7S64.h **** __inline int AT91F_DBGU_IsInterruptMasked(
 476:lib_AT91SAM7S64.h ****         AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
 477:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 478:lib_AT91SAM7S64.h **** {
 479:lib_AT91SAM7S64.h ****         return (AT91F_DBGU_GetInterruptMaskStatus(pDbgu) & flag);
 480:lib_AT91SAM7S64.h **** }
 481:lib_AT91SAM7S64.h **** 
 482:lib_AT91SAM7S64.h **** /* *****************************************************************************
 483:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR PIO
 484:lib_AT91SAM7S64.h ****    ***************************************************************************** */
 485:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 486:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgPeriph
 487:lib_AT91SAM7S64.h **** //* \brief Enable pins to be drived by peripheral
 488:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 489:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgPeriph(
 490:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 491:lib_AT91SAM7S64.h **** 	unsigned int periphAEnable,  // \arg PERIPH A to enable
 492:lib_AT91SAM7S64.h **** 	unsigned int periphBEnable)  // \arg PERIPH B to enable
 493:lib_AT91SAM7S64.h **** 
 494:lib_AT91SAM7S64.h **** {
 495:lib_AT91SAM7S64.h **** 	pPio->PIO_ASR = periphAEnable;
 496:lib_AT91SAM7S64.h **** 	pPio->PIO_BSR = periphBEnable;
 497:lib_AT91SAM7S64.h **** 	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
 498:lib_AT91SAM7S64.h **** }
 499:lib_AT91SAM7S64.h **** 
 500:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 501:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgOutput
 502:lib_AT91SAM7S64.h **** //* \brief Enable PIO in output mode
 503:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 504:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgOutput(
 505:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 506:lib_AT91SAM7S64.h **** 	unsigned int pioEnable)      // \arg PIO to be enabled
 507:lib_AT91SAM7S64.h **** {
 508:lib_AT91SAM7S64.h **** 	pPio->PIO_PER = pioEnable; // Set in PIO mode
 262              		.loc 2 508 0
 263 01a4 0BECE0E3 		mvn	lr, #2816
 264 01a8 01C8A0E3 		mov	ip, #65536
 265              	.LBE8:
 266              	.LBE7:
 267              		.loc 1 129 0
 268 01ac 1E3D83E2 		add	r3, r3, #1920
 269 01b0 EF3002E5 		str	r3, [r2, #-239]
 270              	.LBB9:
 271              	.LBB10:
 272              		.loc 2 508 0
 273 01b4 FFC00EE5 		str	ip, [lr, #-255]
 509:lib_AT91SAM7S64.h **** 	pPio->PIO_OER = pioEnable; // Configure in Output
 274              		.loc 2 509 0
 275 01b8 EFC00EE5 		str	ip, [lr, #-239]
 276              	.LBE10:
 277              	.LBE9:
 278              	.LBB11:
 279              	.LBB12:
 510:lib_AT91SAM7S64.h **** }
 511:lib_AT91SAM7S64.h **** 
 512:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 513:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgInput
 514:lib_AT91SAM7S64.h **** //* \brief Enable PIO in input mode
 515:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 516:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgInput(
 517:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 518:lib_AT91SAM7S64.h **** 	unsigned int inputEnable)      // \arg PIO to be enabled
 519:lib_AT91SAM7S64.h **** {
 520:lib_AT91SAM7S64.h **** 	// Disable output
 521:lib_AT91SAM7S64.h **** 	pPio->PIO_ODR  = inputEnable;
 522:lib_AT91SAM7S64.h **** 	pPio->PIO_PER  = inputEnable;
 523:lib_AT91SAM7S64.h **** }
 524:lib_AT91SAM7S64.h **** 
 525:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 526:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgOpendrain
 527:lib_AT91SAM7S64.h **** //* \brief Configure PIO in open drain
 528:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 529:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgOpendrain(
 530:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 531:lib_AT91SAM7S64.h **** 	unsigned int multiDrvEnable) // \arg pio to be configured in open drain
 532:lib_AT91SAM7S64.h **** {
 533:lib_AT91SAM7S64.h **** 	// Configure the multi-drive option
 534:lib_AT91SAM7S64.h **** 	pPio->PIO_MDDR = ~multiDrvEnable;
 535:lib_AT91SAM7S64.h **** 	pPio->PIO_MDER = multiDrvEnable;
 536:lib_AT91SAM7S64.h **** }
 537:lib_AT91SAM7S64.h **** 
 538:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 539:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgPullup
 540:lib_AT91SAM7S64.h **** //* \brief Enable pullup on PIO
 541:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 542:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgPullup(
 543:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 544:lib_AT91SAM7S64.h **** 	unsigned int pullupEnable)   // \arg enable pullup on PIO
 545:lib_AT91SAM7S64.h **** {
 546:lib_AT91SAM7S64.h **** 		// Connect or not Pullup
 547:lib_AT91SAM7S64.h **** 	pPio->PIO_PPUDR = ~pullupEnable;
 548:lib_AT91SAM7S64.h **** 	pPio->PIO_PPUER = pullupEnable;
 549:lib_AT91SAM7S64.h **** }
 550:lib_AT91SAM7S64.h **** 
 551:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 552:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgDirectDrive
 553:lib_AT91SAM7S64.h **** //* \brief Enable direct drive on PIO
 554:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 555:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgDirectDrive(
 556:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 557:lib_AT91SAM7S64.h **** 	unsigned int directDrive)    // \arg PIO to be configured with direct drive
 558:lib_AT91SAM7S64.h **** 
 559:lib_AT91SAM7S64.h **** {
 560:lib_AT91SAM7S64.h **** 	// Configure the Direct Drive
 561:lib_AT91SAM7S64.h **** 	pPio->PIO_OWDR  = ~directDrive;
 562:lib_AT91SAM7S64.h **** 	pPio->PIO_OWER  = directDrive;
 563:lib_AT91SAM7S64.h **** }
 564:lib_AT91SAM7S64.h **** 
 565:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 566:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_CfgInputFilter
 567:lib_AT91SAM7S64.h **** //* \brief Enable input filter on input PIO
 568:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 569:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_CfgInputFilter(
 570:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
 571:lib_AT91SAM7S64.h **** 	unsigned int inputFilter)    // \arg PIO to be configured with input filter
 572:lib_AT91SAM7S64.h **** 
 573:lib_AT91SAM7S64.h **** {
 574:lib_AT91SAM7S64.h **** 	// Configure the Direct Drive
 575:lib_AT91SAM7S64.h **** 	pPio->PIO_IFDR  = ~inputFilter;
 576:lib_AT91SAM7S64.h **** 	pPio->PIO_IFER  = inputFilter;
 577:lib_AT91SAM7S64.h **** }
 578:lib_AT91SAM7S64.h **** 
 579:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 580:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetInput
 581:lib_AT91SAM7S64.h **** //* \brief Return PIO input value
 582:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 583:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetInput( // \return PIO input
 584:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 585:lib_AT91SAM7S64.h **** {
 586:lib_AT91SAM7S64.h **** 	return pPio->PIO_PDSR;
 587:lib_AT91SAM7S64.h **** }
 588:lib_AT91SAM7S64.h **** 
 589:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 590:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsInputSet
 591:lib_AT91SAM7S64.h **** //* \brief Test if PIO is input flag is active
 592:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 593:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsInputSet(
 594:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 595:lib_AT91SAM7S64.h **** 	unsigned int flag) // \arg  flag to be tested
 596:lib_AT91SAM7S64.h **** {
 597:lib_AT91SAM7S64.h **** 	return (AT91F_PIO_GetInput(pPio) & flag);
 598:lib_AT91SAM7S64.h **** }
 599:lib_AT91SAM7S64.h **** 
 600:lib_AT91SAM7S64.h **** 
 601:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 602:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_SetOutput
 603:lib_AT91SAM7S64.h **** //* \brief Set to 1 output PIO
 604:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 605:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_SetOutput(
 606:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 607:lib_AT91SAM7S64.h **** 	unsigned int flag) // \arg  output to be set
 608:lib_AT91SAM7S64.h **** {
 609:lib_AT91SAM7S64.h **** 	pPio->PIO_SODR = flag;
 610:lib_AT91SAM7S64.h **** }
 611:lib_AT91SAM7S64.h **** 
 612:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 613:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_ClearOutput
 614:lib_AT91SAM7S64.h **** //* \brief Set to 0 output PIO
 615:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 616:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_ClearOutput(
 617:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 618:lib_AT91SAM7S64.h **** 	unsigned int flag) // \arg  output to be cleared
 619:lib_AT91SAM7S64.h **** {
 620:lib_AT91SAM7S64.h **** 	pPio->PIO_CODR = flag;
 280              		.loc 2 620 0
 281 01bc CBC00EE5 		str	ip, [lr, #-203]
 282              	.LBE12:
 283              	.LBE11:
 284              		.loc 1 139 0
 285 01c0 04E09DE4 		ldr	lr, [sp], #4
 286              		.loc 1 138 0
 287 01c4 FEFFFFEA 		b	AT91F_CDC_Open
 288              	.L36:
 289              		.align	2
 290              	.L35:
 291 01c8 00000000 		.word	pCDC
 292 01cc 0000FBFF 		.word	-327680
 293              	.LFE287:
 295              		.align	2
 296              		.global	blinkingGreen
 298              	blinkingGreen:
 299              	.LFB290:
 300              		.loc 1 167 0
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              	.LVL7:
 304 01d0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 305              	.LCFI6:
 306              	.LBB17:
 307              	.LBB18:
 308              		.loc 2 609 0
 309 01d4 0B5CE0E3 		mvn	r5, #2816
 310 01d8 2040A0E3 		mov	r4, #32
 311 01dc CF4005E5 		str	r4, [r5, #-207]
 312              	.LBE18:
 313              	.LBE17:
 314              		.loc 1 167 0
 315 01e0 0060A0E1 		mov	r6, r0
 316              		.loc 1 170 0
 317 01e4 FEFFFFEB 		bl	Delay
 318              	.LVL8:
 319              		.loc 1 172 0
 320 01e8 0600A0E1 		mov	r0, r6
 321              	.LBB19:
 322              	.LBB20:
 323              		.loc 2 620 0
 324 01ec CB4005E5 		str	r4, [r5, #-203]
 325              	.LBE20:
 326              	.LBE19:
 327              		.loc 1 173 0
 328 01f0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 329              		.loc 1 172 0
 330 01f4 FEFFFFEA 		b	Delay
 331              	.LFE290:
 333              		.align	2
 334              		.global	clearLEDs
 336              	clearLEDs:
 337              	.LFB289:
 338              		.loc 1 160 0
 339              		@ args = 0, pretend = 0, frame = 0
 340              		@ frame_needed = 0, uses_anonymous_args = 0
 341              		@ link register save eliminated.
 342              	.LBB27:
 343              	.LBB28:
 344              		.loc 2 620 0
 345 01f8 0B2CE0E3 		mvn	r2, #2816
 346 01fc 0830A0E3 		mov	r3, #8
 347 0200 CB3002E5 		str	r3, [r2, #-203]
 348              	.LBE28:
 349              	.LBE27:
 350              	.LBB29:
 351              	.LBB30:
 352 0204 033083E0 		add	r3, r3, r3
 353 0208 CB3002E5 		str	r3, [r2, #-203]
 354              	.LBE30:
 355              	.LBE29:
 356              	.LBB31:
 357              	.LBB32:
 358 020c 103083E2 		add	r3, r3, #16
 359              	.LBE32:
 360              	.LBE31:
 361              		.loc 1 160 0
 362              		@ lr needed for prologue
 363              	.LBB33:
 364              	.LBB34:
 365              		.loc 2 620 0
 366 0210 CB3002E5 		str	r3, [r2, #-203]
 367              	.LBE34:
 368              	.LBE33:
 369              		.loc 1 164 0
 370 0214 1EFF2FE1 		bx	lr
 371              	.LFE289:
 373              		.align	2
 374              		.global	releasePosition
 376              	releasePosition:
 377              	.LFB296:
 378              		.loc 1 226 0
 379              		@ args = 0, pretend = 0, frame = 0
 380              		@ frame_needed = 0, uses_anonymous_args = 0
 381              		@ link register save eliminated.
 382              	.LBB39:
 383              	.LBB40:
 384              		.loc 2 620 0
 385 0218 0B3CE0E3 		mvn	r3, #2816
 386 021c 8020A0E3 		mov	r2, #128
 387 0220 CB2003E5 		str	r2, [r3, #-203]
 388              	.LBE40:
 389              	.LBE39:
 390              	.LBB41:
 391              	.LBB42:
 392 0224 4020A0E3 		mov	r2, #64
 393              	.LBE42:
 394              	.LBE41:
 395              		.loc 1 226 0
 396              		@ lr needed for prologue
 397              	.LBB43:
 398              	.LBB44:
 399              		.loc 2 620 0
 400 0228 CB2003E5 		str	r2, [r3, #-203]
 401              	.LBE44:
 402              	.LBE43:
 403              		.loc 1 229 0
 404 022c 1EFF2FE1 		bx	lr
 405              	.LFE296:
 407              		.align	2
 408              		.global	startBlinking
 410              	startBlinking:
 411              	.LFB291:
 412              		.loc 1 176 0
 413              		@ args = 0, pretend = 0, frame = 0
 414              		@ frame_needed = 0, uses_anonymous_args = 0
 415              	.LVL9:
 416 0230 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 417              	.LCFI7:
 418              	.LBB57:
 419              	.LBB58:
 420              		.loc 2 609 0
 421 0234 0B5CE0E3 		mvn	r5, #2816
 422 0238 0840A0E3 		mov	r4, #8
 423              	.LBE58:
 424              	.LBE57:
 425              		.loc 1 176 0
 426 023c 0060A0E1 		mov	r6, r0
 427              	.LBB59:
 428              	.LBB60:
 429              		.loc 2 609 0
 430 0240 CF4005E5 		str	r4, [r5, #-207]
 431              	.LBE60:
 432              	.LBE59:
 433              		.loc 1 180 0
 434 0244 FEFFFFEB 		bl	Delay
 435              	.LVL10:
 436              	.LBB61:
 437              	.LBB62:
 438              		.loc 2 620 0
 439 0248 CB4005E5 		str	r4, [r5, #-203]
 440              	.LBE62:
 441              	.LBE61:
 442              		.loc 1 182 0
 443 024c 0600A0E1 		mov	r0, r6
 444              	.LBB63:
 445              	.LBB64:
 446              		.loc 2 609 0
 447 0250 044084E0 		add	r4, r4, r4
 448              	.LBE64:
 449              	.LBE63:
 450              		.loc 1 182 0
 451 0254 FEFFFFEB 		bl	Delay
 452              	.LBB65:
 453              	.LBB66:
 454              		.loc 2 609 0
 455 0258 CF4005E5 		str	r4, [r5, #-207]
 456              	.LBE66:
 457              	.LBE65:
 458              		.loc 1 185 0
 459 025c 0600A0E1 		mov	r0, r6
 460 0260 FEFFFFEB 		bl	Delay
 461              	.LBB67:
 462              	.LBB68:
 463              		.loc 2 620 0
 464 0264 CB4005E5 		str	r4, [r5, #-203]
 465              	.LBE68:
 466              	.LBE67:
 467              		.loc 1 187 0
 468 0268 0600A0E1 		mov	r0, r6
 469              	.LBB69:
 470              	.LBB70:
 471              		.loc 2 609 0
 472 026c 104084E2 		add	r4, r4, #16
 473              	.LBE70:
 474              	.LBE69:
 475              		.loc 1 187 0
 476 0270 FEFFFFEB 		bl	Delay
 477              		.loc 1 190 0
 478 0274 0600A0E1 		mov	r0, r6
 479              	.LBB71:
 480              	.LBB72:
 481              		.loc 2 609 0
 482 0278 CF4005E5 		str	r4, [r5, #-207]
 483              	.LBE72:
 484              	.LBE71:
 485              		.loc 1 190 0
 486 027c FEFFFFEB 		bl	Delay
 487              		.loc 1 192 0
 488 0280 0600A0E1 		mov	r0, r6
 489              	.LBB73:
 490              	.LBB74:
 491              		.loc 2 620 0
 492 0284 CB4005E5 		str	r4, [r5, #-203]
 493              	.LBE74:
 494              	.LBE73:
 495              		.loc 1 193 0
 496 0288 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 497              		.loc 1 192 0
 498 028c FEFFFFEA 		b	Delay
 499              	.LFE291:
 501              		.section	.rodata.str1.4,"aMS",%progbits,1
 502              		.align	2
 503              	.LC1:
 504 0000 54455354 		.ascii	"TEST\000"
 504      00
 505 0005 000000   		.align	2
 506              	.LC2:
 507 0008 494E4954 		.ascii	"INITIAL TEST\015\012\000"
 507      49414C20 
 507      54455354 
 507      0D0A00
 508 0017 00       		.align	2
 509              	.LC3:
 510 0018 53544152 		.ascii	"START\000"
 510      5400
 511 001e 0000     		.align	2
 512              	.LC4:
 513 0020 54455354 		.ascii	"TEST READING ACTIVATED\015\012\000"
 513      20524541 
 513      44494E47 
 513      20414354 
 513      49564154 
 514 0039 000000   		.align	2
 515              	.LC5:
 516 003c 53544F50 		.ascii	"STOP\000"
 516      00
 517 0041 000000   		.align	2
 518              	.LC6:
 519 0044 54455354 		.ascii	"TEST READING STOPPED\015\012\000"
 519      20524541 
 519      44494E47 
 519      2053544F 
 519      50504544 
 520 005b 00       		.align	2
 521              	.LC7:
 522 005c 5A45524F 		.ascii	"ZERO\000"
 522      00
 523 0061 000000   		.align	2
 524              	.LC8:
 525 0064 53455400 		.ascii	"SET\000"
 526              		.align	2
 527              	.LC9:
 528 0068 554E5345 		.ascii	"UNSET\000"
 528      5400
 529 006e 0000     		.align	2
 530              	.LC10:
 531 0070 4D4D4300 		.ascii	"MMC\000"
 532              		.align	2
 533              	.LC11:
 534 0074 52454144 		.ascii	"READ\000"
 534      00
 535 0079 000000   		.align	2
 536              	.LC12:
 537 007c 53544F52 		.ascii	"STORED MMC VALUES:\015\012\000"
 537      4544204D 
 537      4D432056 
 537      414C5545 
 537      533A0D0A 
 538 0091 000000   		.align	2
 539              	.LC13:
 540 0094 0D0A00   		.ascii	"\015\012\000"
 541 0097 00       		.align	2
 542              	.LC14:
 543 0098 434C4541 		.ascii	"CLEAR\000"
 543      5200
 544 009e 0000     		.align	2
 545              	.LC15:
 546 00a0 434C4541 		.ascii	"CLEARING SD CARD...\015\012\000"
 546      52494E47 
 546      20534420 
 546      43415244 
 546      2E2E2E0D 
 547 00b6 0000     		.align	2
 548              	.LC16:
 549 00b8 434C4541 		.ascii	"CLEARING DONE\015\012\000"
 549      52494E47 
 549      20444F4E 
 549      450D0A00 
 550              		.align	2
 551              	.LC0:
 552 00c8 2300     		.ascii	"#\000"
 553              		.text
 554              		.align	2
 555              		.global	parseSettings
 557              	parseSettings:
 558              	.LFB300:
 559              		.loc 1 299 0
 560              		@ args = 0, pretend = 0, frame = 4
 561              		@ frame_needed = 0, uses_anonymous_args = 0
 562              	.LVL11:
 563 0290 30402DE9 		stmfd	sp!, {r4, r5, lr}
 564              	.LCFI8:
 565              		.loc 1 303 0
 566 0294 EC319FE5 		ldr	r3, .L74
 567              		.loc 1 299 0
 568 0298 04D04DE2 		sub	sp, sp, #4
 569              	.LCFI9:
 570              		.loc 1 303 0
 571 029c B030D3E1 		ldrh	r3, [r3, #0]
 572 02a0 04408DE2 		add	r4, sp, #4
 573 02a4 B23064E1 		strh	r3, [r4, #-2]!	@ movhi
 574              		.loc 1 306 0
 575 02a8 0410A0E1 		mov	r1, r4
 576 02ac FEFFFFEB 		bl	strtok
 577              	.LVL12:
 578              		.loc 1 308 0
 579 02b0 D4119FE5 		ldr	r1, .L74+4
 580              		.loc 1 306 0
 581 02b4 0050A0E1 		mov	r5, r0
 582              	.LVL13:
 583              		.loc 1 308 0
 584 02b8 FEFFFFEB 		bl	strcmp
 585 02bc 000050E3 		cmp	r0, #0
 586 02c0 D000001A 		bne	.L46
 587              		.loc 1 310 0
 588 02c4 0410A0E1 		mov	r1, r4
 589 02c8 FEFFFFEB 		bl	strtok
 590              		.loc 1 311 0
 591 02cc B8119FE5 		ldr	r1, .L74+4
 592              		.loc 1 310 0
 593 02d0 0050A0E1 		mov	r5, r0
 594              		.loc 1 311 0
 595 02d4 FEFFFFEB 		bl	strcmp
 596 02d8 004050E2 		subs	r4, r0, #0
 597 02dc BD00001A 		bne	.L48
 598              		.loc 1 314 0
 599 02e0 A8019FE5 		ldr	r0, .L74+8
 600 02e4 FEFFFFEB 		bl	printTrace
 601              	.L50:
 602              	.LVL14:
 603              		.loc 1 315 0
 604 02e8 014084E2 		add	r4, r4, #1
 605              		.loc 1 317 0
 606 02ec A0019FE5 		ldr	r0, .L74+12
 607 02f0 FEFFFFEB 		bl	startBlinking
 608              		.loc 1 315 0
 609 02f4 0F0054E3 		cmp	r4, #15
 610 02f8 B800001A 		bne	.L50
 611              	.L48:
 612              		.loc 1 320 0
 613 02fc 0500A0E1 		mov	r0, r5
 614 0300 90119FE5 		ldr	r1, .L74+16
 615 0304 FEFFFFEB 		bl	strcmp
 616 0308 000050E3 		cmp	r0, #0
 617 030c C700001A 		bne	.L51
 618              		.loc 1 322 0
 619 0310 84019FE5 		ldr	r0, .L74+20
 620 0314 FEFFFFEB 		bl	printTrace
 621              		.loc 1 323 0
 622 0318 80319FE5 		ldr	r3, .L74+24
 623 031c 0120A0E3 		mov	r2, #1
 624 0320 002083E5 		str	r2, [r3, #0]
 625              	.L51:
 626              		.loc 1 325 0
 627 0324 0500A0E1 		mov	r0, r5
 628 0328 74119FE5 		ldr	r1, .L74+28
 629 032c FEFFFFEB 		bl	strcmp
 630 0330 004050E2 		subs	r4, r0, #0
 631              	.LVL15:
 632 0334 D000001A 		bne	.L46
 633              		.loc 1 327 0
 634 0338 68019FE5 		ldr	r0, .L74+32
 635 033c FEFFFFEB 		bl	printTrace
 636              		.loc 1 328 0
 637 0340 58319FE5 		ldr	r3, .L74+24
 638 0344 004083E5 		str	r4, [r3, #0]
 639              	.L46:
 640              		.loc 1 332 0
 641 0348 0500A0E1 		mov	r0, r5
 642 034c 58119FE5 		ldr	r1, .L74+36
 643 0350 FEFFFFEB 		bl	strcmp
 644 0354 000050E3 		cmp	r0, #0
 645 0358 E500001A 		bne	.L54
 646              		.loc 1 334 0
 647 035c 02108DE2 		add	r1, sp, #2
 648 0360 FEFFFFEB 		bl	strtok
 649              		.loc 1 335 0
 650 0364 44119FE5 		ldr	r1, .L74+40
 651              		.loc 1 334 0
 652 0368 0050A0E1 		mov	r5, r0
 653              		.loc 1 335 0
 654 036c FEFFFFEB 		bl	strcmp
 655 0370 000050E3 		cmp	r0, #0
 656              		.loc 1 337 0
 657 0374 38319F05 		ldreq	r3, .L74+44
 658 0378 00209305 		ldreq	r2, [r3, #0]
 659 037c 34319F05 		ldreq	r3, .L74+48
 660              		.loc 1 339 0
 661 0380 0500A0E1 		mov	r0, r5
 662              		.loc 1 337 0
 663 0384 00208305 		streq	r2, [r3, #0]
 664              		.loc 1 339 0
 665 0388 2C119FE5 		ldr	r1, .L74+52
 666 038c FEFFFFEB 		bl	strcmp
 667 0390 000050E3 		cmp	r0, #0
 668              		.loc 1 341 0
 669 0394 1C319F05 		ldreq	r3, .L74+48
 670 0398 00008305 		streq	r0, [r3, #0]
 671              	.L54:
 672              		.loc 1 575 0
 673 039c 0500A0E1 		mov	r0, r5
 674 03a0 18119FE5 		ldr	r1, .L74+56
 675 03a4 FEFFFFEB 		bl	strcmp
 676 03a8 000050E3 		cmp	r0, #0
 677 03ac 1E01001A 		bne	.L70
 678              		.loc 1 577 0
 679 03b0 02108DE2 		add	r1, sp, #2
 680 03b4 FEFFFFEB 		bl	strtok
 681              		.loc 1 578 0
 682 03b8 04119FE5 		ldr	r1, .L74+60
 683              		.loc 1 577 0
 684 03bc 0050A0E1 		mov	r5, r0
 685              	.LVL16:
 686              		.loc 1 578 0
 687 03c0 FEFFFFEB 		bl	strcmp
 688 03c4 004050E2 		subs	r4, r0, #0
 689 03c8 0701001A 		bne	.L61
 690              	.LBB75:
 691              		.loc 1 581 0
 692 03cc F4009FE5 		ldr	r0, .L74+64
 693 03d0 FEFFFFEB 		bl	printTrace
 694              	.L63:
 695              		.loc 1 585 0
 696 03d4 022CA0E3 		mov	r2, #512
 697 03d8 0010A0E3 		mov	r1, #0
 698 03dc E8009FE5 		ldr	r0, .L74+68
 699 03e0 FEFFFFEB 		bl	memset
 700              		.loc 1 586 0
 701 03e4 0400A0E1 		mov	r0, r4
 702 03e8 021CA0E3 		mov	r1, #512
 703 03ec FEFFFFEB 		bl	mmcReadBlock
 704              		.loc 1 587 0
 705 03f0 D8309FE5 		ldr	r3, .L74+72
 706 03f4 024C84E2 		add	r4, r4, #512
 707 03f8 0300A0E1 		mov	r0, r3
 708 03fc C8109FE5 		ldr	r1, .L74+68
 709 0400 022CA0E3 		mov	r2, #512
 710 0404 0FE0A0E1 		mov	lr, pc
 711 0408 10F093E5 		ldr	pc, [r3, #16]
 712              		.loc 1 583 0
 713 040c 010654E3 		cmp	r4, #1048576
 714 0410 F300001A 		bne	.L63
 715              		.loc 1 589 0
 716 0414 B8009FE5 		ldr	r0, .L74+76
 717 0418 FEFFFFEB 		bl	printTrace
 718              		.loc 1 590 0
 719 041c B4009FE5 		ldr	r0, .L74+80
 720 0420 FEFFFFEB 		bl	Delay
 721              	.L61:
 722              	.LBE75:
 723              		.loc 1 592 0
 724 0424 0500A0E1 		mov	r0, r5
 725 0428 AC109FE5 		ldr	r1, .L74+84
 726 042c FEFFFFEB 		bl	strcmp
 727 0430 000050E3 		cmp	r0, #0
 728 0434 1101001A 		bne	.L65
 729              		.loc 1 594 0
 730 0438 A0009FE5 		ldr	r0, .L74+88
 731 043c FEFFFFEB 		bl	printTrace
 732              		.loc 1 595 0
 733 0440 FEFFFFEB 		bl	clearMMCCard
 734              		.loc 1 596 0
 735 0444 98009FE5 		ldr	r0, .L74+92
 736 0448 FEFFFFEB 		bl	printTrace
 737              	.L65:
 738              		.loc 1 598 0
 739 044c 44109FE5 		ldr	r1, .L74+16
 740 0450 0500A0E1 		mov	r0, r5
 741 0454 FEFFFFEB 		bl	strcmp
 742 0458 000050E3 		cmp	r0, #0
 743              		.loc 1 600 0
 744 045c 84309F05 		ldreq	r3, .L74+96
 745 0460 0120A003 		moveq	r2, #1
 746 0464 0020C305 		streqb	r2, [r3, #0]
 747              		.loc 1 602 0
 748 0468 0500A0E1 		mov	r0, r5
 749 046c 30109FE5 		ldr	r1, .L74+28
 750 0470 FEFFFFEB 		bl	strcmp
 751 0474 000050E3 		cmp	r0, #0
 752              		.loc 1 604 0
 753 0478 68309F05 		ldreq	r3, .L74+96
 754 047c 0000C305 		streqb	r0, [r3, #0]
 755              	.LVL17:
 756              	.L70:
 757              		.loc 1 607 0
 758 0480 04D08DE2 		add	sp, sp, #4
 759 0484 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 760              	.L75:
 761              		.align	2
 762              	.L74:
 763 0488 C8000000 		.word	.LC0
 764 048c 00000000 		.word	.LC1
 765 0490 08000000 		.word	.LC2
 766 0494 50C30000 		.word	50000
 767 0498 18000000 		.word	.LC3
 768 049c 20000000 		.word	.LC4
 769 04a0 00000000 		.word	test_read
 770 04a4 3C000000 		.word	.LC5
 771 04a8 44000000 		.word	.LC6
 772 04ac 5C000000 		.word	.LC7
 773 04b0 64000000 		.word	.LC8
 774 04b4 00000000 		.word	pressure
 775 04b8 00000000 		.word	set_zero
 776 04bc 68000000 		.word	.LC9
 777 04c0 70000000 		.word	.LC10
 778 04c4 74000000 		.word	.LC11
 779 04c8 7C000000 		.word	.LC12
 780 04cc 00000000 		.word	mmc_buffer
 781 04d0 00000000 		.word	pCDC
 782 04d4 94000000 		.word	.LC13
 783 04d8 A0252600 		.word	2500000
 784 04dc 98000000 		.word	.LC14
 785 04e0 A0000000 		.word	.LC15
 786 04e4 B8000000 		.word	.LC16
 787 04e8 00000000 		.word	storingOnMMC
 788              	.LFE300:
 790              		.align	2
 791              		.global	setForce
 793              	setForce:
 794              	.LFB293:
 795              		.loc 1 202 0
 796              		@ args = 0, pretend = 0, frame = 0
 797              		@ frame_needed = 0, uses_anonymous_args = 0
 798              		@ link register save eliminated.
 799              	.LVL18:
 800              	.LBB84:
 801              	.LBB85:
 621:lib_AT91SAM7S64.h **** }
 622:lib_AT91SAM7S64.h **** 
 623:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 624:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_ForceOutput
 625:lib_AT91SAM7S64.h **** //* \brief Force output when Direct drive option is enabled
 626:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 627:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_ForceOutput(
 628:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 629:lib_AT91SAM7S64.h **** 	unsigned int flag) // \arg  output to be forced
 630:lib_AT91SAM7S64.h **** {
 631:lib_AT91SAM7S64.h **** 	pPio->PIO_ODSR = flag;
 632:lib_AT91SAM7S64.h **** }
 633:lib_AT91SAM7S64.h **** 
 634:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 635:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_Enable
 636:lib_AT91SAM7S64.h **** //* \brief Enable PIO
 637:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 638:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_Enable(
 639:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 640:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio to be enabled 
 641:lib_AT91SAM7S64.h **** {
 642:lib_AT91SAM7S64.h ****         pPio->PIO_PER = flag;
 643:lib_AT91SAM7S64.h **** }
 644:lib_AT91SAM7S64.h **** 
 645:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 646:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_Disable
 647:lib_AT91SAM7S64.h **** //* \brief Disable PIO
 648:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 649:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_Disable(
 650:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 651:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio to be disabled 
 652:lib_AT91SAM7S64.h **** {
 653:lib_AT91SAM7S64.h ****         pPio->PIO_PDR = flag;
 654:lib_AT91SAM7S64.h **** }
 655:lib_AT91SAM7S64.h **** 
 656:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 657:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetStatus
 658:lib_AT91SAM7S64.h **** //* \brief Return PIO Status
 659:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 660:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetStatus( // \return PIO Status
 661:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 662:lib_AT91SAM7S64.h **** {
 663:lib_AT91SAM7S64.h ****         return pPio->PIO_PSR;
 664:lib_AT91SAM7S64.h **** }
 665:lib_AT91SAM7S64.h **** 
 666:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 667:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsSet
 668:lib_AT91SAM7S64.h **** //* \brief Test if PIO is Set
 669:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 670:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsSet(
 671:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 672:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 673:lib_AT91SAM7S64.h **** {
 674:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetStatus(pPio) & flag);
 675:lib_AT91SAM7S64.h **** }
 676:lib_AT91SAM7S64.h **** 
 677:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 678:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_OutputEnable
 679:lib_AT91SAM7S64.h **** //* \brief Output Enable PIO
 680:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 681:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_OutputEnable(
 682:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 683:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio output to be enabled
 684:lib_AT91SAM7S64.h **** {
 685:lib_AT91SAM7S64.h ****         pPio->PIO_OER = flag;
 686:lib_AT91SAM7S64.h **** }
 687:lib_AT91SAM7S64.h **** 
 688:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 689:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_OutputDisable
 690:lib_AT91SAM7S64.h **** //* \brief Output Enable PIO
 691:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 692:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_OutputDisable(
 693:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 694:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio output to be disabled
 695:lib_AT91SAM7S64.h **** {
 696:lib_AT91SAM7S64.h ****         pPio->PIO_ODR = flag;
 697:lib_AT91SAM7S64.h **** }
 698:lib_AT91SAM7S64.h **** 
 699:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 700:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetOutputStatus
 701:lib_AT91SAM7S64.h **** //* \brief Return PIO Output Status
 702:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 703:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetOutputStatus( // \return PIO Output Status
 704:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 705:lib_AT91SAM7S64.h **** {
 706:lib_AT91SAM7S64.h ****         return pPio->PIO_OSR;
 707:lib_AT91SAM7S64.h **** }
 708:lib_AT91SAM7S64.h **** 
 709:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 710:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsOuputSet
 711:lib_AT91SAM7S64.h **** //* \brief Test if PIO Output is Set
 712:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 713:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsOutputSet(
 714:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 715:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 716:lib_AT91SAM7S64.h **** {
 717:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetOutputStatus(pPio) & flag);
 718:lib_AT91SAM7S64.h **** }
 719:lib_AT91SAM7S64.h **** 
 720:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 721:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_InputFilterEnable
 722:lib_AT91SAM7S64.h **** //* \brief Input Filter Enable PIO
 723:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 724:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_InputFilterEnable(
 725:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 726:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio input filter to be enabled
 727:lib_AT91SAM7S64.h **** {
 728:lib_AT91SAM7S64.h ****         pPio->PIO_IFER = flag;
 729:lib_AT91SAM7S64.h **** }
 730:lib_AT91SAM7S64.h **** 
 731:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 732:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_InputFilterDisable
 733:lib_AT91SAM7S64.h **** //* \brief Input Filter Disable PIO
 734:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 735:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_InputFilterDisable(
 736:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 737:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio input filter to be disabled
 738:lib_AT91SAM7S64.h **** {
 739:lib_AT91SAM7S64.h ****         pPio->PIO_IFDR = flag;
 740:lib_AT91SAM7S64.h **** }
 741:lib_AT91SAM7S64.h **** 
 742:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 743:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetInputFilterStatus
 744:lib_AT91SAM7S64.h **** //* \brief Return PIO Input Filter Status
 745:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 746:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetInputFilterStatus( // \return PIO Input Filter Status
 747:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 748:lib_AT91SAM7S64.h **** {
 749:lib_AT91SAM7S64.h ****         return pPio->PIO_IFSR;
 750:lib_AT91SAM7S64.h **** }
 751:lib_AT91SAM7S64.h **** 
 752:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 753:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsInputFilterSet
 754:lib_AT91SAM7S64.h **** //* \brief Test if PIO Input filter is Set
 755:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 756:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsInputFilterSet(
 757:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 758:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 759:lib_AT91SAM7S64.h **** {
 760:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetInputFilterStatus(pPio) & flag);
 761:lib_AT91SAM7S64.h **** }
 762:lib_AT91SAM7S64.h **** 
 763:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 764:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetOutputDataStatus
 765:lib_AT91SAM7S64.h **** //* \brief Return PIO Output Data Status 
 766:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 767:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetOutputDataStatus( // \return PIO Output Data Status 
 768:lib_AT91SAM7S64.h **** 	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 769:lib_AT91SAM7S64.h **** {
 770:lib_AT91SAM7S64.h ****         return pPio->PIO_ODSR;
 771:lib_AT91SAM7S64.h **** }
 772:lib_AT91SAM7S64.h **** 
 773:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 774:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_InterruptEnable
 775:lib_AT91SAM7S64.h **** //* \brief Enable PIO Interrupt
 776:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 777:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_InterruptEnable(
 778:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 779:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio interrupt to be enabled
 780:lib_AT91SAM7S64.h **** {
 781:lib_AT91SAM7S64.h ****         pPio->PIO_IER = flag;
 782:lib_AT91SAM7S64.h **** }
 783:lib_AT91SAM7S64.h **** 
 784:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 785:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_InterruptDisable
 786:lib_AT91SAM7S64.h **** //* \brief Disable PIO Interrupt
 787:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 788:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_InterruptDisable(
 789:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 790:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio interrupt to be disabled
 791:lib_AT91SAM7S64.h **** {
 792:lib_AT91SAM7S64.h ****         pPio->PIO_IDR = flag;
 793:lib_AT91SAM7S64.h **** }
 794:lib_AT91SAM7S64.h **** 
 795:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 796:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetInterruptMaskStatus
 797:lib_AT91SAM7S64.h **** //* \brief Return PIO Interrupt Mask Status
 798:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 799:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetInterruptMaskStatus( // \return PIO Interrupt Mask Status
 800:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 801:lib_AT91SAM7S64.h **** {
 802:lib_AT91SAM7S64.h ****         return pPio->PIO_IMR;
 803:lib_AT91SAM7S64.h **** }
 804:lib_AT91SAM7S64.h **** 
 805:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 806:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetInterruptStatus
 807:lib_AT91SAM7S64.h **** //* \brief Return PIO Interrupt Status
 808:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 809:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetInterruptStatus( // \return PIO Interrupt Status
 810:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 811:lib_AT91SAM7S64.h **** {
 812:lib_AT91SAM7S64.h ****         return pPio->PIO_ISR;
 813:lib_AT91SAM7S64.h **** }
 814:lib_AT91SAM7S64.h **** 
 815:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 816:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsInterruptMasked
 817:lib_AT91SAM7S64.h **** //* \brief Test if PIO Interrupt is Masked 
 818:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 819:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsInterruptMasked(
 820:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 821:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 822:lib_AT91SAM7S64.h **** {
 823:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetInterruptMaskStatus(pPio) & flag);
 824:lib_AT91SAM7S64.h **** }
 825:lib_AT91SAM7S64.h **** 
 826:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 827:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsInterruptSet
 828:lib_AT91SAM7S64.h **** //* \brief Test if PIO Interrupt is Set
 829:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 830:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsInterruptSet(
 831:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 832:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 833:lib_AT91SAM7S64.h **** {
 834:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetInterruptStatus(pPio) & flag);
 835:lib_AT91SAM7S64.h **** }
 836:lib_AT91SAM7S64.h **** 
 837:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 838:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_MultiDriverEnable
 839:lib_AT91SAM7S64.h **** //* \brief Multi Driver Enable PIO
 840:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 841:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_MultiDriverEnable(
 842:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 843:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio to be enabled
 844:lib_AT91SAM7S64.h **** {
 845:lib_AT91SAM7S64.h ****         pPio->PIO_MDER = flag;
 846:lib_AT91SAM7S64.h **** }
 847:lib_AT91SAM7S64.h **** 
 848:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 849:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_MultiDriverDisable
 850:lib_AT91SAM7S64.h **** //* \brief Multi Driver Disable PIO
 851:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 852:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_MultiDriverDisable(
 853:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 854:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio to be disabled
 855:lib_AT91SAM7S64.h **** {
 856:lib_AT91SAM7S64.h ****         pPio->PIO_MDDR = flag;
 857:lib_AT91SAM7S64.h **** }
 858:lib_AT91SAM7S64.h **** 
 859:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 860:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetMultiDriverStatus
 861:lib_AT91SAM7S64.h **** //* \brief Return PIO Multi Driver Status
 862:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 863:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetMultiDriverStatus( // \return PIO Multi Driver Status
 864:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 865:lib_AT91SAM7S64.h **** {
 866:lib_AT91SAM7S64.h ****         return pPio->PIO_MDSR;
 867:lib_AT91SAM7S64.h **** }
 868:lib_AT91SAM7S64.h **** 
 869:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 870:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsMultiDriverSet
 871:lib_AT91SAM7S64.h **** //* \brief Test if PIO MultiDriver is Set
 872:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 873:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsMultiDriverSet(
 874:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 875:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 876:lib_AT91SAM7S64.h **** {
 877:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetMultiDriverStatus(pPio) & flag);
 878:lib_AT91SAM7S64.h **** }
 879:lib_AT91SAM7S64.h **** 
 880:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 881:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_A_RegisterSelection
 882:lib_AT91SAM7S64.h **** //* \brief PIO A Register Selection 
 883:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 884:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_A_RegisterSelection(
 885:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 886:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio A register selection
 887:lib_AT91SAM7S64.h **** {
 888:lib_AT91SAM7S64.h ****         pPio->PIO_ASR = flag;
 889:lib_AT91SAM7S64.h **** }
 890:lib_AT91SAM7S64.h **** 
 891:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 892:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_B_RegisterSelection
 893:lib_AT91SAM7S64.h **** //* \brief PIO B Register Selection 
 894:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 895:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_B_RegisterSelection(
 896:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 897:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio B register selection 
 898:lib_AT91SAM7S64.h **** {
 899:lib_AT91SAM7S64.h ****         pPio->PIO_BSR = flag;
 900:lib_AT91SAM7S64.h **** }
 901:lib_AT91SAM7S64.h **** 
 902:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 903:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_Get_AB_RegisterStatus
 904:lib_AT91SAM7S64.h **** //* \brief Return PIO Interrupt Status
 905:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 906:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_Get_AB_RegisterStatus( // \return PIO AB Register Status
 907:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 908:lib_AT91SAM7S64.h **** {
 909:lib_AT91SAM7S64.h ****         return pPio->PIO_ABSR;
 910:lib_AT91SAM7S64.h **** }
 911:lib_AT91SAM7S64.h **** 
 912:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 913:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsAB_RegisterSet
 914:lib_AT91SAM7S64.h **** //* \brief Test if PIO AB Register is Set
 915:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 916:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsAB_RegisterSet(
 917:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 918:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 919:lib_AT91SAM7S64.h **** {
 920:lib_AT91SAM7S64.h ****         return (AT91F_PIO_Get_AB_RegisterStatus(pPio) & flag);
 921:lib_AT91SAM7S64.h **** }
 922:lib_AT91SAM7S64.h **** 
 923:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 924:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_OutputWriteEnable
 925:lib_AT91SAM7S64.h **** //* \brief Output Write Enable PIO
 926:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 927:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_OutputWriteEnable(
 928:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 929:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio output write to be enabled
 930:lib_AT91SAM7S64.h **** {
 931:lib_AT91SAM7S64.h ****         pPio->PIO_OWER = flag;
 932:lib_AT91SAM7S64.h **** }
 933:lib_AT91SAM7S64.h **** 
 934:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 935:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_OutputWriteDisable
 936:lib_AT91SAM7S64.h **** //* \brief Output Write Disable PIO
 937:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 938:lib_AT91SAM7S64.h **** __inline void AT91F_PIO_OutputWriteDisable(
 939:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 940:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  pio output write to be disabled
 941:lib_AT91SAM7S64.h **** {
 942:lib_AT91SAM7S64.h ****         pPio->PIO_OWDR = flag;
 943:lib_AT91SAM7S64.h **** }
 944:lib_AT91SAM7S64.h **** 
 945:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 946:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetOutputWriteStatus
 947:lib_AT91SAM7S64.h **** //* \brief Return PIO Output Write Status
 948:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 949:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetOutputWriteStatus( // \return PIO Output Write Status
 950:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 951:lib_AT91SAM7S64.h **** {
 952:lib_AT91SAM7S64.h ****         return pPio->PIO_OWSR;
 953:lib_AT91SAM7S64.h **** }
 954:lib_AT91SAM7S64.h **** 
 955:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 956:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsOutputWriteSet
 957:lib_AT91SAM7S64.h **** //* \brief Test if PIO OutputWrite is Set
 958:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 959:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsOutputWriteSet(
 960:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 961:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 962:lib_AT91SAM7S64.h **** {
 963:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetOutputWriteStatus(pPio) & flag);
 964:lib_AT91SAM7S64.h **** }
 965:lib_AT91SAM7S64.h **** 
 966:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 967:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_GetCfgPullup
 968:lib_AT91SAM7S64.h **** //* \brief Return PIO Configuration Pullup
 969:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 970:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PIO_GetCfgPullup( // \return PIO Configuration Pullup 
 971:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio) // \arg  pointer to a PIO controller
 972:lib_AT91SAM7S64.h **** {
 973:lib_AT91SAM7S64.h ****         return pPio->PIO_PPUSR;
 974:lib_AT91SAM7S64.h **** }
 975:lib_AT91SAM7S64.h **** 
 976:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 977:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsOutputDataStatusSet
 978:lib_AT91SAM7S64.h **** //* \brief Test if PIO Output Data Status is Set 
 979:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 980:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsOutputDataStatusSet(
 981:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 982:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 983:lib_AT91SAM7S64.h **** {
 984:lib_AT91SAM7S64.h ****         return (AT91F_PIO_GetOutputDataStatus(pPio) & flag);
 985:lib_AT91SAM7S64.h **** }
 986:lib_AT91SAM7S64.h **** 
 987:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 988:lib_AT91SAM7S64.h **** //* \fn    AT91F_PIO_IsCfgPullupStatusSet
 989:lib_AT91SAM7S64.h **** //* \brief Test if PIO Configuration Pullup Status is Set
 990:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
 991:lib_AT91SAM7S64.h **** __inline int AT91F_PIO_IsCfgPullupStatusSet(
 992:lib_AT91SAM7S64.h ****         AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
 993:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
 994:lib_AT91SAM7S64.h **** {
 995:lib_AT91SAM7S64.h ****         return (~AT91F_PIO_GetCfgPullup(pPio) & flag);
 996:lib_AT91SAM7S64.h **** }
 997:lib_AT91SAM7S64.h **** 
 998:lib_AT91SAM7S64.h **** /* *****************************************************************************
 999:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR PMC
1000:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1001:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1002:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_CfgSysClkEnableReg
1003:lib_AT91SAM7S64.h **** //* \brief Configure the System Clock Enable Register of the PMC controller
1004:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1005:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_CfgSysClkEnableReg (
1006:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1007:lib_AT91SAM7S64.h **** 	unsigned int mode)
1008:lib_AT91SAM7S64.h **** {
1009:lib_AT91SAM7S64.h **** 	//* Write to the SCER register
1010:lib_AT91SAM7S64.h **** 	pPMC->PMC_SCER = mode;
1011:lib_AT91SAM7S64.h **** }
1012:lib_AT91SAM7S64.h **** 
1013:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1014:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_CfgSysClkDisableReg
1015:lib_AT91SAM7S64.h **** //* \brief Configure the System Clock Disable Register of the PMC controller
1016:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1017:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_CfgSysClkDisableReg (
1018:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1019:lib_AT91SAM7S64.h **** 	unsigned int mode)
1020:lib_AT91SAM7S64.h **** {
1021:lib_AT91SAM7S64.h **** 	//* Write to the SCDR register
1022:lib_AT91SAM7S64.h **** 	pPMC->PMC_SCDR = mode;
1023:lib_AT91SAM7S64.h **** }
1024:lib_AT91SAM7S64.h **** 
1025:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1026:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetSysClkStatusReg
1027:lib_AT91SAM7S64.h **** //* \brief Return the System Clock Status Register of the PMC controller
1028:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1029:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetSysClkStatusReg (
1030:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC // pointer to a CAN controller
1031:lib_AT91SAM7S64.h **** 	)
1032:lib_AT91SAM7S64.h **** {
1033:lib_AT91SAM7S64.h **** 	return pPMC->PMC_SCSR;
1034:lib_AT91SAM7S64.h **** }
1035:lib_AT91SAM7S64.h **** 
1036:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1037:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_EnablePeriphClock
1038:lib_AT91SAM7S64.h **** //* \brief Enable peripheral clock
1039:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1040:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_EnablePeriphClock (
1041:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1042:lib_AT91SAM7S64.h **** 	unsigned int periphIds)  // \arg IDs of peripherals to enable
1043:lib_AT91SAM7S64.h **** {
1044:lib_AT91SAM7S64.h **** 	pPMC->PMC_PCER = periphIds;
1045:lib_AT91SAM7S64.h **** }
1046:lib_AT91SAM7S64.h **** 
1047:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1048:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_DisablePeriphClock
1049:lib_AT91SAM7S64.h **** //* \brief Disable peripheral clock
1050:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1051:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_DisablePeriphClock (
1052:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1053:lib_AT91SAM7S64.h **** 	unsigned int periphIds)  // \arg IDs of peripherals to enable
1054:lib_AT91SAM7S64.h **** {
1055:lib_AT91SAM7S64.h **** 	pPMC->PMC_PCDR = periphIds;
1056:lib_AT91SAM7S64.h **** }
1057:lib_AT91SAM7S64.h **** 
1058:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1059:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetPeriphClock
1060:lib_AT91SAM7S64.h **** //* \brief Get peripheral clock status
1061:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1062:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetPeriphClock (
1063:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC) // \arg pointer to PMC controller
1064:lib_AT91SAM7S64.h **** {
1065:lib_AT91SAM7S64.h **** 	return pPMC->PMC_PCSR;
1066:lib_AT91SAM7S64.h **** }
1067:lib_AT91SAM7S64.h **** 
1068:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1069:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_CfgMainOscillatorReg
1070:lib_AT91SAM7S64.h **** //* \brief Cfg the main oscillator
1071:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1072:lib_AT91SAM7S64.h **** __inline void AT91F_CKGR_CfgMainOscillatorReg (
1073:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1074:lib_AT91SAM7S64.h **** 	unsigned int mode)
1075:lib_AT91SAM7S64.h **** {
1076:lib_AT91SAM7S64.h **** 	pCKGR->CKGR_MOR = mode;
1077:lib_AT91SAM7S64.h **** }
1078:lib_AT91SAM7S64.h **** 
1079:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1080:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_GetMainOscillatorReg
1081:lib_AT91SAM7S64.h **** //* \brief Cfg the main oscillator
1082:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1083:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_CKGR_GetMainOscillatorReg (
1084:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1085:lib_AT91SAM7S64.h **** {
1086:lib_AT91SAM7S64.h **** 	return pCKGR->CKGR_MOR;
1087:lib_AT91SAM7S64.h **** }
1088:lib_AT91SAM7S64.h **** 
1089:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1090:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_EnableMainOscillator
1091:lib_AT91SAM7S64.h **** //* \brief Enable the main oscillator
1092:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1093:lib_AT91SAM7S64.h **** __inline void AT91F_CKGR_EnableMainOscillator(
1094:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1095:lib_AT91SAM7S64.h **** {
1096:lib_AT91SAM7S64.h **** 	pCKGR->CKGR_MOR |= AT91C_CKGR_MOSCEN;
1097:lib_AT91SAM7S64.h **** }
1098:lib_AT91SAM7S64.h **** 
1099:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1100:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_DisableMainOscillator
1101:lib_AT91SAM7S64.h **** //* \brief Disable the main oscillator
1102:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1103:lib_AT91SAM7S64.h **** __inline void AT91F_CKGR_DisableMainOscillator (
1104:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1105:lib_AT91SAM7S64.h **** {
1106:lib_AT91SAM7S64.h **** 	pCKGR->CKGR_MOR &= ~AT91C_CKGR_MOSCEN;
1107:lib_AT91SAM7S64.h **** }
1108:lib_AT91SAM7S64.h **** 
1109:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1110:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_CfgMainOscStartUpTime
1111:lib_AT91SAM7S64.h **** //* \brief Cfg MOR Register according to the main osc startup time
1112:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1113:lib_AT91SAM7S64.h **** __inline void AT91F_CKGR_CfgMainOscStartUpTime (
1114:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1115:lib_AT91SAM7S64.h **** 	unsigned int startup_time,  // \arg main osc startup time in microsecond (us)
1116:lib_AT91SAM7S64.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1117:lib_AT91SAM7S64.h **** {
1118:lib_AT91SAM7S64.h **** 	pCKGR->CKGR_MOR &= ~AT91C_CKGR_OSCOUNT;
1119:lib_AT91SAM7S64.h **** 	pCKGR->CKGR_MOR |= ((slowClock * startup_time)/(8*1000000)) << 8;
1120:lib_AT91SAM7S64.h **** }
1121:lib_AT91SAM7S64.h **** 
1122:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1123:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_GetMainClockFreqReg
1124:lib_AT91SAM7S64.h **** //* \brief Cfg the main oscillator
1125:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1126:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_CKGR_GetMainClockFreqReg (
1127:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
1128:lib_AT91SAM7S64.h **** {
1129:lib_AT91SAM7S64.h **** 	return pCKGR->CKGR_MCFR;
1130:lib_AT91SAM7S64.h **** }
1131:lib_AT91SAM7S64.h **** 
1132:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1133:lib_AT91SAM7S64.h **** //* \fn    AT91F_CKGR_GetMainClock
1134:lib_AT91SAM7S64.h **** //* \brief Return Main clock in Hz
1135:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1136:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_CKGR_GetMainClock (
1137:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1138:lib_AT91SAM7S64.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1139:lib_AT91SAM7S64.h **** {
1140:lib_AT91SAM7S64.h **** 	return ((pCKGR->CKGR_MCFR  & AT91C_CKGR_MAINF) * slowClock) >> 4;
1141:lib_AT91SAM7S64.h **** }
1142:lib_AT91SAM7S64.h **** 
1143:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1144:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_CfgMCKReg
1145:lib_AT91SAM7S64.h **** //* \brief Cfg Master Clock Register
1146:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1147:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_CfgMCKReg (
1148:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1149:lib_AT91SAM7S64.h **** 	unsigned int mode)
1150:lib_AT91SAM7S64.h **** {
1151:lib_AT91SAM7S64.h **** 	pPMC->PMC_MCKR = mode;
1152:lib_AT91SAM7S64.h **** }
1153:lib_AT91SAM7S64.h **** 
1154:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1155:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetMCKReg
1156:lib_AT91SAM7S64.h **** //* \brief Return Master Clock Register
1157:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1158:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetMCKReg(
1159:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC) // \arg pointer to PMC controller
1160:lib_AT91SAM7S64.h **** {
1161:lib_AT91SAM7S64.h **** 	return pPMC->PMC_MCKR;
1162:lib_AT91SAM7S64.h **** }
1163:lib_AT91SAM7S64.h **** 
1164:lib_AT91SAM7S64.h **** //*------------------------------------------------------------------------------
1165:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetMasterClock
1166:lib_AT91SAM7S64.h **** //* \brief Return master clock in Hz which correponds to processor clock for ARM7
1167:lib_AT91SAM7S64.h **** //*------------------------------------------------------------------------------
1168:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetMasterClock (
1169:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1170:lib_AT91SAM7S64.h **** 	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
1171:lib_AT91SAM7S64.h **** 	unsigned int slowClock)  // \arg slowClock in Hz
1172:lib_AT91SAM7S64.h **** {
1173:lib_AT91SAM7S64.h **** 	unsigned int reg = pPMC->PMC_MCKR;
1174:lib_AT91SAM7S64.h **** 	unsigned int prescaler = (1 << ((reg & AT91C_PMC_PRES) >> 2));
1175:lib_AT91SAM7S64.h **** 	unsigned int pllDivider, pllMultiplier;
1176:lib_AT91SAM7S64.h **** 
1177:lib_AT91SAM7S64.h **** 	switch (reg & AT91C_PMC_CSS) {
1178:lib_AT91SAM7S64.h **** 		case AT91C_PMC_CSS_SLOW_CLK: // Slow clock selected
1179:lib_AT91SAM7S64.h **** 			return slowClock / prescaler;
1180:lib_AT91SAM7S64.h **** 		case AT91C_PMC_CSS_MAIN_CLK: // Main clock is selected
1181:lib_AT91SAM7S64.h **** 			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / prescaler;
1182:lib_AT91SAM7S64.h **** 		case AT91C_PMC_CSS_PLL_CLK: // PLLB clock is selected
1183:lib_AT91SAM7S64.h **** 			reg = pCKGR->CKGR_PLLR;
1184:lib_AT91SAM7S64.h **** 			pllDivider    = (reg  & AT91C_CKGR_DIV);
1185:lib_AT91SAM7S64.h **** 			pllMultiplier = ((reg  & AT91C_CKGR_MUL) >> 16) + 1;
1186:lib_AT91SAM7S64.h **** 			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / pllDivider * pllMultiplier / prescaler;
1187:lib_AT91SAM7S64.h **** 	}
1188:lib_AT91SAM7S64.h **** 	return 0;
1189:lib_AT91SAM7S64.h **** }
1190:lib_AT91SAM7S64.h **** 
1191:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1192:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_EnablePCK
1193:lib_AT91SAM7S64.h **** //* \brief Enable peripheral clock
1194:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1195:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_EnablePCK (
1196:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1197:lib_AT91SAM7S64.h **** 	unsigned int pck,  // \arg Peripheral clock identifier 0 .. 7
1198:lib_AT91SAM7S64.h **** 	unsigned int mode)
1199:lib_AT91SAM7S64.h **** {
1200:lib_AT91SAM7S64.h **** 	pPMC->PMC_PCKR[pck] = mode;
1201:lib_AT91SAM7S64.h **** 	pPMC->PMC_SCER = (1 << pck) << 8;
1202:lib_AT91SAM7S64.h **** }
1203:lib_AT91SAM7S64.h **** 
1204:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1205:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_DisablePCK
1206:lib_AT91SAM7S64.h **** //* \brief Enable peripheral clock
1207:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1208:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_DisablePCK (
1209:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // \arg pointer to PMC controller
1210:lib_AT91SAM7S64.h **** 	unsigned int pck)  // \arg Peripheral clock identifier 0 .. 7
1211:lib_AT91SAM7S64.h **** {
1212:lib_AT91SAM7S64.h **** 	pPMC->PMC_SCDR = (1 << pck) << 8;
1213:lib_AT91SAM7S64.h **** }
1214:lib_AT91SAM7S64.h **** 
1215:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1216:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_EnableIt
1217:lib_AT91SAM7S64.h **** //* \brief Enable PMC interrupt
1218:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1219:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_EnableIt (
1220:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC,     // pointer to a PMC controller
1221:lib_AT91SAM7S64.h **** 	unsigned int flag)   // IT to be enabled
1222:lib_AT91SAM7S64.h **** {
1223:lib_AT91SAM7S64.h **** 	//* Write to the IER register
1224:lib_AT91SAM7S64.h **** 	pPMC->PMC_IER = flag;
1225:lib_AT91SAM7S64.h **** }
1226:lib_AT91SAM7S64.h **** 
1227:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1228:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_DisableIt
1229:lib_AT91SAM7S64.h **** //* \brief Disable PMC interrupt
1230:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1231:lib_AT91SAM7S64.h **** __inline void AT91F_PMC_DisableIt (
1232:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC, // pointer to a PMC controller
1233:lib_AT91SAM7S64.h **** 	unsigned int flag) // IT to be disabled
1234:lib_AT91SAM7S64.h **** {
1235:lib_AT91SAM7S64.h **** 	//* Write to the IDR register
1236:lib_AT91SAM7S64.h **** 	pPMC->PMC_IDR = flag;
1237:lib_AT91SAM7S64.h **** }
1238:lib_AT91SAM7S64.h **** 
1239:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1240:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetStatus
1241:lib_AT91SAM7S64.h **** //* \brief Return PMC Interrupt Status
1242:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1243:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetStatus( // \return PMC Interrupt Status
1244:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC) // pointer to a PMC controller
1245:lib_AT91SAM7S64.h **** {
1246:lib_AT91SAM7S64.h **** 	return pPMC->PMC_SR;
1247:lib_AT91SAM7S64.h **** }
1248:lib_AT91SAM7S64.h **** 
1249:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1250:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_GetInterruptMaskStatus
1251:lib_AT91SAM7S64.h **** //* \brief Return PMC Interrupt Mask Status
1252:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1253:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_GetInterruptMaskStatus( // \return PMC Interrupt Mask Status
1254:lib_AT91SAM7S64.h **** 	AT91PS_PMC pPMC) // pointer to a PMC controller
1255:lib_AT91SAM7S64.h **** {
1256:lib_AT91SAM7S64.h **** 	return pPMC->PMC_IMR;
1257:lib_AT91SAM7S64.h **** }
1258:lib_AT91SAM7S64.h **** 
1259:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1260:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_IsInterruptMasked
1261:lib_AT91SAM7S64.h **** //* \brief Test if PMC Interrupt is Masked
1262:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1263:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_IsInterruptMasked(
1264:lib_AT91SAM7S64.h ****         AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
1265:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1266:lib_AT91SAM7S64.h **** {
1267:lib_AT91SAM7S64.h **** 	return (AT91F_PMC_GetInterruptMaskStatus(pPMC) & flag);
1268:lib_AT91SAM7S64.h **** }
1269:lib_AT91SAM7S64.h **** 
1270:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1271:lib_AT91SAM7S64.h **** //* \fn    AT91F_PMC_IsStatusSet
1272:lib_AT91SAM7S64.h **** //* \brief Test if PMC Status is Set
1273:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1274:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PMC_IsStatusSet(
1275:lib_AT91SAM7S64.h ****         AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
1276:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1277:lib_AT91SAM7S64.h **** {
1278:lib_AT91SAM7S64.h **** 	return (AT91F_PMC_GetStatus(pPMC) & flag);
1279:lib_AT91SAM7S64.h **** }/* *****************************************************************************
1280:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR RSTC
1281:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1282:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1283:lib_AT91SAM7S64.h **** //* \fn    AT91F_RSTSoftReset
1284:lib_AT91SAM7S64.h **** //* \brief Start Software Reset
1285:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1286:lib_AT91SAM7S64.h **** __inline void AT91F_RSTSoftReset(
1287:lib_AT91SAM7S64.h ****         AT91PS_RSTC pRSTC,
1288:lib_AT91SAM7S64.h ****         unsigned int reset)
1289:lib_AT91SAM7S64.h **** {
1290:lib_AT91SAM7S64.h **** 	pRSTC->RSTC_RCR = (0xA5000000 | reset);
1291:lib_AT91SAM7S64.h **** }
1292:lib_AT91SAM7S64.h **** 
1293:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1294:lib_AT91SAM7S64.h **** //* \fn    AT91F_RSTSetMode
1295:lib_AT91SAM7S64.h **** //* \brief Set Reset Mode
1296:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1297:lib_AT91SAM7S64.h **** __inline void AT91F_RSTSetMode(
1298:lib_AT91SAM7S64.h ****         AT91PS_RSTC pRSTC,
1299:lib_AT91SAM7S64.h ****         unsigned int mode)
1300:lib_AT91SAM7S64.h **** {
1301:lib_AT91SAM7S64.h **** 	pRSTC->RSTC_RMR = (0xA5000000 | mode);
1302:lib_AT91SAM7S64.h **** }
1303:lib_AT91SAM7S64.h **** 
1304:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1305:lib_AT91SAM7S64.h **** //* \fn    AT91F_RSTGetMode
1306:lib_AT91SAM7S64.h **** //* \brief Get Reset Mode
1307:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1308:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RSTGetMode(
1309:lib_AT91SAM7S64.h ****         AT91PS_RSTC pRSTC)
1310:lib_AT91SAM7S64.h **** {
1311:lib_AT91SAM7S64.h **** 	return (pRSTC->RSTC_RMR);
1312:lib_AT91SAM7S64.h **** }
1313:lib_AT91SAM7S64.h **** 
1314:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1315:lib_AT91SAM7S64.h **** //* \fn    AT91F_RSTGetStatus
1316:lib_AT91SAM7S64.h **** //* \brief Get Reset Status
1317:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1318:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RSTGetStatus(
1319:lib_AT91SAM7S64.h ****         AT91PS_RSTC pRSTC)
1320:lib_AT91SAM7S64.h **** {
1321:lib_AT91SAM7S64.h **** 	return (pRSTC->RSTC_RSR);
1322:lib_AT91SAM7S64.h **** }
1323:lib_AT91SAM7S64.h **** 
1324:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1325:lib_AT91SAM7S64.h **** //* \fn    AT91F_RSTIsSoftRstActive
1326:lib_AT91SAM7S64.h **** //* \brief Return !=0 if software reset is still not completed
1327:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1328:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RSTIsSoftRstActive(
1329:lib_AT91SAM7S64.h ****         AT91PS_RSTC pRSTC)
1330:lib_AT91SAM7S64.h **** {
1331:lib_AT91SAM7S64.h **** 	return ((pRSTC->RSTC_RSR) & AT91C_RSTC_SRCMP);
1332:lib_AT91SAM7S64.h **** }
1333:lib_AT91SAM7S64.h **** /* *****************************************************************************
1334:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR RTTC
1335:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1336:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1337:lib_AT91SAM7S64.h **** //* \fn     AT91F_SetRTT_TimeBase()
1338:lib_AT91SAM7S64.h **** //* \brief  Set the RTT prescaler according to the TimeBase in ms
1339:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1340:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RTTSetTimeBase(
1341:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC, 
1342:lib_AT91SAM7S64.h ****         unsigned int ms)
1343:lib_AT91SAM7S64.h **** {
1344:lib_AT91SAM7S64.h **** 	if (ms > 2000)
1345:lib_AT91SAM7S64.h **** 		return 1;   // AT91C_TIME_OUT_OF_RANGE
1346:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR &= ~0xFFFF;	
1347:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR |= (((ms << 15) /1000) & 0xFFFF);	
1348:lib_AT91SAM7S64.h **** 	return 0;
1349:lib_AT91SAM7S64.h **** }
1350:lib_AT91SAM7S64.h **** 
1351:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1352:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTTSetPrescaler()
1353:lib_AT91SAM7S64.h **** //* \brief  Set the new prescaler value
1354:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1355:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RTTSetPrescaler(
1356:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC, 
1357:lib_AT91SAM7S64.h ****         unsigned int rtpres)
1358:lib_AT91SAM7S64.h **** {
1359:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR &= ~0xFFFF;	
1360:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR |= (rtpres & 0xFFFF);	
1361:lib_AT91SAM7S64.h **** 	return (pRTTC->RTTC_RTMR);
1362:lib_AT91SAM7S64.h **** }
1363:lib_AT91SAM7S64.h **** 
1364:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1365:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTTRestart()
1366:lib_AT91SAM7S64.h **** //* \brief  Restart the RTT prescaler
1367:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1368:lib_AT91SAM7S64.h **** __inline void AT91F_RTTRestart(
1369:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1370:lib_AT91SAM7S64.h **** {
1371:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTRST;	
1372:lib_AT91SAM7S64.h **** }
1373:lib_AT91SAM7S64.h **** 
1374:lib_AT91SAM7S64.h **** 
1375:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1376:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_SetAlarmINT()
1377:lib_AT91SAM7S64.h **** //* \brief  Enable RTT Alarm Interrupt
1378:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1379:lib_AT91SAM7S64.h **** __inline void AT91F_RTTSetAlarmINT(
1380:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1381:lib_AT91SAM7S64.h **** {
1382:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_ALMIEN;
1383:lib_AT91SAM7S64.h **** }
1384:lib_AT91SAM7S64.h **** 
1385:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1386:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_ClearAlarmINT()
1387:lib_AT91SAM7S64.h **** //* \brief  Disable RTT Alarm Interrupt
1388:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1389:lib_AT91SAM7S64.h **** __inline void AT91F_RTTClearAlarmINT(
1390:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1391:lib_AT91SAM7S64.h **** {
1392:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_ALMIEN;
1393:lib_AT91SAM7S64.h **** }
1394:lib_AT91SAM7S64.h **** 
1395:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1396:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_SetRttIncINT()
1397:lib_AT91SAM7S64.h **** //* \brief  Enable RTT INC Interrupt
1398:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1399:lib_AT91SAM7S64.h **** __inline void AT91F_RTTSetRttIncINT(
1400:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1401:lib_AT91SAM7S64.h **** {
1402:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTINCIEN;
1403:lib_AT91SAM7S64.h **** }
1404:lib_AT91SAM7S64.h **** 
1405:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1406:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_ClearRttIncINT()
1407:lib_AT91SAM7S64.h **** //* \brief  Disable RTT INC Interrupt
1408:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1409:lib_AT91SAM7S64.h **** __inline void AT91F_RTTClearRttIncINT(
1410:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1411:lib_AT91SAM7S64.h **** {
1412:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_RTTINCIEN;
1413:lib_AT91SAM7S64.h **** }
1414:lib_AT91SAM7S64.h **** 
1415:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1416:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_SetAlarmValue()
1417:lib_AT91SAM7S64.h **** //* \brief  Set RTT Alarm Value
1418:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1419:lib_AT91SAM7S64.h **** __inline void AT91F_RTTSetAlarmValue(
1420:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC, unsigned int alarm)
1421:lib_AT91SAM7S64.h **** {
1422:lib_AT91SAM7S64.h **** 	pRTTC->RTTC_RTAR = alarm;
1423:lib_AT91SAM7S64.h **** }
1424:lib_AT91SAM7S64.h **** 
1425:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1426:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_GetAlarmValue()
1427:lib_AT91SAM7S64.h **** //* \brief  Get RTT Alarm Value
1428:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1429:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RTTGetAlarmValue(
1430:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1431:lib_AT91SAM7S64.h **** {
1432:lib_AT91SAM7S64.h **** 	return(pRTTC->RTTC_RTAR);
1433:lib_AT91SAM7S64.h **** }
1434:lib_AT91SAM7S64.h **** 
1435:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1436:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTTGetStatus()
1437:lib_AT91SAM7S64.h **** //* \brief  Read the RTT status
1438:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1439:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RTTGetStatus(
1440:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1441:lib_AT91SAM7S64.h **** {
1442:lib_AT91SAM7S64.h **** 	return(pRTTC->RTTC_RTSR);
1443:lib_AT91SAM7S64.h **** }
1444:lib_AT91SAM7S64.h **** 
1445:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1446:lib_AT91SAM7S64.h **** //* \fn     AT91F_RTT_ReadValue()
1447:lib_AT91SAM7S64.h **** //* \brief  Read the RTT value
1448:lib_AT91SAM7S64.h **** //*--------------------------------------------------------------------------------------
1449:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_RTTReadValue(
1450:lib_AT91SAM7S64.h ****         AT91PS_RTTC pRTTC)
1451:lib_AT91SAM7S64.h **** {
1452:lib_AT91SAM7S64.h ****         register volatile unsigned int val1,val2;
1453:lib_AT91SAM7S64.h **** 	do
1454:lib_AT91SAM7S64.h **** 	{
1455:lib_AT91SAM7S64.h **** 		val1 = pRTTC->RTTC_RTVR;
1456:lib_AT91SAM7S64.h **** 		val2 = pRTTC->RTTC_RTVR;
1457:lib_AT91SAM7S64.h **** 	}	
1458:lib_AT91SAM7S64.h **** 	while(val1 != val2);
1459:lib_AT91SAM7S64.h **** 	return(val1);
1460:lib_AT91SAM7S64.h **** }
1461:lib_AT91SAM7S64.h **** /* *****************************************************************************
1462:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR PITC
1463:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1464:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1465:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITInit
1466:lib_AT91SAM7S64.h **** //* \brief System timer init : period in second, system clock freq in MHz
1467:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1468:lib_AT91SAM7S64.h **** __inline void AT91F_PITInit(
1469:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC,
1470:lib_AT91SAM7S64.h ****         unsigned int period,
1471:lib_AT91SAM7S64.h ****         unsigned int pit_frequency)
1472:lib_AT91SAM7S64.h **** {
1473:lib_AT91SAM7S64.h **** 	pPITC->PITC_PIMR = period? (period * pit_frequency + 8) >> 4 : 0; // +8 to avoid %10 and /10
1474:lib_AT91SAM7S64.h **** 	pPITC->PITC_PIMR |= AT91C_PITC_PITEN;	 
1475:lib_AT91SAM7S64.h **** }
1476:lib_AT91SAM7S64.h **** 
1477:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1478:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITSetPIV
1479:lib_AT91SAM7S64.h **** //* \brief Set the PIT Periodic Interval Value 
1480:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1481:lib_AT91SAM7S64.h **** __inline void AT91F_PITSetPIV(
1482:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC,
1483:lib_AT91SAM7S64.h ****         unsigned int piv)
1484:lib_AT91SAM7S64.h **** {
1485:lib_AT91SAM7S64.h **** 	pPITC->PITC_PIMR = piv | (pPITC->PITC_PIMR & (AT91C_PITC_PITEN | AT91C_PITC_PITIEN));
1486:lib_AT91SAM7S64.h **** }
1487:lib_AT91SAM7S64.h **** 
1488:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1489:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITEnableInt
1490:lib_AT91SAM7S64.h **** //* \brief Enable PIT periodic interrupt
1491:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1492:lib_AT91SAM7S64.h **** __inline void AT91F_PITEnableInt(
1493:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1494:lib_AT91SAM7S64.h **** {
1495:lib_AT91SAM7S64.h **** 	pPITC->PITC_PIMR |= AT91C_PITC_PITIEN;	 
1496:lib_AT91SAM7S64.h **** }
1497:lib_AT91SAM7S64.h **** 
1498:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1499:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITDisableInt
1500:lib_AT91SAM7S64.h **** //* \brief Disable PIT periodic interrupt
1501:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1502:lib_AT91SAM7S64.h **** __inline void AT91F_PITDisableInt(
1503:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1504:lib_AT91SAM7S64.h **** {
1505:lib_AT91SAM7S64.h **** 	pPITC->PITC_PIMR &= ~AT91C_PITC_PITIEN;	 
1506:lib_AT91SAM7S64.h **** }
1507:lib_AT91SAM7S64.h **** 
1508:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1509:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITGetMode
1510:lib_AT91SAM7S64.h **** //* \brief Read PIT mode register
1511:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1512:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PITGetMode(
1513:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1514:lib_AT91SAM7S64.h **** {
1515:lib_AT91SAM7S64.h **** 	return(pPITC->PITC_PIMR);
1516:lib_AT91SAM7S64.h **** }
1517:lib_AT91SAM7S64.h **** 
1518:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1519:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITGetStatus
1520:lib_AT91SAM7S64.h **** //* \brief Read PIT status register
1521:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1522:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PITGetStatus(
1523:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1524:lib_AT91SAM7S64.h **** {
1525:lib_AT91SAM7S64.h **** 	return(pPITC->PITC_PISR);
1526:lib_AT91SAM7S64.h **** }
1527:lib_AT91SAM7S64.h **** 
1528:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1529:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITGetPIIR
1530:lib_AT91SAM7S64.h **** //* \brief Read PIT CPIV and PICNT without ressetting the counters
1531:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1532:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PITGetPIIR(
1533:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1534:lib_AT91SAM7S64.h **** {
1535:lib_AT91SAM7S64.h **** 	return(pPITC->PITC_PIIR);
1536:lib_AT91SAM7S64.h **** }
1537:lib_AT91SAM7S64.h **** 
1538:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1539:lib_AT91SAM7S64.h **** //* \fn    AT91F_PITGetPIVR
1540:lib_AT91SAM7S64.h **** //* \brief Read System timer CPIV and PICNT without ressetting the counters
1541:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1542:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PITGetPIVR(
1543:lib_AT91SAM7S64.h ****         AT91PS_PITC pPITC)
1544:lib_AT91SAM7S64.h **** {
1545:lib_AT91SAM7S64.h **** 	return(pPITC->PITC_PIVR);
1546:lib_AT91SAM7S64.h **** }
1547:lib_AT91SAM7S64.h **** /* *****************************************************************************
1548:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR WDTC
1549:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1550:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1551:lib_AT91SAM7S64.h **** //* \fn    AT91F_WDTSetMode
1552:lib_AT91SAM7S64.h **** //* \brief Set Watchdog Mode Register
1553:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1554:lib_AT91SAM7S64.h **** __inline void AT91F_WDTSetMode(
1555:lib_AT91SAM7S64.h ****         AT91PS_WDTC pWDTC,
1556:lib_AT91SAM7S64.h ****         unsigned int Mode)
1557:lib_AT91SAM7S64.h **** {
1558:lib_AT91SAM7S64.h **** 	pWDTC->WDTC_WDMR = Mode;
1559:lib_AT91SAM7S64.h **** }
1560:lib_AT91SAM7S64.h **** 
1561:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1562:lib_AT91SAM7S64.h **** //* \fn    AT91F_WDTRestart
1563:lib_AT91SAM7S64.h **** //* \brief Restart Watchdog
1564:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1565:lib_AT91SAM7S64.h **** __inline void AT91F_WDTRestart(
1566:lib_AT91SAM7S64.h ****         AT91PS_WDTC pWDTC)
1567:lib_AT91SAM7S64.h **** {
1568:lib_AT91SAM7S64.h **** 	pWDTC->WDTC_WDCR = 0xA5000001;
1569:lib_AT91SAM7S64.h **** }
1570:lib_AT91SAM7S64.h **** 
1571:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1572:lib_AT91SAM7S64.h **** //* \fn    AT91F_WDTSGettatus
1573:lib_AT91SAM7S64.h **** //* \brief Get Watchdog Status
1574:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1575:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_WDTSGettatus(
1576:lib_AT91SAM7S64.h ****         AT91PS_WDTC pWDTC)
1577:lib_AT91SAM7S64.h **** {
1578:lib_AT91SAM7S64.h **** 	return(pWDTC->WDTC_WDSR & 0x3);
1579:lib_AT91SAM7S64.h **** }
1580:lib_AT91SAM7S64.h **** 
1581:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1582:lib_AT91SAM7S64.h **** //* \fn    AT91F_WDTGetPeriod
1583:lib_AT91SAM7S64.h **** //* \brief Translate ms into Watchdog Compatible value
1584:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1585:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_WDTGetPeriod(unsigned int ms)
1586:lib_AT91SAM7S64.h **** {
1587:lib_AT91SAM7S64.h **** 	if ((ms < 4) || (ms > 16000))
1588:lib_AT91SAM7S64.h **** 		return 0;
1589:lib_AT91SAM7S64.h **** 	return((ms << 8) / 1000);
1590:lib_AT91SAM7S64.h **** }
1591:lib_AT91SAM7S64.h **** /* *****************************************************************************
1592:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR VREG
1593:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1594:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1595:lib_AT91SAM7S64.h **** //* \fn    AT91F_VREG_Enable_LowPowerMode
1596:lib_AT91SAM7S64.h **** //* \brief Enable VREG Low Power Mode
1597:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1598:lib_AT91SAM7S64.h **** __inline void AT91F_VREG_Enable_LowPowerMode(
1599:lib_AT91SAM7S64.h ****         AT91PS_VREG pVREG)
1600:lib_AT91SAM7S64.h **** {
1601:lib_AT91SAM7S64.h **** 	pVREG->VREG_MR |= AT91C_VREG_PSTDBY;	 
1602:lib_AT91SAM7S64.h **** }
1603:lib_AT91SAM7S64.h **** 
1604:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1605:lib_AT91SAM7S64.h **** //* \fn    AT91F_VREG_Disable_LowPowerMode
1606:lib_AT91SAM7S64.h **** //* \brief Disable VREG Low Power Mode
1607:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1608:lib_AT91SAM7S64.h **** __inline void AT91F_VREG_Disable_LowPowerMode(
1609:lib_AT91SAM7S64.h ****         AT91PS_VREG pVREG)
1610:lib_AT91SAM7S64.h **** {
1611:lib_AT91SAM7S64.h **** 	pVREG->VREG_MR &= ~AT91C_VREG_PSTDBY;	 
1612:lib_AT91SAM7S64.h **** }/* *****************************************************************************
1613:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR MC
1614:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1615:lib_AT91SAM7S64.h **** 
1616:lib_AT91SAM7S64.h **** #define AT91C_MC_CORRECT_KEY  ((unsigned int) 0x5A << 24) // (MC) Correct Protect Key
1617:lib_AT91SAM7S64.h **** 
1618:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1619:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_Remap
1620:lib_AT91SAM7S64.h **** //* \brief Make Remap
1621:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1622:lib_AT91SAM7S64.h **** __inline void AT91F_MC_Remap (void)     //  
1623:lib_AT91SAM7S64.h **** {
1624:lib_AT91SAM7S64.h ****     AT91PS_MC pMC = (AT91PS_MC) AT91C_BASE_MC;
1625:lib_AT91SAM7S64.h ****     
1626:lib_AT91SAM7S64.h ****     pMC->MC_RCR = AT91C_MC_RCB;
1627:lib_AT91SAM7S64.h **** }
1628:lib_AT91SAM7S64.h **** 
1629:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1630:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_CfgModeReg
1631:lib_AT91SAM7S64.h **** //* \brief Configure the EFC Mode Register of the MC controller
1632:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1633:lib_AT91SAM7S64.h **** __inline void AT91F_MC_EFC_CfgModeReg (
1634:lib_AT91SAM7S64.h **** 	AT91PS_MC pMC, // pointer to a MC controller
1635:lib_AT91SAM7S64.h **** 	unsigned int mode)        // mode register 
1636:lib_AT91SAM7S64.h **** {
1637:lib_AT91SAM7S64.h **** 	// Write to the FMR register
1638:lib_AT91SAM7S64.h **** 	pMC->MC_FMR = mode;
1639:lib_AT91SAM7S64.h **** }
1640:lib_AT91SAM7S64.h **** 
1641:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1642:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_GetModeReg
1643:lib_AT91SAM7S64.h **** //* \brief Return MC EFC Mode Regsiter
1644:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1645:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_MC_EFC_GetModeReg(
1646:lib_AT91SAM7S64.h **** 	AT91PS_MC pMC) // pointer to a MC controller
1647:lib_AT91SAM7S64.h **** {
1648:lib_AT91SAM7S64.h **** 	return pMC->MC_FMR;
1649:lib_AT91SAM7S64.h **** }
1650:lib_AT91SAM7S64.h **** 
1651:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1652:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_ComputeFMCN
1653:lib_AT91SAM7S64.h **** //* \brief Return MC EFC Mode Regsiter
1654:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1655:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_MC_EFC_ComputeFMCN(
1656:lib_AT91SAM7S64.h **** 	int master_clock) // master clock in Hz
1657:lib_AT91SAM7S64.h **** {
1658:lib_AT91SAM7S64.h **** 	return (master_clock/1000000 +2);
1659:lib_AT91SAM7S64.h **** }
1660:lib_AT91SAM7S64.h **** 
1661:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1662:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_PerformCmd
1663:lib_AT91SAM7S64.h **** //* \brief Perform EFC Command
1664:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1665:lib_AT91SAM7S64.h **** __inline void AT91F_MC_EFC_PerformCmd (
1666:lib_AT91SAM7S64.h **** 	AT91PS_MC pMC, // pointer to a MC controller
1667:lib_AT91SAM7S64.h ****     unsigned int transfer_cmd)
1668:lib_AT91SAM7S64.h **** {
1669:lib_AT91SAM7S64.h **** 	pMC->MC_FCR = transfer_cmd;	
1670:lib_AT91SAM7S64.h **** }
1671:lib_AT91SAM7S64.h **** 
1672:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1673:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_GetStatus
1674:lib_AT91SAM7S64.h **** //* \brief Return MC EFC Status
1675:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1676:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_MC_EFC_GetStatus(
1677:lib_AT91SAM7S64.h **** 	AT91PS_MC pMC) // pointer to a MC controller
1678:lib_AT91SAM7S64.h **** {
1679:lib_AT91SAM7S64.h **** 	return pMC->MC_FSR;
1680:lib_AT91SAM7S64.h **** }
1681:lib_AT91SAM7S64.h **** 
1682:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1683:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_IsInterruptMasked
1684:lib_AT91SAM7S64.h **** //* \brief Test if EFC MC Interrupt is Masked 
1685:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1686:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_MC_EFC_IsInterruptMasked(
1687:lib_AT91SAM7S64.h ****         AT91PS_MC pMC,   // \arg  pointer to a MC controller
1688:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1689:lib_AT91SAM7S64.h **** {
1690:lib_AT91SAM7S64.h **** 	return (AT91F_MC_EFC_GetModeReg(pMC) & flag);
1691:lib_AT91SAM7S64.h **** }
1692:lib_AT91SAM7S64.h **** 
1693:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1694:lib_AT91SAM7S64.h **** //* \fn    AT91F_MC_EFC_IsInterruptSet
1695:lib_AT91SAM7S64.h **** //* \brief Test if EFC MC Interrupt is Set
1696:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1697:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_MC_EFC_IsInterruptSet(
1698:lib_AT91SAM7S64.h ****         AT91PS_MC pMC,   // \arg  pointer to a MC controller
1699:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1700:lib_AT91SAM7S64.h **** {
1701:lib_AT91SAM7S64.h **** 	return (AT91F_MC_EFC_GetStatus(pMC) & flag);
1702:lib_AT91SAM7S64.h **** }
1703:lib_AT91SAM7S64.h **** 
1704:lib_AT91SAM7S64.h **** /* *****************************************************************************
1705:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR SPI
1706:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1707:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1708:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_Open
1709:lib_AT91SAM7S64.h **** //* \brief Open a SPI Port
1710:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1711:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SPI_Open (
1712:lib_AT91SAM7S64.h ****         const unsigned int null)  // \arg
1713:lib_AT91SAM7S64.h **** {
1714:lib_AT91SAM7S64.h ****         /* NOT DEFINED AT THIS MOMENT */
1715:lib_AT91SAM7S64.h ****         return ( 0 );
1716:lib_AT91SAM7S64.h **** }
1717:lib_AT91SAM7S64.h **** 
1718:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1719:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_CfgCs
1720:lib_AT91SAM7S64.h **** //* \brief Configure SPI chip select register
1721:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1722:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_CfgCs (
1723:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI,     // pointer to a SPI controller
1724:lib_AT91SAM7S64.h **** 	int cs,     // SPI cs number (0 to 3)
1725:lib_AT91SAM7S64.h ****  	int val)   //  chip select register
1726:lib_AT91SAM7S64.h **** {
1727:lib_AT91SAM7S64.h **** 	//* Write to the CSR register
1728:lib_AT91SAM7S64.h **** 	*(pSPI->SPI_CSR + cs) = val;
1729:lib_AT91SAM7S64.h **** }
1730:lib_AT91SAM7S64.h **** 
1731:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1732:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_EnableIt
1733:lib_AT91SAM7S64.h **** //* \brief Enable SPI interrupt
1734:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1735:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_EnableIt (
1736:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI,     // pointer to a SPI controller
1737:lib_AT91SAM7S64.h **** 	unsigned int flag)   // IT to be enabled
1738:lib_AT91SAM7S64.h **** {
1739:lib_AT91SAM7S64.h **** 	//* Write to the IER register
1740:lib_AT91SAM7S64.h **** 	pSPI->SPI_IER = flag;
1741:lib_AT91SAM7S64.h **** }
1742:lib_AT91SAM7S64.h **** 
1743:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1744:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_DisableIt
1745:lib_AT91SAM7S64.h **** //* \brief Disable SPI interrupt
1746:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1747:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_DisableIt (
1748:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI, // pointer to a SPI controller
1749:lib_AT91SAM7S64.h **** 	unsigned int flag) // IT to be disabled
1750:lib_AT91SAM7S64.h **** {
1751:lib_AT91SAM7S64.h **** 	//* Write to the IDR register
1752:lib_AT91SAM7S64.h **** 	pSPI->SPI_IDR = flag;
1753:lib_AT91SAM7S64.h **** }
1754:lib_AT91SAM7S64.h **** 
1755:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1756:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_Reset
1757:lib_AT91SAM7S64.h **** //* \brief Reset the SPI controller
1758:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1759:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_Reset (
1760:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
1761:lib_AT91SAM7S64.h **** 	)
1762:lib_AT91SAM7S64.h **** {
1763:lib_AT91SAM7S64.h **** 	//* Write to the CR register
1764:lib_AT91SAM7S64.h **** 	pSPI->SPI_CR = AT91C_SPI_SWRST;
1765:lib_AT91SAM7S64.h **** }
1766:lib_AT91SAM7S64.h **** 
1767:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1768:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_Enable
1769:lib_AT91SAM7S64.h **** //* \brief Enable the SPI controller
1770:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1771:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_Enable (
1772:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
1773:lib_AT91SAM7S64.h **** 	)
1774:lib_AT91SAM7S64.h **** {
1775:lib_AT91SAM7S64.h **** 	//* Write to the CR register
1776:lib_AT91SAM7S64.h **** 	pSPI->SPI_CR = AT91C_SPI_SPIEN;
1777:lib_AT91SAM7S64.h **** }
1778:lib_AT91SAM7S64.h **** 
1779:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1780:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_Disable
1781:lib_AT91SAM7S64.h **** //* \brief Disable the SPI controller
1782:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1783:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_Disable (
1784:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI // pointer to a SPI controller
1785:lib_AT91SAM7S64.h **** 	)
1786:lib_AT91SAM7S64.h **** {
1787:lib_AT91SAM7S64.h **** 	//* Write to the CR register
1788:lib_AT91SAM7S64.h **** 	pSPI->SPI_CR = AT91C_SPI_SPIDIS;
1789:lib_AT91SAM7S64.h **** }
1790:lib_AT91SAM7S64.h **** 
1791:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1792:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_CfgMode
1793:lib_AT91SAM7S64.h **** //* \brief Enable the SPI controller
1794:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1795:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_CfgMode (
1796:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI, // pointer to a SPI controller
1797:lib_AT91SAM7S64.h **** 	int mode)        // mode register 
1798:lib_AT91SAM7S64.h **** {
1799:lib_AT91SAM7S64.h **** 	//* Write to the MR register
1800:lib_AT91SAM7S64.h **** 	pSPI->SPI_MR = mode;
1801:lib_AT91SAM7S64.h **** }
1802:lib_AT91SAM7S64.h **** 
1803:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1804:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_CfgPCS
1805:lib_AT91SAM7S64.h **** //* \brief Switch to the correct PCS of SPI Mode Register : Fixed Peripheral Selected
1806:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1807:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_CfgPCS (
1808:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI, // pointer to a SPI controller
1809:lib_AT91SAM7S64.h **** 	char PCS_Device) // PCS of the Device
1810:lib_AT91SAM7S64.h **** {	
1811:lib_AT91SAM7S64.h ****  	//* Write to the MR register
1812:lib_AT91SAM7S64.h **** 	pSPI->SPI_MR &= 0xFFF0FFFF;
1813:lib_AT91SAM7S64.h **** 	pSPI->SPI_MR |= ( (PCS_Device<<16) & AT91C_SPI_PCS );
1814:lib_AT91SAM7S64.h **** }
1815:lib_AT91SAM7S64.h **** 
1816:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1817:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_ReceiveFrame
1818:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
1819:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1820:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SPI_ReceiveFrame (
1821:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI,
1822:lib_AT91SAM7S64.h **** 	char *pBuffer,
1823:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
1824:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
1825:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
1826:lib_AT91SAM7S64.h **** {
1827:lib_AT91SAM7S64.h **** 	return AT91F_PDC_ReceiveFrame(
1828:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pSPI->SPI_RPR),
1829:lib_AT91SAM7S64.h **** 		pBuffer,
1830:lib_AT91SAM7S64.h **** 		szBuffer,
1831:lib_AT91SAM7S64.h **** 		pNextBuffer,
1832:lib_AT91SAM7S64.h **** 		szNextBuffer);
1833:lib_AT91SAM7S64.h **** }
1834:lib_AT91SAM7S64.h **** 
1835:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1836:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_SendFrame
1837:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
1838:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1839:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SPI_SendFrame(
1840:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI,
1841:lib_AT91SAM7S64.h **** 	char *pBuffer,
1842:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
1843:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
1844:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
1845:lib_AT91SAM7S64.h **** {
1846:lib_AT91SAM7S64.h **** 	return AT91F_PDC_SendFrame(
1847:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pSPI->SPI_RPR),
1848:lib_AT91SAM7S64.h **** 		pBuffer,
1849:lib_AT91SAM7S64.h **** 		szBuffer,
1850:lib_AT91SAM7S64.h **** 		pNextBuffer,
1851:lib_AT91SAM7S64.h **** 		szNextBuffer);
1852:lib_AT91SAM7S64.h **** }
1853:lib_AT91SAM7S64.h **** 
1854:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1855:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_Close
1856:lib_AT91SAM7S64.h **** //* \brief Close SPI: disable IT disable transfert, close PDC
1857:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1858:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_Close (
1859:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI)     // \arg pointer to a SPI controller
1860:lib_AT91SAM7S64.h **** {
1861:lib_AT91SAM7S64.h ****     //* Reset all the Chip Select register
1862:lib_AT91SAM7S64.h ****     pSPI->SPI_CSR[0] = 0 ;
1863:lib_AT91SAM7S64.h ****     pSPI->SPI_CSR[1] = 0 ;
1864:lib_AT91SAM7S64.h ****     pSPI->SPI_CSR[2] = 0 ;
1865:lib_AT91SAM7S64.h ****     pSPI->SPI_CSR[3] = 0 ;
1866:lib_AT91SAM7S64.h **** 
1867:lib_AT91SAM7S64.h ****     //* Reset the SPI mode
1868:lib_AT91SAM7S64.h ****     pSPI->SPI_MR = 0  ;
1869:lib_AT91SAM7S64.h **** 
1870:lib_AT91SAM7S64.h ****     //* Disable all interrupts
1871:lib_AT91SAM7S64.h ****     pSPI->SPI_IDR = 0xFFFFFFFF ;
1872:lib_AT91SAM7S64.h **** 
1873:lib_AT91SAM7S64.h ****     //* Abort the Peripheral Data Transfers
1874:lib_AT91SAM7S64.h ****     AT91F_PDC_Close((AT91PS_PDC) &(pSPI->SPI_RPR));
1875:lib_AT91SAM7S64.h **** 
1876:lib_AT91SAM7S64.h ****     //* Disable receiver and transmitter and stop any activity immediately
1877:lib_AT91SAM7S64.h ****     pSPI->SPI_CR = AT91C_SPI_SPIDIS;
1878:lib_AT91SAM7S64.h **** }
1879:lib_AT91SAM7S64.h **** 
1880:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1881:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_PutChar
1882:lib_AT91SAM7S64.h **** //* \brief Send a character,does not check if ready to send
1883:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1884:lib_AT91SAM7S64.h **** __inline void AT91F_SPI_PutChar (
1885:lib_AT91SAM7S64.h **** 	AT91PS_SPI pSPI,
1886:lib_AT91SAM7S64.h **** 	unsigned int character,
1887:lib_AT91SAM7S64.h ****              unsigned int cs_number )
1888:lib_AT91SAM7S64.h **** {
1889:lib_AT91SAM7S64.h ****     unsigned int value_for_cs;
1890:lib_AT91SAM7S64.h ****     value_for_cs = (~(1 << cs_number)) & 0xF;  //Place a zero among a 4 ONEs number
1891:lib_AT91SAM7S64.h ****     pSPI->SPI_TDR = (character & 0xFFFF) | (value_for_cs << 16);
1892:lib_AT91SAM7S64.h **** }
1893:lib_AT91SAM7S64.h **** 
1894:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1895:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_GetChar
1896:lib_AT91SAM7S64.h **** //* \brief Receive a character,does not check if a character is available
1897:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1898:lib_AT91SAM7S64.h **** __inline int AT91F_SPI_GetChar (
1899:lib_AT91SAM7S64.h **** 	const AT91PS_SPI pSPI)
1900:lib_AT91SAM7S64.h **** {
1901:lib_AT91SAM7S64.h ****     return((pSPI->SPI_RDR) & 0xFFFF);
1902:lib_AT91SAM7S64.h **** }
1903:lib_AT91SAM7S64.h **** 
1904:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1905:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_GetInterruptMaskStatus
1906:lib_AT91SAM7S64.h **** //* \brief Return SPI Interrupt Mask Status
1907:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1908:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SPI_GetInterruptMaskStatus( // \return SPI Interrupt Mask Status
1909:lib_AT91SAM7S64.h ****         AT91PS_SPI pSpi) // \arg  pointer to a SPI controller
1910:lib_AT91SAM7S64.h **** {
1911:lib_AT91SAM7S64.h ****         return pSpi->SPI_IMR;
1912:lib_AT91SAM7S64.h **** }
1913:lib_AT91SAM7S64.h **** 
1914:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1915:lib_AT91SAM7S64.h **** //* \fn    AT91F_SPI_IsInterruptMasked
1916:lib_AT91SAM7S64.h **** //* \brief Test if SPI Interrupt is Masked 
1917:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1918:lib_AT91SAM7S64.h **** __inline int AT91F_SPI_IsInterruptMasked(
1919:lib_AT91SAM7S64.h ****         AT91PS_SPI pSpi,   // \arg  pointer to a SPI controller
1920:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1921:lib_AT91SAM7S64.h **** {
1922:lib_AT91SAM7S64.h ****         return (AT91F_SPI_GetInterruptMaskStatus(pSpi) & flag);
1923:lib_AT91SAM7S64.h **** }
1924:lib_AT91SAM7S64.h **** 
1925:lib_AT91SAM7S64.h **** /* *****************************************************************************
1926:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR ADC
1927:lib_AT91SAM7S64.h ****    ***************************************************************************** */
1928:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1929:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_EnableIt
1930:lib_AT91SAM7S64.h **** //* \brief Enable ADC interrupt
1931:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1932:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_EnableIt (
1933:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC,     // pointer to a ADC controller
1934:lib_AT91SAM7S64.h **** 	unsigned int flag)   // IT to be enabled
1935:lib_AT91SAM7S64.h **** {
1936:lib_AT91SAM7S64.h **** 	//* Write to the IER register
1937:lib_AT91SAM7S64.h **** 	pADC->ADC_IER = flag;
1938:lib_AT91SAM7S64.h **** }
1939:lib_AT91SAM7S64.h **** 
1940:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1941:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_DisableIt
1942:lib_AT91SAM7S64.h **** //* \brief Disable ADC interrupt
1943:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1944:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_DisableIt (
1945:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
1946:lib_AT91SAM7S64.h **** 	unsigned int flag) // IT to be disabled
1947:lib_AT91SAM7S64.h **** {
1948:lib_AT91SAM7S64.h **** 	//* Write to the IDR register
1949:lib_AT91SAM7S64.h **** 	pADC->ADC_IDR = flag;
1950:lib_AT91SAM7S64.h **** }
1951:lib_AT91SAM7S64.h **** 
1952:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1953:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetStatus
1954:lib_AT91SAM7S64.h **** //* \brief Return ADC Interrupt Status
1955:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1956:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetStatus( // \return ADC Interrupt Status
1957:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC) // pointer to a ADC controller
1958:lib_AT91SAM7S64.h **** {
1959:lib_AT91SAM7S64.h **** 	return pADC->ADC_SR;
1960:lib_AT91SAM7S64.h **** }
1961:lib_AT91SAM7S64.h **** 
1962:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1963:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetInterruptMaskStatus
1964:lib_AT91SAM7S64.h **** //* \brief Return ADC Interrupt Mask Status
1965:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1966:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetInterruptMaskStatus( // \return ADC Interrupt Mask Status
1967:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC) // pointer to a ADC controller
1968:lib_AT91SAM7S64.h **** {
1969:lib_AT91SAM7S64.h **** 	return pADC->ADC_IMR;
1970:lib_AT91SAM7S64.h **** }
1971:lib_AT91SAM7S64.h **** 
1972:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1973:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_IsInterruptMasked
1974:lib_AT91SAM7S64.h **** //* \brief Test if ADC Interrupt is Masked 
1975:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1976:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_IsInterruptMasked(
1977:lib_AT91SAM7S64.h ****         AT91PS_ADC pADC,   // \arg  pointer to a ADC controller
1978:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1979:lib_AT91SAM7S64.h **** {
1980:lib_AT91SAM7S64.h **** 	return (AT91F_ADC_GetInterruptMaskStatus(pADC) & flag);
1981:lib_AT91SAM7S64.h **** }
1982:lib_AT91SAM7S64.h **** 
1983:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1984:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_IsStatusSet
1985:lib_AT91SAM7S64.h **** //* \brief Test if ADC Status is Set
1986:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1987:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_IsStatusSet(
1988:lib_AT91SAM7S64.h ****         AT91PS_ADC pADC,   // \arg  pointer to a ADC controller
1989:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
1990:lib_AT91SAM7S64.h **** {
1991:lib_AT91SAM7S64.h **** 	return (AT91F_ADC_GetStatus(pADC) & flag);
1992:lib_AT91SAM7S64.h **** }
1993:lib_AT91SAM7S64.h **** 
1994:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1995:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_CfgModeReg
1996:lib_AT91SAM7S64.h **** //* \brief Configure the Mode Register of the ADC controller
1997:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
1998:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_CfgModeReg (
1999:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
2000:lib_AT91SAM7S64.h **** 	unsigned int mode)        // mode register 
2001:lib_AT91SAM7S64.h **** {
2002:lib_AT91SAM7S64.h **** 	//* Write to the MR register
2003:lib_AT91SAM7S64.h **** 	pADC->ADC_MR = mode;
2004:lib_AT91SAM7S64.h **** }
2005:lib_AT91SAM7S64.h **** 
2006:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2007:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetModeReg
2008:lib_AT91SAM7S64.h **** //* \brief Return the Mode Register of the ADC controller value
2009:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2010:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetModeReg (
2011:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2012:lib_AT91SAM7S64.h **** 	)
2013:lib_AT91SAM7S64.h **** {
2014:lib_AT91SAM7S64.h **** 	return pADC->ADC_MR;	
2015:lib_AT91SAM7S64.h **** }
2016:lib_AT91SAM7S64.h **** 
2017:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2018:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_CfgTimings
2019:lib_AT91SAM7S64.h **** //* \brief Configure the different necessary timings of the ADC controller
2020:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2021:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_CfgTimings (
2022:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
2023:lib_AT91SAM7S64.h **** 	unsigned int mck_clock, // in MHz 
2024:lib_AT91SAM7S64.h **** 	unsigned int adc_clock, // in MHz 
2025:lib_AT91SAM7S64.h **** 	unsigned int startup_time, // in us 
2026:lib_AT91SAM7S64.h **** 	unsigned int sample_and_hold_time)	// in ns  
2027:lib_AT91SAM7S64.h **** {
2028:lib_AT91SAM7S64.h **** 	unsigned int prescal,startup,shtim;
2029:lib_AT91SAM7S64.h **** 	
2030:lib_AT91SAM7S64.h **** 	prescal = mck_clock/(2*adc_clock) - 1;
2031:lib_AT91SAM7S64.h **** 	startup = adc_clock*startup_time/8 - 1;
2032:lib_AT91SAM7S64.h **** 	shtim = adc_clock*sample_and_hold_time/1000 - 1;
2033:lib_AT91SAM7S64.h **** 	
2034:lib_AT91SAM7S64.h **** 	//* Write to the MR register
2035:lib_AT91SAM7S64.h **** 	pADC->ADC_MR = ( (prescal<<8) & AT91C_ADC_PRESCAL) | ( (startup<<16) & AT91C_ADC_STARTUP) | ( (sht
2036:lib_AT91SAM7S64.h **** }
2037:lib_AT91SAM7S64.h **** 
2038:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2039:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_EnableChannel
2040:lib_AT91SAM7S64.h **** //* \brief Return ADC Timer Register Value
2041:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2042:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_EnableChannel (
2043:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
2044:lib_AT91SAM7S64.h **** 	unsigned int channel)        // mode register 
2045:lib_AT91SAM7S64.h **** {
2046:lib_AT91SAM7S64.h **** 	//* Write to the CHER register
2047:lib_AT91SAM7S64.h **** 	pADC->ADC_CHER = channel;
2048:lib_AT91SAM7S64.h **** }
2049:lib_AT91SAM7S64.h **** 
2050:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2051:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_DisableChannel
2052:lib_AT91SAM7S64.h **** //* \brief Return ADC Timer Register Value
2053:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2054:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_DisableChannel (
2055:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC, // pointer to a ADC controller
2056:lib_AT91SAM7S64.h **** 	unsigned int channel)        // mode register 
2057:lib_AT91SAM7S64.h **** {
2058:lib_AT91SAM7S64.h **** 	//* Write to the CHDR register
2059:lib_AT91SAM7S64.h **** 	pADC->ADC_CHDR = channel;
2060:lib_AT91SAM7S64.h **** }
2061:lib_AT91SAM7S64.h **** 
2062:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2063:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetChannelStatus
2064:lib_AT91SAM7S64.h **** //* \brief Return ADC Timer Register Value
2065:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2066:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetChannelStatus (
2067:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2068:lib_AT91SAM7S64.h **** 	)
2069:lib_AT91SAM7S64.h **** {
2070:lib_AT91SAM7S64.h **** 	return pADC->ADC_CHSR;	
2071:lib_AT91SAM7S64.h **** }
2072:lib_AT91SAM7S64.h **** 
2073:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2074:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_StartConversion
2075:lib_AT91SAM7S64.h **** //* \brief Software request for a analog to digital conversion 
2076:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2077:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_StartConversion (
2078:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2079:lib_AT91SAM7S64.h **** 	)
2080:lib_AT91SAM7S64.h **** {
2081:lib_AT91SAM7S64.h **** 	pADC->ADC_CR = AT91C_ADC_START;	
2082:lib_AT91SAM7S64.h **** }
2083:lib_AT91SAM7S64.h **** 
2084:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2085:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_SoftReset
2086:lib_AT91SAM7S64.h **** //* \brief Software reset
2087:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2088:lib_AT91SAM7S64.h **** __inline void AT91F_ADC_SoftReset (
2089:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2090:lib_AT91SAM7S64.h **** 	)
2091:lib_AT91SAM7S64.h **** {
2092:lib_AT91SAM7S64.h **** 	pADC->ADC_CR = AT91C_ADC_SWRST;	
2093:lib_AT91SAM7S64.h **** }
2094:lib_AT91SAM7S64.h **** 
2095:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2096:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetLastConvertedData
2097:lib_AT91SAM7S64.h **** //* \brief Return the Last Converted Data
2098:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2099:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetLastConvertedData (
2100:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2101:lib_AT91SAM7S64.h **** 	)
2102:lib_AT91SAM7S64.h **** {
2103:lib_AT91SAM7S64.h **** 	return pADC->ADC_LCDR;	
2104:lib_AT91SAM7S64.h **** }
2105:lib_AT91SAM7S64.h **** 
2106:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2107:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH0
2108:lib_AT91SAM7S64.h **** //* \brief Return the Channel 0 Converted Data
2109:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2110:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH0 (
2111:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2112:lib_AT91SAM7S64.h **** 	)
2113:lib_AT91SAM7S64.h **** {
2114:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR0;	
2115:lib_AT91SAM7S64.h **** }
2116:lib_AT91SAM7S64.h **** 
2117:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2118:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH1
2119:lib_AT91SAM7S64.h **** //* \brief Return the Channel 1 Converted Data
2120:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2121:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH1 (
2122:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2123:lib_AT91SAM7S64.h **** 	)
2124:lib_AT91SAM7S64.h **** {
2125:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR1;	
2126:lib_AT91SAM7S64.h **** }
2127:lib_AT91SAM7S64.h **** 
2128:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2129:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH2
2130:lib_AT91SAM7S64.h **** //* \brief Return the Channel 2 Converted Data
2131:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2132:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH2 (
2133:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2134:lib_AT91SAM7S64.h **** 	)
2135:lib_AT91SAM7S64.h **** {
2136:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR2;	
2137:lib_AT91SAM7S64.h **** }
2138:lib_AT91SAM7S64.h **** 
2139:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2140:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH3
2141:lib_AT91SAM7S64.h **** //* \brief Return the Channel 3 Converted Data
2142:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2143:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH3 (
2144:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2145:lib_AT91SAM7S64.h **** 	)
2146:lib_AT91SAM7S64.h **** {
2147:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR3;	
2148:lib_AT91SAM7S64.h **** }
2149:lib_AT91SAM7S64.h **** 
2150:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2151:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH4
2152:lib_AT91SAM7S64.h **** //* \brief Return the Channel 4 Converted Data
2153:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2154:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH4 (
2155:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2156:lib_AT91SAM7S64.h **** 	)
2157:lib_AT91SAM7S64.h **** {
2158:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR4;	
2159:lib_AT91SAM7S64.h **** }
2160:lib_AT91SAM7S64.h **** 
2161:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2162:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH5
2163:lib_AT91SAM7S64.h **** //* \brief Return the Channel 5 Converted Data
2164:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2165:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH5 (
2166:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2167:lib_AT91SAM7S64.h **** 	)
2168:lib_AT91SAM7S64.h **** {
2169:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR5;	
2170:lib_AT91SAM7S64.h **** }
2171:lib_AT91SAM7S64.h **** 
2172:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2173:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH6
2174:lib_AT91SAM7S64.h **** //* \brief Return the Channel 6 Converted Data
2175:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2176:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH6 (
2177:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2178:lib_AT91SAM7S64.h **** 	)
2179:lib_AT91SAM7S64.h **** {
2180:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR6;	
2181:lib_AT91SAM7S64.h **** }
2182:lib_AT91SAM7S64.h **** 
2183:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2184:lib_AT91SAM7S64.h **** //* \fn    AT91F_ADC_GetConvertedDataCH7
2185:lib_AT91SAM7S64.h **** //* \brief Return the Channel 7 Converted Data
2186:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2187:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_ADC_GetConvertedDataCH7 (
2188:lib_AT91SAM7S64.h **** 	AT91PS_ADC pADC // pointer to a ADC controller
2189:lib_AT91SAM7S64.h **** 	)
2190:lib_AT91SAM7S64.h **** {
2191:lib_AT91SAM7S64.h **** 	return pADC->ADC_CDR7;	
2192:lib_AT91SAM7S64.h **** }
2193:lib_AT91SAM7S64.h **** 
2194:lib_AT91SAM7S64.h **** /* *****************************************************************************
2195:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR SSC
2196:lib_AT91SAM7S64.h ****    ***************************************************************************** */
2197:lib_AT91SAM7S64.h **** //* Define the standard I2S mode configuration
2198:lib_AT91SAM7S64.h **** 
2199:lib_AT91SAM7S64.h **** //* Configuration to set in the SSC Transmit Clock Mode Register
2200:lib_AT91SAM7S64.h **** //* Parameters :  nb_bit_by_slot : 8, 16 or 32 bits
2201:lib_AT91SAM7S64.h **** //* 			  nb_slot_by_frame : number of channels
2202:lib_AT91SAM7S64.h **** #define AT91C_I2S_ASY_MASTER_TX_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
2203:lib_AT91SAM7S64.h **** 									   AT91C_SSC_CKS_DIV   +\
2204:lib_AT91SAM7S64.h ****                             		   AT91C_SSC_CKO_CONTINOUS      +\
2205:lib_AT91SAM7S64.h ****                             		   AT91C_SSC_CKG_NONE    +\
2206:lib_AT91SAM7S64.h ****                                        AT91C_SSC_START_FALL_RF +\
2207:lib_AT91SAM7S64.h ****                            			   AT91C_SSC_STTOUT  +\
2208:lib_AT91SAM7S64.h ****                             		   ((1<<16) & AT91C_SSC_STTDLY) +\
2209:lib_AT91SAM7S64.h ****                             		   ((((nb_bit_by_slot*nb_slot_by_frame)/2)-1) <<24))
2210:lib_AT91SAM7S64.h **** 
2211:lib_AT91SAM7S64.h **** 
2212:lib_AT91SAM7S64.h **** //* Configuration to set in the SSC Transmit Frame Mode Register
2213:lib_AT91SAM7S64.h **** //* Parameters : nb_bit_by_slot : 8, 16 or 32 bits
2214:lib_AT91SAM7S64.h **** //* 			 nb_slot_by_frame : number of channels
2215:lib_AT91SAM7S64.h **** #define AT91C_I2S_ASY_TX_FRAME_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
2216:lib_AT91SAM7S64.h **** 									(nb_bit_by_slot-1)  +\
2217:lib_AT91SAM7S64.h ****                             		AT91C_SSC_MSBF   +\
2218:lib_AT91SAM7S64.h ****                             		(((nb_slot_by_frame-1)<<8) & AT91C_SSC_DATNB)  +\
2219:lib_AT91SAM7S64.h ****                             		(((nb_bit_by_slot-1)<<16) & AT91C_SSC_FSLEN) +\
2220:lib_AT91SAM7S64.h ****                             		AT91C_SSC_FSOS_NEGATIVE)
2221:lib_AT91SAM7S64.h **** 
2222:lib_AT91SAM7S64.h **** 
2223:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2224:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_SetBaudrate
2225:lib_AT91SAM7S64.h **** //* \brief Set the baudrate according to the CPU clock
2226:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2227:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_SetBaudrate (
2228:lib_AT91SAM7S64.h ****         AT91PS_SSC pSSC,        // \arg pointer to a SSC controller
2229:lib_AT91SAM7S64.h ****         unsigned int mainClock, // \arg peripheral clock
2230:lib_AT91SAM7S64.h ****         unsigned int speed)     // \arg SSC baudrate
2231:lib_AT91SAM7S64.h **** {
2232:lib_AT91SAM7S64.h ****         unsigned int baud_value;
2233:lib_AT91SAM7S64.h ****         //* Define the baud rate divisor register
2234:lib_AT91SAM7S64.h ****         if (speed == 0)
2235:lib_AT91SAM7S64.h ****            baud_value = 0;
2236:lib_AT91SAM7S64.h ****         else
2237:lib_AT91SAM7S64.h ****         {
2238:lib_AT91SAM7S64.h ****            baud_value = (unsigned int) (mainClock * 10)/(2*speed);
2239:lib_AT91SAM7S64.h ****            if ((baud_value % 10) >= 5)
2240:lib_AT91SAM7S64.h ****                   baud_value = (baud_value / 10) + 1;
2241:lib_AT91SAM7S64.h ****            else
2242:lib_AT91SAM7S64.h ****                   baud_value /= 10;
2243:lib_AT91SAM7S64.h ****         }
2244:lib_AT91SAM7S64.h **** 
2245:lib_AT91SAM7S64.h ****         pSSC->SSC_CMR = baud_value;
2246:lib_AT91SAM7S64.h **** }
2247:lib_AT91SAM7S64.h **** 
2248:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2249:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_Configure
2250:lib_AT91SAM7S64.h **** //* \brief Configure SSC
2251:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2252:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_Configure (
2253:lib_AT91SAM7S64.h ****              AT91PS_SSC pSSC,          // \arg pointer to a SSC controller
2254:lib_AT91SAM7S64.h ****              unsigned int syst_clock,  // \arg System Clock Frequency
2255:lib_AT91SAM7S64.h ****              unsigned int baud_rate,   // \arg Expected Baud Rate Frequency
2256:lib_AT91SAM7S64.h ****              unsigned int clock_rx,    // \arg Receiver Clock Parameters
2257:lib_AT91SAM7S64.h ****              unsigned int mode_rx,     // \arg mode Register to be programmed
2258:lib_AT91SAM7S64.h ****              unsigned int clock_tx,    // \arg Transmitter Clock Parameters
2259:lib_AT91SAM7S64.h ****              unsigned int mode_tx)     // \arg mode Register to be programmed
2260:lib_AT91SAM7S64.h **** {
2261:lib_AT91SAM7S64.h ****     //* Disable interrupts
2262:lib_AT91SAM7S64.h **** 	pSSC->SSC_IDR = (unsigned int) -1;
2263:lib_AT91SAM7S64.h **** 
2264:lib_AT91SAM7S64.h ****     //* Reset receiver and transmitter
2265:lib_AT91SAM7S64.h **** 	pSSC->SSC_CR = AT91C_SSC_SWRST | AT91C_SSC_RXDIS | AT91C_SSC_TXDIS ;
2266:lib_AT91SAM7S64.h **** 
2267:lib_AT91SAM7S64.h ****     //* Define the Clock Mode Register
2268:lib_AT91SAM7S64.h **** 	AT91F_SSC_SetBaudrate(pSSC, syst_clock, baud_rate);
2269:lib_AT91SAM7S64.h **** 
2270:lib_AT91SAM7S64.h ****      //* Write the Receive Clock Mode Register
2271:lib_AT91SAM7S64.h **** 	pSSC->SSC_RCMR =  clock_rx;
2272:lib_AT91SAM7S64.h **** 
2273:lib_AT91SAM7S64.h ****      //* Write the Transmit Clock Mode Register
2274:lib_AT91SAM7S64.h **** 	pSSC->SSC_TCMR =  clock_tx;
2275:lib_AT91SAM7S64.h **** 
2276:lib_AT91SAM7S64.h ****      //* Write the Receive Frame Mode Register
2277:lib_AT91SAM7S64.h **** 	pSSC->SSC_RFMR =  mode_rx;
2278:lib_AT91SAM7S64.h **** 
2279:lib_AT91SAM7S64.h ****      //* Write the Transmit Frame Mode Register
2280:lib_AT91SAM7S64.h **** 	pSSC->SSC_TFMR =  mode_tx;
2281:lib_AT91SAM7S64.h **** 
2282:lib_AT91SAM7S64.h ****     //* Clear Transmit and Receive Counters
2283:lib_AT91SAM7S64.h **** 	AT91F_PDC_Open((AT91PS_PDC) &(pSSC->SSC_RPR));
2284:lib_AT91SAM7S64.h **** 
2285:lib_AT91SAM7S64.h **** 
2286:lib_AT91SAM7S64.h **** }
2287:lib_AT91SAM7S64.h **** 
2288:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2289:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_EnableRx
2290:lib_AT91SAM7S64.h **** //* \brief Enable receiving datas
2291:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2292:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_EnableRx (
2293:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
2294:lib_AT91SAM7S64.h **** {
2295:lib_AT91SAM7S64.h ****     //* Enable receiver
2296:lib_AT91SAM7S64.h ****     pSSC->SSC_CR = AT91C_SSC_RXEN;
2297:lib_AT91SAM7S64.h **** }
2298:lib_AT91SAM7S64.h **** 
2299:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2300:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_DisableRx
2301:lib_AT91SAM7S64.h **** //* \brief Disable receiving datas
2302:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2303:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_DisableRx (
2304:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
2305:lib_AT91SAM7S64.h **** {
2306:lib_AT91SAM7S64.h ****     //* Disable receiver
2307:lib_AT91SAM7S64.h ****     pSSC->SSC_CR = AT91C_SSC_RXDIS;
2308:lib_AT91SAM7S64.h **** }
2309:lib_AT91SAM7S64.h **** 
2310:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2311:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_EnableTx
2312:lib_AT91SAM7S64.h **** //* \brief Enable sending datas
2313:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2314:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_EnableTx (
2315:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
2316:lib_AT91SAM7S64.h **** {
2317:lib_AT91SAM7S64.h ****     //* Enable  transmitter
2318:lib_AT91SAM7S64.h ****     pSSC->SSC_CR = AT91C_SSC_TXEN;
2319:lib_AT91SAM7S64.h **** }
2320:lib_AT91SAM7S64.h **** 
2321:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2322:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_DisableTx
2323:lib_AT91SAM7S64.h **** //* \brief Disable sending datas
2324:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2325:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_DisableTx (
2326:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
2327:lib_AT91SAM7S64.h **** {
2328:lib_AT91SAM7S64.h ****     //* Disable  transmitter
2329:lib_AT91SAM7S64.h ****     pSSC->SSC_CR = AT91C_SSC_TXDIS;
2330:lib_AT91SAM7S64.h **** }
2331:lib_AT91SAM7S64.h **** 
2332:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2333:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_EnableIt
2334:lib_AT91SAM7S64.h **** //* \brief Enable SSC IT
2335:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2336:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_EnableIt (
2337:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
2338:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be enabled
2339:lib_AT91SAM7S64.h **** {
2340:lib_AT91SAM7S64.h **** 	//* Write to the IER register
2341:lib_AT91SAM7S64.h **** 	pSSC->SSC_IER = flag;
2342:lib_AT91SAM7S64.h **** }
2343:lib_AT91SAM7S64.h **** 
2344:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2345:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_DisableIt
2346:lib_AT91SAM7S64.h **** //* \brief Disable SSC IT
2347:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2348:lib_AT91SAM7S64.h **** __inline void AT91F_SSC_DisableIt (
2349:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
2350:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be disabled
2351:lib_AT91SAM7S64.h **** {
2352:lib_AT91SAM7S64.h **** 	//* Write to the IDR register
2353:lib_AT91SAM7S64.h **** 	pSSC->SSC_IDR = flag;
2354:lib_AT91SAM7S64.h **** }
2355:lib_AT91SAM7S64.h **** 
2356:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2357:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_ReceiveFrame
2358:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
2359:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2360:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SSC_ReceiveFrame (
2361:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC,
2362:lib_AT91SAM7S64.h **** 	char *pBuffer,
2363:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
2364:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
2365:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
2366:lib_AT91SAM7S64.h **** {
2367:lib_AT91SAM7S64.h **** 	return AT91F_PDC_ReceiveFrame(
2368:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pSSC->SSC_RPR),
2369:lib_AT91SAM7S64.h **** 		pBuffer,
2370:lib_AT91SAM7S64.h **** 		szBuffer,
2371:lib_AT91SAM7S64.h **** 		pNextBuffer,
2372:lib_AT91SAM7S64.h **** 		szNextBuffer);
2373:lib_AT91SAM7S64.h **** }
2374:lib_AT91SAM7S64.h **** 
2375:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2376:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_SendFrame
2377:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
2378:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2379:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SSC_SendFrame(
2380:lib_AT91SAM7S64.h **** 	AT91PS_SSC pSSC,
2381:lib_AT91SAM7S64.h **** 	char *pBuffer,
2382:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
2383:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
2384:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
2385:lib_AT91SAM7S64.h **** {
2386:lib_AT91SAM7S64.h **** 	return AT91F_PDC_SendFrame(
2387:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pSSC->SSC_RPR),
2388:lib_AT91SAM7S64.h **** 		pBuffer,
2389:lib_AT91SAM7S64.h **** 		szBuffer,
2390:lib_AT91SAM7S64.h **** 		pNextBuffer,
2391:lib_AT91SAM7S64.h **** 		szNextBuffer);
2392:lib_AT91SAM7S64.h **** }
2393:lib_AT91SAM7S64.h **** 
2394:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2395:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_GetInterruptMaskStatus
2396:lib_AT91SAM7S64.h **** //* \brief Return SSC Interrupt Mask Status
2397:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2398:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_SSC_GetInterruptMaskStatus( // \return SSC Interrupt Mask Status
2399:lib_AT91SAM7S64.h ****         AT91PS_SSC pSsc) // \arg  pointer to a SSC controller
2400:lib_AT91SAM7S64.h **** {
2401:lib_AT91SAM7S64.h ****         return pSsc->SSC_IMR;
2402:lib_AT91SAM7S64.h **** }
2403:lib_AT91SAM7S64.h **** 
2404:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2405:lib_AT91SAM7S64.h **** //* \fn    AT91F_SSC_IsInterruptMasked
2406:lib_AT91SAM7S64.h **** //* \brief Test if SSC Interrupt is Masked 
2407:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2408:lib_AT91SAM7S64.h **** __inline int AT91F_SSC_IsInterruptMasked(
2409:lib_AT91SAM7S64.h ****         AT91PS_SSC pSsc,   // \arg  pointer to a SSC controller
2410:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
2411:lib_AT91SAM7S64.h **** {
2412:lib_AT91SAM7S64.h ****         return (AT91F_SSC_GetInterruptMaskStatus(pSsc) & flag);
2413:lib_AT91SAM7S64.h **** }
2414:lib_AT91SAM7S64.h **** 
2415:lib_AT91SAM7S64.h **** /* *****************************************************************************
2416:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR USART
2417:lib_AT91SAM7S64.h ****    ***************************************************************************** */
2418:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2419:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_Baudrate
2420:lib_AT91SAM7S64.h **** //* \brief Calculate the baudrate
2421:lib_AT91SAM7S64.h **** //* Standard Asynchronous Mode : 8 bits , 1 stop , no parity
2422:lib_AT91SAM7S64.h **** #define AT91C_US_ASYNC_MODE ( AT91C_US_USMODE_NORMAL + \
2423:lib_AT91SAM7S64.h ****                         AT91C_US_NBSTOP_1_BIT + \
2424:lib_AT91SAM7S64.h ****                         AT91C_US_PAR_NONE + \
2425:lib_AT91SAM7S64.h ****                         AT91C_US_CHRL_8_BITS + \
2426:lib_AT91SAM7S64.h ****                         AT91C_US_CLKS_CLOCK )
2427:lib_AT91SAM7S64.h **** 
2428:lib_AT91SAM7S64.h **** //* Standard External Asynchronous Mode : 8 bits , 1 stop , no parity
2429:lib_AT91SAM7S64.h **** #define AT91C_US_ASYNC_SCK_MODE ( AT91C_US_USMODE_NORMAL + \
2430:lib_AT91SAM7S64.h ****                             AT91C_US_NBSTOP_1_BIT + \
2431:lib_AT91SAM7S64.h ****                             AT91C_US_PAR_NONE + \
2432:lib_AT91SAM7S64.h ****                             AT91C_US_CHRL_8_BITS + \
2433:lib_AT91SAM7S64.h ****                             AT91C_US_CLKS_EXT )
2434:lib_AT91SAM7S64.h **** 
2435:lib_AT91SAM7S64.h **** //* Standard Synchronous Mode : 8 bits , 1 stop , no parity
2436:lib_AT91SAM7S64.h **** #define AT91C_US_SYNC_MODE ( AT91C_US_SYNC + \
2437:lib_AT91SAM7S64.h ****                        AT91C_US_USMODE_NORMAL + \
2438:lib_AT91SAM7S64.h ****                        AT91C_US_NBSTOP_1_BIT + \
2439:lib_AT91SAM7S64.h ****                        AT91C_US_PAR_NONE + \
2440:lib_AT91SAM7S64.h ****                        AT91C_US_CHRL_8_BITS + \
2441:lib_AT91SAM7S64.h ****                        AT91C_US_CLKS_CLOCK )
2442:lib_AT91SAM7S64.h **** 
2443:lib_AT91SAM7S64.h **** //* SCK used Label
2444:lib_AT91SAM7S64.h **** #define AT91C_US_SCK_USED (AT91C_US_CKLO | AT91C_US_CLKS_EXT)
2445:lib_AT91SAM7S64.h **** 
2446:lib_AT91SAM7S64.h **** //* Standard ISO T=0 Mode : 8 bits , 1 stop , parity
2447:lib_AT91SAM7S64.h **** #define AT91C_US_ISO_READER_MODE ( AT91C_US_USMODE_ISO7816_0 + \
2448:lib_AT91SAM7S64.h **** 					   		 AT91C_US_CLKS_CLOCK +\
2449:lib_AT91SAM7S64.h ****                        		 AT91C_US_NBSTOP_1_BIT + \
2450:lib_AT91SAM7S64.h ****                        		 AT91C_US_PAR_EVEN + \
2451:lib_AT91SAM7S64.h ****                        		 AT91C_US_CHRL_8_BITS + \
2452:lib_AT91SAM7S64.h ****                        		 AT91C_US_CKLO +\
2453:lib_AT91SAM7S64.h ****                        		 AT91C_US_OVER)
2454:lib_AT91SAM7S64.h **** 
2455:lib_AT91SAM7S64.h **** //* Standard IRDA mode
2456:lib_AT91SAM7S64.h **** #define AT91C_US_ASYNC_IRDA_MODE (  AT91C_US_USMODE_IRDA + \
2457:lib_AT91SAM7S64.h ****                             AT91C_US_NBSTOP_1_BIT + \
2458:lib_AT91SAM7S64.h ****                             AT91C_US_PAR_NONE + \
2459:lib_AT91SAM7S64.h ****                             AT91C_US_CHRL_8_BITS + \
2460:lib_AT91SAM7S64.h ****                             AT91C_US_CLKS_CLOCK )
2461:lib_AT91SAM7S64.h **** 
2462:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2463:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_Baudrate
2464:lib_AT91SAM7S64.h **** //* \brief Caluculate baud_value according to the main clock and the baud rate
2465:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2466:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_Baudrate (
2467:lib_AT91SAM7S64.h **** 	const unsigned int main_clock, // \arg peripheral clock
2468:lib_AT91SAM7S64.h **** 	const unsigned int baud_rate)  // \arg UART baudrate
2469:lib_AT91SAM7S64.h **** {
2470:lib_AT91SAM7S64.h **** 	unsigned int baud_value = ((main_clock*10)/(baud_rate * 16));
2471:lib_AT91SAM7S64.h **** 	if ((baud_value % 10) >= 5)
2472:lib_AT91SAM7S64.h **** 		baud_value = (baud_value / 10) + 1;
2473:lib_AT91SAM7S64.h **** 	else
2474:lib_AT91SAM7S64.h **** 		baud_value /= 10;
2475:lib_AT91SAM7S64.h **** 	return baud_value;
2476:lib_AT91SAM7S64.h **** }
2477:lib_AT91SAM7S64.h **** 
2478:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2479:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_SetBaudrate
2480:lib_AT91SAM7S64.h **** //* \brief Set the baudrate according to the CPU clock
2481:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2482:lib_AT91SAM7S64.h **** __inline void AT91F_US_SetBaudrate (
2483:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,    // \arg pointer to a USART controller
2484:lib_AT91SAM7S64.h **** 	unsigned int mainClock, // \arg peripheral clock
2485:lib_AT91SAM7S64.h **** 	unsigned int speed)     // \arg UART baudrate
2486:lib_AT91SAM7S64.h **** {
2487:lib_AT91SAM7S64.h **** 	//* Define the baud rate divisor register
2488:lib_AT91SAM7S64.h **** 	pUSART->US_BRGR = AT91F_US_Baudrate(mainClock, speed);
2489:lib_AT91SAM7S64.h **** }
2490:lib_AT91SAM7S64.h **** 
2491:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2492:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_SetTimeguard
2493:lib_AT91SAM7S64.h **** //* \brief Set USART timeguard
2494:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2495:lib_AT91SAM7S64.h **** __inline void AT91F_US_SetTimeguard (
2496:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,    // \arg pointer to a USART controller
2497:lib_AT91SAM7S64.h **** 	unsigned int timeguard) // \arg timeguard value
2498:lib_AT91SAM7S64.h **** {
2499:lib_AT91SAM7S64.h **** 	//* Write the Timeguard Register
2500:lib_AT91SAM7S64.h **** 	pUSART->US_TTGR = timeguard ;
2501:lib_AT91SAM7S64.h **** }
2502:lib_AT91SAM7S64.h **** 
2503:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2504:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_EnableIt
2505:lib_AT91SAM7S64.h **** //* \brief Enable USART IT
2506:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2507:lib_AT91SAM7S64.h **** __inline void AT91F_US_EnableIt (
2508:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART, // \arg pointer to a USART controller
2509:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be enabled
2510:lib_AT91SAM7S64.h **** {
2511:lib_AT91SAM7S64.h **** 	//* Write to the IER register
2512:lib_AT91SAM7S64.h **** 	pUSART->US_IER = flag;
2513:lib_AT91SAM7S64.h **** }
2514:lib_AT91SAM7S64.h **** 
2515:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2516:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_DisableIt
2517:lib_AT91SAM7S64.h **** //* \brief Disable USART IT
2518:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2519:lib_AT91SAM7S64.h **** __inline void AT91F_US_DisableIt (
2520:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART, // \arg pointer to a USART controller
2521:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be disabled
2522:lib_AT91SAM7S64.h **** {
2523:lib_AT91SAM7S64.h **** 	//* Write to the IER register
2524:lib_AT91SAM7S64.h **** 	pUSART->US_IDR = flag;
2525:lib_AT91SAM7S64.h **** }
2526:lib_AT91SAM7S64.h **** 
2527:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2528:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_Configure
2529:lib_AT91SAM7S64.h **** //* \brief Configure USART
2530:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2531:lib_AT91SAM7S64.h **** __inline void AT91F_US_Configure (
2532:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,     // \arg pointer to a USART controller
2533:lib_AT91SAM7S64.h **** 	unsigned int mainClock,  // \arg peripheral clock
2534:lib_AT91SAM7S64.h **** 	unsigned int mode ,      // \arg mode Register to be programmed
2535:lib_AT91SAM7S64.h **** 	unsigned int baudRate ,  // \arg baudrate to be programmed
2536:lib_AT91SAM7S64.h **** 	unsigned int timeguard ) // \arg timeguard to be programmed
2537:lib_AT91SAM7S64.h **** {
2538:lib_AT91SAM7S64.h ****     //* Disable interrupts
2539:lib_AT91SAM7S64.h ****     pUSART->US_IDR = (unsigned int) -1;
2540:lib_AT91SAM7S64.h **** 
2541:lib_AT91SAM7S64.h ****     //* Reset receiver and transmitter
2542:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS | AT91C_US_TXDIS ;
2543:lib_AT91SAM7S64.h **** 
2544:lib_AT91SAM7S64.h **** 	//* Define the baud rate divisor register
2545:lib_AT91SAM7S64.h **** 	AT91F_US_SetBaudrate(pUSART, mainClock, baudRate);
2546:lib_AT91SAM7S64.h **** 
2547:lib_AT91SAM7S64.h **** 	//* Write the Timeguard Register
2548:lib_AT91SAM7S64.h **** 	AT91F_US_SetTimeguard(pUSART, timeguard);
2549:lib_AT91SAM7S64.h **** 
2550:lib_AT91SAM7S64.h ****     //* Clear Transmit and Receive Counters
2551:lib_AT91SAM7S64.h ****     AT91F_PDC_Open((AT91PS_PDC) &(pUSART->US_RPR));
2552:lib_AT91SAM7S64.h **** 
2553:lib_AT91SAM7S64.h ****     //* Define the USART mode
2554:lib_AT91SAM7S64.h ****     pUSART->US_MR = mode  ;
2555:lib_AT91SAM7S64.h **** 
2556:lib_AT91SAM7S64.h **** }
2557:lib_AT91SAM7S64.h **** 
2558:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2559:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_EnableRx
2560:lib_AT91SAM7S64.h **** //* \brief Enable receiving characters
2561:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2562:lib_AT91SAM7S64.h **** __inline void AT91F_US_EnableRx (
2563:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2564:lib_AT91SAM7S64.h **** {
2565:lib_AT91SAM7S64.h ****     //* Enable receiver
2566:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_RXEN;
2567:lib_AT91SAM7S64.h **** }
2568:lib_AT91SAM7S64.h **** 
2569:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2570:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_EnableTx
2571:lib_AT91SAM7S64.h **** //* \brief Enable sending characters
2572:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2573:lib_AT91SAM7S64.h **** __inline void AT91F_US_EnableTx (
2574:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2575:lib_AT91SAM7S64.h **** {
2576:lib_AT91SAM7S64.h ****     //* Enable  transmitter
2577:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_TXEN;
2578:lib_AT91SAM7S64.h **** }
2579:lib_AT91SAM7S64.h **** 
2580:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2581:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_ResetRx
2582:lib_AT91SAM7S64.h **** //* \brief Reset Receiver and re-enable it
2583:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2584:lib_AT91SAM7S64.h **** __inline void AT91F_US_ResetRx (
2585:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2586:lib_AT91SAM7S64.h **** {
2587:lib_AT91SAM7S64.h **** 	//* Reset receiver
2588:lib_AT91SAM7S64.h **** 	pUSART->US_CR = AT91C_US_RSTRX;
2589:lib_AT91SAM7S64.h ****     //* Re-Enable receiver
2590:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_RXEN;
2591:lib_AT91SAM7S64.h **** }
2592:lib_AT91SAM7S64.h **** 
2593:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2594:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_ResetTx
2595:lib_AT91SAM7S64.h **** //* \brief Reset Transmitter and re-enable it
2596:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2597:lib_AT91SAM7S64.h **** __inline void AT91F_US_ResetTx (
2598:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2599:lib_AT91SAM7S64.h **** {
2600:lib_AT91SAM7S64.h **** 	//* Reset transmitter
2601:lib_AT91SAM7S64.h **** 	pUSART->US_CR = AT91C_US_RSTTX;
2602:lib_AT91SAM7S64.h ****     //* Enable transmitter
2603:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_TXEN;
2604:lib_AT91SAM7S64.h **** }
2605:lib_AT91SAM7S64.h **** 
2606:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2607:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_DisableRx
2608:lib_AT91SAM7S64.h **** //* \brief Disable Receiver
2609:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2610:lib_AT91SAM7S64.h **** __inline void AT91F_US_DisableRx (
2611:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2612:lib_AT91SAM7S64.h **** {
2613:lib_AT91SAM7S64.h ****     //* Disable receiver
2614:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_RXDIS;
2615:lib_AT91SAM7S64.h **** }
2616:lib_AT91SAM7S64.h **** 
2617:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2618:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_DisableTx
2619:lib_AT91SAM7S64.h **** //* \brief Disable Transmitter
2620:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2621:lib_AT91SAM7S64.h **** __inline void AT91F_US_DisableTx (
2622:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2623:lib_AT91SAM7S64.h **** {
2624:lib_AT91SAM7S64.h ****     //* Disable transmitter
2625:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_TXDIS;
2626:lib_AT91SAM7S64.h **** }
2627:lib_AT91SAM7S64.h **** 
2628:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2629:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_Close
2630:lib_AT91SAM7S64.h **** //* \brief Close USART: disable IT disable receiver and transmitter, close PDC
2631:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2632:lib_AT91SAM7S64.h **** __inline void AT91F_US_Close (
2633:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART)     // \arg pointer to a USART controller
2634:lib_AT91SAM7S64.h **** {
2635:lib_AT91SAM7S64.h ****     //* Reset the baud rate divisor register
2636:lib_AT91SAM7S64.h ****     pUSART->US_BRGR = 0 ;
2637:lib_AT91SAM7S64.h **** 
2638:lib_AT91SAM7S64.h ****     //* Reset the USART mode
2639:lib_AT91SAM7S64.h ****     pUSART->US_MR = 0  ;
2640:lib_AT91SAM7S64.h **** 
2641:lib_AT91SAM7S64.h ****     //* Reset the Timeguard Register
2642:lib_AT91SAM7S64.h ****     pUSART->US_TTGR = 0;
2643:lib_AT91SAM7S64.h **** 
2644:lib_AT91SAM7S64.h ****     //* Disable all interrupts
2645:lib_AT91SAM7S64.h ****     pUSART->US_IDR = 0xFFFFFFFF ;
2646:lib_AT91SAM7S64.h **** 
2647:lib_AT91SAM7S64.h ****     //* Abort the Peripheral Data Transfers
2648:lib_AT91SAM7S64.h ****     AT91F_PDC_Close((AT91PS_PDC) &(pUSART->US_RPR));
2649:lib_AT91SAM7S64.h **** 
2650:lib_AT91SAM7S64.h ****     //* Disable receiver and transmitter and stop any activity immediately
2651:lib_AT91SAM7S64.h ****     pUSART->US_CR = AT91C_US_TXDIS | AT91C_US_RXDIS | AT91C_US_RSTTX | AT91C_US_RSTRX ;
2652:lib_AT91SAM7S64.h **** }
2653:lib_AT91SAM7S64.h **** 
2654:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2655:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_TxReady
2656:lib_AT91SAM7S64.h **** //* \brief Return 1 if a character can be written in US_THR
2657:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2658:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_TxReady (
2659:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
2660:lib_AT91SAM7S64.h **** {
2661:lib_AT91SAM7S64.h ****     return (pUSART->US_CSR & AT91C_US_TXRDY);
2662:lib_AT91SAM7S64.h **** }
2663:lib_AT91SAM7S64.h **** 
2664:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2665:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_RxReady
2666:lib_AT91SAM7S64.h **** //* \brief Return 1 if a character can be read in US_RHR
2667:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2668:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_RxReady (
2669:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
2670:lib_AT91SAM7S64.h **** {
2671:lib_AT91SAM7S64.h ****     return (pUSART->US_CSR & AT91C_US_RXRDY);
2672:lib_AT91SAM7S64.h **** }
2673:lib_AT91SAM7S64.h **** 
2674:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2675:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_Error
2676:lib_AT91SAM7S64.h **** //* \brief Return the error flag
2677:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2678:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_Error (
2679:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART )     // \arg pointer to a USART controller
2680:lib_AT91SAM7S64.h **** {
2681:lib_AT91SAM7S64.h ****     return (pUSART->US_CSR &
2682:lib_AT91SAM7S64.h ****     	(AT91C_US_OVRE |  // Overrun error
2683:lib_AT91SAM7S64.h ****     	 AT91C_US_FRAME | // Framing error
2684:lib_AT91SAM7S64.h ****     	 AT91C_US_PARE));  // Parity error
2685:lib_AT91SAM7S64.h **** }
2686:lib_AT91SAM7S64.h **** 
2687:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2688:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_PutChar
2689:lib_AT91SAM7S64.h **** //* \brief Send a character,does not check if ready to send
2690:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2691:lib_AT91SAM7S64.h **** __inline void AT91F_US_PutChar (
2692:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,
2693:lib_AT91SAM7S64.h **** 	int character )
2694:lib_AT91SAM7S64.h **** {
2695:lib_AT91SAM7S64.h ****     pUSART->US_THR = (character & 0x1FF);
2696:lib_AT91SAM7S64.h **** }
2697:lib_AT91SAM7S64.h **** 
2698:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2699:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_GetChar
2700:lib_AT91SAM7S64.h **** //* \brief Receive a character,does not check if a character is available
2701:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2702:lib_AT91SAM7S64.h **** __inline int AT91F_US_GetChar (
2703:lib_AT91SAM7S64.h **** 	const AT91PS_USART pUSART)
2704:lib_AT91SAM7S64.h **** {
2705:lib_AT91SAM7S64.h ****     return((pUSART->US_RHR) & 0x1FF);
2706:lib_AT91SAM7S64.h **** }
2707:lib_AT91SAM7S64.h **** 
2708:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2709:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_SendFrame
2710:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
2711:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2712:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_SendFrame(
2713:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,
2714:lib_AT91SAM7S64.h **** 	char *pBuffer,
2715:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
2716:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
2717:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
2718:lib_AT91SAM7S64.h **** {
2719:lib_AT91SAM7S64.h **** 	return AT91F_PDC_SendFrame(
2720:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pUSART->US_RPR),
2721:lib_AT91SAM7S64.h **** 		pBuffer,
2722:lib_AT91SAM7S64.h **** 		szBuffer,
2723:lib_AT91SAM7S64.h **** 		pNextBuffer,
2724:lib_AT91SAM7S64.h **** 		szNextBuffer);
2725:lib_AT91SAM7S64.h **** }
2726:lib_AT91SAM7S64.h **** 
2727:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2728:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_ReceiveFrame
2729:lib_AT91SAM7S64.h **** //* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been init
2730:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2731:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_US_ReceiveFrame (
2732:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,
2733:lib_AT91SAM7S64.h **** 	char *pBuffer,
2734:lib_AT91SAM7S64.h **** 	unsigned int szBuffer,
2735:lib_AT91SAM7S64.h **** 	char *pNextBuffer,
2736:lib_AT91SAM7S64.h **** 	unsigned int szNextBuffer )
2737:lib_AT91SAM7S64.h **** {
2738:lib_AT91SAM7S64.h **** 	return AT91F_PDC_ReceiveFrame(
2739:lib_AT91SAM7S64.h **** 		(AT91PS_PDC) &(pUSART->US_RPR),
2740:lib_AT91SAM7S64.h **** 		pBuffer,
2741:lib_AT91SAM7S64.h **** 		szBuffer,
2742:lib_AT91SAM7S64.h **** 		pNextBuffer,
2743:lib_AT91SAM7S64.h **** 		szNextBuffer);
2744:lib_AT91SAM7S64.h **** }
2745:lib_AT91SAM7S64.h **** 
2746:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2747:lib_AT91SAM7S64.h **** //* \fn    AT91F_US_SetIrdaFilter
2748:lib_AT91SAM7S64.h **** //* \brief Set the value of IrDa filter tregister
2749:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2750:lib_AT91SAM7S64.h **** __inline void AT91F_US_SetIrdaFilter (
2751:lib_AT91SAM7S64.h **** 	AT91PS_USART pUSART,
2752:lib_AT91SAM7S64.h **** 	unsigned char value
2753:lib_AT91SAM7S64.h **** )
2754:lib_AT91SAM7S64.h **** {
2755:lib_AT91SAM7S64.h **** 	pUSART->US_IF = value;
2756:lib_AT91SAM7S64.h **** }
2757:lib_AT91SAM7S64.h **** 
2758:lib_AT91SAM7S64.h **** /* *****************************************************************************
2759:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR TWI
2760:lib_AT91SAM7S64.h ****    ***************************************************************************** */
2761:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2762:lib_AT91SAM7S64.h **** //* \fn    AT91F_TWI_EnableIt
2763:lib_AT91SAM7S64.h **** //* \brief Enable TWI IT
2764:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2765:lib_AT91SAM7S64.h **** __inline void AT91F_TWI_EnableIt (
2766:lib_AT91SAM7S64.h **** 	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
2767:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be enabled
2768:lib_AT91SAM7S64.h **** {
2769:lib_AT91SAM7S64.h **** 	//* Write to the IER register
2770:lib_AT91SAM7S64.h **** 	pTWI->TWI_IER = flag;
2771:lib_AT91SAM7S64.h **** }
2772:lib_AT91SAM7S64.h **** 
2773:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2774:lib_AT91SAM7S64.h **** //* \fn    AT91F_TWI_DisableIt
2775:lib_AT91SAM7S64.h **** //* \brief Disable TWI IT
2776:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2777:lib_AT91SAM7S64.h **** __inline void AT91F_TWI_DisableIt (
2778:lib_AT91SAM7S64.h **** 	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
2779:lib_AT91SAM7S64.h **** 	unsigned int flag)   // \arg IT to be disabled
2780:lib_AT91SAM7S64.h **** {
2781:lib_AT91SAM7S64.h **** 	//* Write to the IDR register
2782:lib_AT91SAM7S64.h **** 	pTWI->TWI_IDR = flag;
2783:lib_AT91SAM7S64.h **** }
2784:lib_AT91SAM7S64.h **** 
2785:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2786:lib_AT91SAM7S64.h **** //* \fn    AT91F_TWI_Configure
2787:lib_AT91SAM7S64.h **** //* \brief Configure TWI in master mode
2788:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2789:lib_AT91SAM7S64.h **** __inline void AT91F_TWI_Configure ( AT91PS_TWI pTWI )          // \arg pointer to a TWI controller
2790:lib_AT91SAM7S64.h **** {
2791:lib_AT91SAM7S64.h ****     //* Disable interrupts
2792:lib_AT91SAM7S64.h **** 	pTWI->TWI_IDR = (unsigned int) -1;
2793:lib_AT91SAM7S64.h **** 
2794:lib_AT91SAM7S64.h ****     //* Reset peripheral
2795:lib_AT91SAM7S64.h **** 	pTWI->TWI_CR = AT91C_TWI_SWRST;
2796:lib_AT91SAM7S64.h **** 
2797:lib_AT91SAM7S64.h **** 	//* Set Master mode
2798:lib_AT91SAM7S64.h **** 	pTWI->TWI_CR = AT91C_TWI_MSEN;
2799:lib_AT91SAM7S64.h **** 
2800:lib_AT91SAM7S64.h **** }
2801:lib_AT91SAM7S64.h **** 
2802:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2803:lib_AT91SAM7S64.h **** //* \fn    AT91F_TWI_GetInterruptMaskStatus
2804:lib_AT91SAM7S64.h **** //* \brief Return TWI Interrupt Mask Status
2805:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2806:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_TWI_GetInterruptMaskStatus( // \return TWI Interrupt Mask Status
2807:lib_AT91SAM7S64.h ****         AT91PS_TWI pTwi) // \arg  pointer to a TWI controller
2808:lib_AT91SAM7S64.h **** {
2809:lib_AT91SAM7S64.h ****         return pTwi->TWI_IMR;
2810:lib_AT91SAM7S64.h **** }
2811:lib_AT91SAM7S64.h **** 
2812:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2813:lib_AT91SAM7S64.h **** //* \fn    AT91F_TWI_IsInterruptMasked
2814:lib_AT91SAM7S64.h **** //* \brief Test if TWI Interrupt is Masked 
2815:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2816:lib_AT91SAM7S64.h **** __inline int AT91F_TWI_IsInterruptMasked(
2817:lib_AT91SAM7S64.h ****         AT91PS_TWI pTwi,   // \arg  pointer to a TWI controller
2818:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
2819:lib_AT91SAM7S64.h **** {
2820:lib_AT91SAM7S64.h ****         return (AT91F_TWI_GetInterruptMaskStatus(pTwi) & flag);
2821:lib_AT91SAM7S64.h **** }
2822:lib_AT91SAM7S64.h **** 
2823:lib_AT91SAM7S64.h **** /* *****************************************************************************
2824:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR TC
2825:lib_AT91SAM7S64.h ****    ***************************************************************************** */
2826:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2827:lib_AT91SAM7S64.h **** //* \fn    AT91F_TC_InterruptEnable
2828:lib_AT91SAM7S64.h **** //* \brief Enable TC Interrupt
2829:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2830:lib_AT91SAM7S64.h **** __inline void AT91F_TC_InterruptEnable(
2831:lib_AT91SAM7S64.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2832:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  TC interrupt to be enabled
2833:lib_AT91SAM7S64.h **** {
2834:lib_AT91SAM7S64.h ****         pTc->TC_IER = flag;
2835:lib_AT91SAM7S64.h **** }
2836:lib_AT91SAM7S64.h **** 
2837:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2838:lib_AT91SAM7S64.h **** //* \fn    AT91F_TC_InterruptDisable
2839:lib_AT91SAM7S64.h **** //* \brief Disable TC Interrupt
2840:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2841:lib_AT91SAM7S64.h **** __inline void AT91F_TC_InterruptDisable(
2842:lib_AT91SAM7S64.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2843:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  TC interrupt to be disabled
2844:lib_AT91SAM7S64.h **** {
2845:lib_AT91SAM7S64.h ****         pTc->TC_IDR = flag;
2846:lib_AT91SAM7S64.h **** }
2847:lib_AT91SAM7S64.h **** 
2848:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2849:lib_AT91SAM7S64.h **** //* \fn    AT91F_TC_GetInterruptMaskStatus
2850:lib_AT91SAM7S64.h **** //* \brief Return TC Interrupt Mask Status
2851:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2852:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_TC_GetInterruptMaskStatus( // \return TC Interrupt Mask Status
2853:lib_AT91SAM7S64.h ****         AT91PS_TC pTc) // \arg  pointer to a TC controller
2854:lib_AT91SAM7S64.h **** {
2855:lib_AT91SAM7S64.h ****         return pTc->TC_IMR;
2856:lib_AT91SAM7S64.h **** }
2857:lib_AT91SAM7S64.h **** 
2858:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2859:lib_AT91SAM7S64.h **** //* \fn    AT91F_TC_IsInterruptMasked
2860:lib_AT91SAM7S64.h **** //* \brief Test if TC Interrupt is Masked 
2861:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2862:lib_AT91SAM7S64.h **** __inline int AT91F_TC_IsInterruptMasked(
2863:lib_AT91SAM7S64.h ****         AT91PS_TC pTc,   // \arg  pointer to a TC controller
2864:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
2865:lib_AT91SAM7S64.h **** {
2866:lib_AT91SAM7S64.h ****         return (AT91F_TC_GetInterruptMaskStatus(pTc) & flag);
2867:lib_AT91SAM7S64.h **** }
2868:lib_AT91SAM7S64.h **** 
2869:lib_AT91SAM7S64.h **** /* *****************************************************************************
2870:lib_AT91SAM7S64.h ****                 SOFTWARE API FOR PWMC
2871:lib_AT91SAM7S64.h ****    ***************************************************************************** */
2872:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2873:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_GetStatus
2874:lib_AT91SAM7S64.h **** //* \brief Return PWM Interrupt Status
2875:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2876:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PWMC_GetStatus( // \return PWM Interrupt Status
2877:lib_AT91SAM7S64.h **** 	AT91PS_PWMC pPWM) // pointer to a PWM controller
2878:lib_AT91SAM7S64.h **** {
2879:lib_AT91SAM7S64.h **** 	return pPWM->PWMC_SR;
2880:lib_AT91SAM7S64.h **** }
2881:lib_AT91SAM7S64.h **** 
2882:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2883:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_InterruptEnable
2884:lib_AT91SAM7S64.h **** //* \brief Enable PWM Interrupt
2885:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2886:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_InterruptEnable(
2887:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPwm,   // \arg  pointer to a PWM controller
2888:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  PWM interrupt to be enabled
2889:lib_AT91SAM7S64.h **** {
2890:lib_AT91SAM7S64.h ****         pPwm->PWMC_IER = flag;
2891:lib_AT91SAM7S64.h **** }
2892:lib_AT91SAM7S64.h **** 
2893:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2894:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_InterruptDisable
2895:lib_AT91SAM7S64.h **** //* \brief Disable PWM Interrupt
2896:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2897:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_InterruptDisable(
2898:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPwm,   // \arg  pointer to a PWM controller
2899:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  PWM interrupt to be disabled
2900:lib_AT91SAM7S64.h **** {
2901:lib_AT91SAM7S64.h ****         pPwm->PWMC_IDR = flag;
2902:lib_AT91SAM7S64.h **** }
2903:lib_AT91SAM7S64.h **** 
2904:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2905:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_GetInterruptMaskStatus
2906:lib_AT91SAM7S64.h **** //* \brief Return PWM Interrupt Mask Status
2907:lib_AT91SAM7S64.h **** 
2908:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2909:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PWMC_GetInterruptMaskStatus( // \return PWM Interrupt Mask Status
2910:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPwm) // \arg  pointer to a PWM controller
2911:lib_AT91SAM7S64.h **** {
2912:lib_AT91SAM7S64.h ****         return pPwm->PWMC_IMR;
2913:lib_AT91SAM7S64.h **** }
2914:lib_AT91SAM7S64.h **** 
2915:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2916:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_IsInterruptMasked
2917:lib_AT91SAM7S64.h **** //* \brief Test if PWM Interrupt is Masked
2918:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2919:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PWMC_IsInterruptMasked(
2920:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2921:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
2922:lib_AT91SAM7S64.h **** {
2923:lib_AT91SAM7S64.h **** 	return (AT91F_PWMC_GetInterruptMaskStatus(pPWM) & flag);
2924:lib_AT91SAM7S64.h **** }
2925:lib_AT91SAM7S64.h **** 
2926:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2927:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_IsStatusSet
2928:lib_AT91SAM7S64.h **** //* \brief Test if PWM Interrupt is Set
2929:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2930:lib_AT91SAM7S64.h **** __inline unsigned int AT91F_PWMC_IsStatusSet(
2931:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2932:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  flag to be tested
2933:lib_AT91SAM7S64.h **** {
2934:lib_AT91SAM7S64.h **** 	return (AT91F_PWMC_GetStatus(pPWM) & flag);
2935:lib_AT91SAM7S64.h **** }
2936:lib_AT91SAM7S64.h **** 
2937:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2938:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_CfgChannel
2939:lib_AT91SAM7S64.h **** //* \brief Test if PWM Interrupt is Set
2940:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2941:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_CfgChannel(
2942:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2943:lib_AT91SAM7S64.h ****         unsigned int channelId, // \arg PWM channel ID
2944:lib_AT91SAM7S64.h ****         unsigned int mode, // \arg  PWM mode
2945:lib_AT91SAM7S64.h ****         unsigned int period, // \arg PWM period
2946:lib_AT91SAM7S64.h ****         unsigned int duty) // \arg PWM duty cycle
2947:lib_AT91SAM7S64.h **** {
2948:lib_AT91SAM7S64.h **** 	pPWM->PWMC_CH[channelId].PWMC_CMR = mode;
2949:lib_AT91SAM7S64.h **** 	pPWM->PWMC_CH[channelId].PWMC_CDTYR = duty;
2950:lib_AT91SAM7S64.h **** 	pPWM->PWMC_CH[channelId].PWMC_CPRDR = period;
2951:lib_AT91SAM7S64.h **** }
2952:lib_AT91SAM7S64.h **** 
2953:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2954:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_StartChannel
2955:lib_AT91SAM7S64.h **** //* \brief Enable channel
2956:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2957:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_StartChannel(
2958:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2959:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  Channels IDs to be enabled
2960:lib_AT91SAM7S64.h **** {
2961:lib_AT91SAM7S64.h **** 	pPWM->PWMC_ENA = flag;
2962:lib_AT91SAM7S64.h **** }
2963:lib_AT91SAM7S64.h **** 
2964:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2965:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_StopChannel
2966:lib_AT91SAM7S64.h **** //* \brief Disable channel
2967:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2968:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_StopChannel(
2969:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2970:lib_AT91SAM7S64.h ****         unsigned int flag) // \arg  Channels IDs to be enabled
2971:lib_AT91SAM7S64.h **** {
2972:lib_AT91SAM7S64.h **** 	pPWM->PWMC_DIS = flag;
 802              		.loc 2 2972 0
 803 04ec 28209FE5 		ldr	r2, .L78
 804              	.LBE85:
 805              	.LBE84:
 806              	.LBB86:
 807              	.LBB87:
 808              		.loc 2 2948 0
 809 04f0 28309FE5 		ldr	r3, .L78+4
 810              	.LBE87:
 811              	.LBE86:
 812              	.LBB88:
 813              	.LBB89:
 814              		.loc 2 2972 0
 815 04f4 0110A0E3 		mov	r1, #1
 816 04f8 F71002E5 		str	r1, [r2, #-247]
 817              	.LBE89:
 818              	.LBE88:
 819              	.LBB90:
 820              	.LBB91:
 821              		.loc 2 2948 0
 822 04fc 013182E5 		str	r3, [r2, #257]
 823              		.loc 2 2950 0
 824 0500 1C309FE5 		ldr	r3, .L78+8
 825              		.loc 2 2949 0
 826 0504 050182E5 		str	r0, [r2, #261]
 827              		.loc 2 2950 0
 828 0508 093182E5 		str	r3, [r2, #265]
 829              	.LBE91:
 830              	.LBE90:
 831              	.LBB92:
 832              	.LBB93:
2973:lib_AT91SAM7S64.h **** }
2974:lib_AT91SAM7S64.h **** 
2975:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2976:lib_AT91SAM7S64.h **** //* \fn    AT91F_PWM_UpdateChannel
2977:lib_AT91SAM7S64.h **** //* \brief Update Period or Duty Cycle
2978:lib_AT91SAM7S64.h **** //*----------------------------------------------------------------------------
2979:lib_AT91SAM7S64.h **** __inline void AT91F_PWMC_UpdateChannel(
2980:lib_AT91SAM7S64.h ****         AT91PS_PWMC pPWM,   // \arg  pointer to a PWM controller
2981:lib_AT91SAM7S64.h ****         unsigned int channelId, // \arg PWM channel ID
2982:lib_AT91SAM7S64.h ****         unsigned int update) // \arg  Channels IDs to be enabled
2983:lib_AT91SAM7S64.h **** {
2984:lib_AT91SAM7S64.h **** 	pPWM->PWMC_CH[channelId].PWMC_CUPDR = update;
 833              		.loc 2 2984 0
 834 050c 0030A0E3 		mov	r3, #0
 835 0510 313182E5 		str	r3, [r2, #305]
 836              	.LBE93:
 837              	.LBE92:
 838              		.loc 1 202 0
 839              		@ lr needed for prologue
 840              	.LBB94:
 841              	.LBB95:
 842              		.loc 2 2961 0
 843 0514 FB1002E5 		str	r1, [r2, #-251]
 844              	.LBE95:
 845              	.LBE94:
 846              		.loc 1 207 0
 847 0518 1EFF2FE1 		bx	lr
 848              	.L79:
 849              		.align	2
 850              	.L78:
 851 051c FFC0FCFF 		.word	-212737
 852 0520 01020000 		.word	513
 853 0524 A0860100 		.word	100000
 854              	.LFE293:
 856              		.align	2
 857              		.global	lowerDown
 859              	lowerDown:
 860              	.LFB295:
 861              		.loc 1 218 0
 862              		@ args = 0, pretend = 0, frame = 0
 863              		@ frame_needed = 0, uses_anonymous_args = 0
 864              	.LVL19:
 865 0528 04E02DE5 		str	lr, [sp, #-4]!
 866              	.LCFI10:
 867              		.loc 1 219 0
 868 052c FEFFFFEB 		bl	setForce
 869              	.LVL20:
 870              		.loc 1 222 0
 871 0530 1C309FE5 		ldr	r3, .L82
 872 0534 0120A0E3 		mov	r2, #1
 873 0538 002083E5 		str	r2, [r3, #0]
 874              	.LBB100:
 875              	.LBB101:
 876              		.loc 2 609 0
 877 053c 0B1CE0E3 		mvn	r1, #2816
 878 0540 8030A0E3 		mov	r3, #128
 879 0544 CF3001E5 		str	r3, [r1, #-207]
 880              	.LBE101:
 881              	.LBE100:
 882              	.LBB102:
 883              	.LBB103:
 884              		.loc 2 620 0
 885 0548 4030A0E3 		mov	r3, #64
 886 054c CB3001E5 		str	r3, [r1, #-203]
 887              	.LBE103:
 888              	.LBE102:
 889              		.loc 1 223 0
 890 0550 04F09DE4 		ldr	pc, [sp], #4
 891              	.L83:
 892              		.align	2
 893              	.L82:
 894 0554 00000000 		.word	direction
 895              	.LFE295:
 897              		.align	2
 898              		.global	liftUp
 900              	liftUp:
 901              	.LFB294:
 902              		.loc 1 210 0
 903              		@ args = 0, pretend = 0, frame = 0
 904              		@ frame_needed = 0, uses_anonymous_args = 0
 905              	.LVL21:
 906 0558 04E02DE5 		str	lr, [sp, #-4]!
 907              	.LCFI11:
 908              		.loc 1 211 0
 909 055c FEFFFFEB 		bl	setForce
 910              	.LVL22:
 911              		.loc 1 214 0
 912 0560 1C309FE5 		ldr	r3, .L86
 913 0564 0020E0E3 		mvn	r2, #0
 914 0568 002083E5 		str	r2, [r3, #0]
 915              	.LBB108:
 916              	.LBB109:
 917              		.loc 2 609 0
 918 056c 0B1CE0E3 		mvn	r1, #2816
 919 0570 4030A0E3 		mov	r3, #64
 920 0574 CF3001E5 		str	r3, [r1, #-207]
 921              	.LBE109:
 922              	.LBE108:
 923              	.LBB110:
 924              	.LBB111:
 925              		.loc 2 620 0
 926 0578 033083E0 		add	r3, r3, r3
 927 057c CB3001E5 		str	r3, [r1, #-203]
 928              	.LBE111:
 929              	.LBE110:
 930              		.loc 1 215 0
 931 0580 04F09DE4 		ldr	pc, [sp], #4
 932              	.L87:
 933              		.align	2
 934              	.L86:
 935 0584 00000000 		.word	direction
 936              	.LFE294:
 938              		.align	2
 939              		.global	Init_PWM
 941              	Init_PWM:
 942              	.LFB286:
 943              		.loc 1 104 0
 944              		@ args = 0, pretend = 0, frame = 0
 945              		@ frame_needed = 0, uses_anonymous_args = 0
 946              	.LBB136:
 947              	.LBB137:
 948              		.loc 2 2901 0
 949 0588 74209FE5 		ldr	r2, .L90
 950 058c 0100A0E3 		mov	r0, #1
 951              	.LBE137:
 952              	.LBE136:
 953              	.LBB138:
 954              	.LBB139:
 955              		.loc 2 1044 0
 956 0590 03CCE0E3 		mvn	ip, #768
 957 0594 0430A0E3 		mov	r3, #4
 958              	.LBE139:
 959              	.LBE138:
 960              	.LBB140:
 961              	.LBB141:
 962              		.loc 2 2901 0
 963 0598 EB0002E5 		str	r0, [r2, #-235]
 964              	.LBE141:
 965              	.LBE140:
 966              	.LBB142:
 967              	.LBB143:
 968              		.loc 2 1044 0
 969 059c EF300CE5 		str	r3, [ip, #-239]
 970              	.LBE143:
 971              	.LBE142:
 972              	.LBB144:
 973              	.LBB145:
 974              	.LBB146:
 975              	.LBB147:
 976              		.loc 2 496 0
 977 05a0 60309FE5 		ldr	r3, .L90+4
 978              		.loc 2 495 0
 979 05a4 0B1CE0E3 		mvn	r1, #2816
 980 05a8 8F0001E5 		str	r0, [r1, #-143]
 981              		.loc 2 496 0
 982 05ac 8B3001E5 		str	r3, [r1, #-139]
 983              		.loc 2 497 0
 984 05b0 003083E0 		add	r3, r3, r0
 985 05b4 FB3001E5 		str	r3, [r1, #-251]
 986              	.LBE147:
 987              	.LBE146:
 988              	.LBE145:
 989              	.LBE144:
 990              	.LBB148:
 991              	.LBB149:
 992              	.LBB150:
 993              	.LBB151:
 994              		.loc 2 1044 0
 995 05b8 013BA0E3 		mov	r3, #1024
 996 05bc EF300CE5 		str	r3, [ip, #-239]
 997              	.LBE151:
 998              	.LBE150:
 999              	.LBE149:
 1000              	.LBE148:
 1001              	.LBB152:
 1002              	.LBB153:
 1003              		.loc 2 2948 0
 1004 05c0 44309FE5 		ldr	r3, .L90+8
 1005              	.LBE153:
 1006              	.LBE152:
 1007              		.loc 1 104 0
 1008 05c4 10402DE9 		stmfd	sp!, {r4, lr}
 1009              	.LCFI12:
 1010              	.LBB154:
 1011              	.LBB155:
 1012              		.loc 2 2972 0
 1013 05c8 F70002E5 		str	r0, [r2, #-247]
 1014              	.LBE155:
 1015              	.LBE154:
 1016              	.LBB156:
 1017              	.LBB157:
 1018              		.loc 2 2948 0
 1019 05cc 013182E5 		str	r3, [r2, #257]
 1020              		.loc 2 2949 0
 1021 05d0 38309FE5 		ldr	r3, .L90+12
 1022 05d4 053182E5 		str	r3, [r2, #261]
 1023              		.loc 2 2950 0
 1024 05d8 34309FE5 		ldr	r3, .L90+16
 1025              	.LBE157:
 1026              	.LBE156:
 1027              	.LBB158:
 1028              	.LBB159:
 1029              		.loc 2 2984 0
 1030 05dc 00E0A0E3 		mov	lr, #0
 1031              	.LBE159:
 1032              	.LBE158:
 1033              	.LBB160:
 1034              	.LBB161:
 1035              		.loc 2 496 0
 1036 05e0 0245A0E3 		mov	r4, #8388608
 1037              	.LBE161:
 1038              	.LBE160:
 1039              	.LBB162:
 1040              	.LBB163:
 1041              		.loc 2 2950 0
 1042 05e4 093182E5 		str	r3, [r2, #265]
 1043              	.LBE163:
 1044              	.LBE162:
 1045              	.LBB164:
 1046              	.LBB165:
 1047              		.loc 2 2984 0
 1048 05e8 31E182E5 		str	lr, [r2, #305]
 1049              	.LBE165:
 1050              	.LBE164:
 1051              	.LBB166:
 1052              	.LBB167:
 1053              		.loc 2 2972 0
 1054 05ec F70002E5 		str	r0, [r2, #-247]
 1055              	.LBE167:
 1056              	.LBE166:
 1057              	.LBB168:
 1058              	.LBB169:
 1059              		.loc 2 495 0
 1060 05f0 8FE001E5 		str	lr, [r1, #-143]
 1061              		.loc 2 496 0
 1062 05f4 8B4001E5 		str	r4, [r1, #-139]
 1063              		.loc 2 497 0
 1064 05f8 FB4001E5 		str	r4, [r1, #-251]
 1065              	.LBE169:
 1066              	.LBE168:
 1067              	.LBB170:
 1068              	.LBB171:
 1069              		.loc 2 2961 0
 1070 05fc FB0002E5 		str	r0, [r2, #-251]
 1071              	.LBE171:
 1072              	.LBE170:
 1073              		.loc 1 115 0
 1074 0600 1080BDE8 		ldmfd	sp!, {r4, pc}
 1075              	.L91:
 1076              		.align	2
 1077              	.L90:
 1078 0604 FFC0FCFF 		.word	-212737
 1079 0608 00088000 		.word	8390656
 1080 060c 01020000 		.word	513
 1081 0610 D0010100 		.word	66000
 1082 0614 A0860100 		.word	100000
 1083              	.LFE286:
 1085              		.global	__divsi3
 1086              		.global	__floatsidf
 1087              		.global	__fixdfsi
 1088              		.section	.rodata.str1.4
 1089 00ca 0000     		.align	2
 1090              	.LC18:
 1091 00cc 256400   		.ascii	"%d\000"
 1092 00cf 00       		.align	2
 1093              	.LC19:
 1094 00d0 25640A00 		.ascii	"%d\012\000"
 1095              		.align	2
 1096              	.LC17:
 1097 00d4 7E00     		.ascii	"~\000"
 1098 00d6 0000     		.text
 1099              		.align	2
 1100              		.global	main
 1102              	main:
 1103              	.LFB302:
 627:load_cell.c   **** 
 628:load_cell.c   **** 
 629:load_cell.c   **** //*--------------------------------------------------------------------------------------
 630:load_cell.c   **** //* Function Name       : Main
 631:load_cell.c   **** //* Object              : Software entry point
 632:load_cell.c   **** //* Input Parameters    : none.
 633:load_cell.c   **** //* Output Parameters   : none.
 634:load_cell.c   **** //*--------------------------------------------------------------------------------------
 635:load_cell.c   **** int main(void)
 636:load_cell.c   **** {
 1104              		.loc 1 636 0
 1105              		@ args = 0, pretend = 0, frame = 1220
 1106              		@ frame_needed = 0, uses_anonymous_args = 0
 1107 0618 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1108              	.LCFI13:
 1109 061c 13DD4DE2 		sub	sp, sp, #1216
 1110              	.LCFI14:
 1111 0620 04D04DE2 		sub	sp, sp, #4
 1112              	.LCFI15:
 637:load_cell.c   ****     char data[MSG_SIZE];
 638:load_cell.c   ****     unsigned int length;
 639:load_cell.c   ****     int stepCnt = 0;
 640:load_cell.c   ****     unsigned char str[10];
 641:load_cell.c   **** 
 642:load_cell.c   ****     /**** System init ****/
 643:load_cell.c   ****     //InitFrec();
 644:load_cell.c   ****     Init_CP_WP();
 1113              		.loc 1 644 0
 1114 0624 FEFFFFEB 		bl	Init_CP_WP
 1115              	.L93:
 645:load_cell.c   ****     //chek for CP and WP
 646:load_cell.c   ****     //CP - card present
 647:load_cell.c   ****     while(((AT91C_BASE_PIOA->PIO_PDSR) & BIT15)) { /*put your card present event here*/  }
 1116              		.loc 1 647 0
 1117 0628 0B6CE0E3 		mvn	r6, #2816
 1118 062c C33016E5 		ldr	r3, [r6, #-195]
 1119 0630 027913E2 		ands	r7, r3, #32768
 1120 0634 8801001A 		bne	.L93
 648:load_cell.c   ****     //WP - write protect
 649:load_cell.c   ****     //while(((AT91C_BASE_PIOA->PIO_PDSR) & BIT16)) { /*put your write protect event here*/ }
 650:load_cell.c   **** 
 651:load_cell.c   ****     if (initMMC() == MMC_SUCCESS)
 1121              		.loc 1 651 0
 1122 0638 FEFFFFEB 		bl	initMMC
 1123 063c 005050E2 		subs	r5, r0, #0
 1124 0640 9801001A 		bne	.L95
 652:load_cell.c   ****     {
 653:load_cell.c   ****         //card_state |= 1;
 654:load_cell.c   ****         memset(&mmc_buffer,0,512);
 1125              		.loc 1 654 0
 1126 0644 C8439FE5 		ldr	r4, .L144
 1127 0648 0510A0E1 		mov	r1, r5
 1128 064c 022CA0E3 		mov	r2, #512
 1129 0650 0400A0E1 		mov	r0, r4
 1130 0654 FEFFFFEB 		bl	memset
 655:load_cell.c   ****         mmcReadRegister (10, 16);
 1131              		.loc 1 655 0
 1132 0658 0A00A0E3 		mov	r0, #10
 1133 065c 1010A0E3 		mov	r1, #16
 1134 0660 FEFFFFEB 		bl	mmcReadRegister
 656:load_cell.c   ****         mmc_buffer[7]=0;
 1135              		.loc 1 656 0
 1136 0664 0750C4E5 		strb	r5, [r4, #7]
 1137              	.L95:
 1138              	.LBB200:
 1139              	.LBB201:
 1140              		.loc 1 94 0
 1141 0668 FF30E0E3 		mvn	r3, #255
 1142 066c BC348DE5 		str	r3, [sp, #1212]
 1143              	.LVL23:
 1144              		.loc 1 97 0
 1145 0670 BC249DE5 		ldr	r2, [sp, #1212]
 1146 0674 9C339FE5 		ldr	r3, .L144+4
 1147 0678 603082E5 		str	r3, [r2, #96]
 1148              	.LBE201:
 1149              	.LBE200:
 657:load_cell.c   ****     }
 658:load_cell.c   **** 
 659:load_cell.c   **** 
 660:load_cell.c   ****     flashInit();
 661:load_cell.c   **** 
 662:load_cell.c   ****     Init_PWM();
 1150              		.loc 1 662 0
 1151 067c FEFFFFEB 		bl	Init_PWM
 663:load_cell.c   **** 
 664:load_cell.c   ****     // Enable User Reset and set its minimal assertion to 960 us
 665:load_cell.c   ****     AT91C_BASE_RSTC->RSTC_RMR = AT91C_RSTC_URSTEN | (0x4<<8) | (unsigned int)(0xA5<<24);
 1152              		.loc 1 665 0
 1153 0680 94239FE5 		ldr	r2, .L144+8
 1154              	.LBB202:
 1155              	.LBB203:
 1156              		.loc 2 508 0
 1157 0684 94439FE5 		ldr	r4, .L144+12
 1158              	.LBE203:
 1159              	.LBE202:
 1160              		.loc 1 665 0
 1161 0688 023CE0E3 		mvn	r3, #512
 1162 068c F72003E5 		str	r2, [r3, #-247]
 1163              	.LBB204:
 1164              	.LBB205:
 1165              		.loc 2 1044 0
 1166 0690 0420A0E3 		mov	r2, #4
 1167 0694 033CE0E3 		mvn	r3, #768
 1168 0698 EF2003E5 		str	r2, [r3, #-239]
 1169              	.LBE205:
 1170              	.LBE204:
 1171              	.LBB206:
 1172              	.LBB207:
 1173              		.loc 2 508 0
 1174 069c FF4006E5 		str	r4, [r6, #-255]
 1175              		.loc 2 509 0
 1176 06a0 EF4006E5 		str	r4, [r6, #-239]
 1177              	.LBE207:
 1178              	.LBE206:
 666:load_cell.c   ****     // Led init
 667:load_cell.c   ****     // First, enable the clock of the PIOB
 668:load_cell.c   ****     AT91F_PMC_EnablePeriphClock ( AT91C_BASE_PMC, 1 << AT91C_ID_PIOA ) ;
 669:load_cell.c   ****     //* to be outputs. No need to set these pins to be driven by the PIO because it is GPIO pins on
 670:load_cell.c   ****     AT91F_PIO_CfgOutput( AT91C_BASE_PIOA, OUTPUT_MASK );
 671:load_cell.c   ****     //* Clear the LED's.
 672:load_cell.c   ****     /*
 673:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, OUTPUT_MASK );
 674:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, OUTPUT_MASK );
 675:load_cell.c   ****     */
 676:load_cell.c   **** 
 677:load_cell.c   **** 
 678:load_cell.c   ****     // Init USB device
 679:load_cell.c   ****     AT91F_USB_Open();
 1179              		.loc 1 679 0
 1180 06a4 FEFFFFEB 		bl	AT91F_USB_Open
 1181              	.LBB208:
 1182              	.LBB209:
 1183              		.loc 2 620 0
 1184 06a8 CB4006E5 		str	r4, [r6, #-203]
 1185              	.LBE209:
 1186              	.LBE208:
 680:load_cell.c   ****     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, OUTPUT_MASK );
 681:load_cell.c   ****     // Init USB device
 682:load_cell.c   ****     // Wait for the end of enumeration
 683:load_cell.c   ****     setForce(40000);
 1187              		.loc 1 683 0
 1188 06ac 70039FE5 		ldr	r0, .L144+16
 1189 06b0 FEFFFFEB 		bl	setForce
 1190 06b4 0740A0E1 		mov	r4, r7
 1191              	.LVL24:
 1192 06b8 AE0100EA 		b	.L97
 1193              	.L98:
 684:load_cell.c   ****     int pCDCEnablingCounter = 0;
 685:load_cell.c   ****     while (!pCDC.IsConfigured(&pCDC) && pCDCEnablingCounter < 2500000){ pCDCEnablingCounter++; };
 1194              		.loc 1 685 0
 1195 06bc 014084E2 		add	r4, r4, #1
 1196              	.L97:
 1197 06c0 60339FE5 		ldr	r3, .L144+20
 1198 06c4 0300A0E1 		mov	r0, r3
 1199 06c8 0FE0A0E1 		mov	lr, pc
 1200 06cc 0CF093E5 		ldr	pc, [r3, #12]
 1201 06d0 000050E3 		cmp	r0, #0
 1202 06d4 B801001A 		bne	.L99
 1203 06d8 4C339FE5 		ldr	r3, .L144+24
 1204 06dc 030054E1 		cmp	r4, r3
 1205 06e0 AD01001A 		bne	.L98
 1206 06e4 BD0100EA 		b	.L101
 1207              	.L99:
 686:load_cell.c   **** 
 687:load_cell.c   ****     if (pCDCEnablingCounter < 2500000)
 1208              		.loc 1 687 0
 1209 06e8 40339FE5 		ldr	r3, .L144+28
 1210 06ec 030054E1 		cmp	r4, r3
 688:load_cell.c   ****     {
 689:load_cell.c   ****         CDC = 1;
 1211              		.loc 1 689 0
 1212 06f0 3C339FD5 		ldrle	r3, .L144+32
 1213 06f4 0120A0D3 		movle	r2, #1
 1214 06f8 0020C3D5 		strleb	r2, [r3, #0]
 1215              	.L101:
 690:load_cell.c   ****     }
 691:load_cell.c   **** 
 692:load_cell.c   ****     setForce(0);
 1216              		.loc 1 692 0
 1217 06fc 0000A0E3 		mov	r0, #0
 1218 0700 FEFFFFEB 		bl	setForce
 693:load_cell.c   **** 
 694:load_cell.c   ****     // Set Usart in interrupt
 695:load_cell.c   ****     //Usart_init();
 696:load_cell.c   **** 
 697:load_cell.c   ****     //Read and set settings
 698:load_cell.c   ****     memcpy(settings, OUR_FLASH_ADDR, 128);
 1219              		.loc 1 698 0
 1220 0704 2C139FE5 		ldr	r1, .L144+36
 1221 0708 8020A0E3 		mov	r2, #128
 1222 070c 28039FE5 		ldr	r0, .L144+40
 1223 0710 FEFFFFEB 		bl	memcpy
 699:load_cell.c   ****     int i;memset(&mmc_buffer, 0x00, 512);
 1224              		.loc 1 699 0
 1225 0714 022CA0E3 		mov	r2, #512
 1226 0718 0010A0E3 		mov	r1, #0
 1227 071c F0029FE5 		ldr	r0, .L144
 1228 0720 FEFFFFEB 		bl	memset
 700:load_cell.c   ****     int j;
 701:load_cell.c   ****     char *settingsBlocks[50];
 702:load_cell.c   ****     char settingsDelim[] = "~";
 1229              		.loc 1 702 0
 1230 0724 14339FE5 		ldr	r3, .L144+44
 1231 0728 131D8DE2 		add	r1, sp, #1216
 1232 072c B030D3E1 		ldrh	r3, [r3, #0]
 1233 0730 041081E2 		add	r1, r1, #4
 1234 0734 B23061E1 		strh	r3, [r1, #-2]!	@ movhi
 703:load_cell.c   ****     char *settingsParts = strtok( settings, settingsDelim );
 1235              		.loc 1 703 0
 1236 0738 FC029FE5 		ldr	r0, .L144+40
 1237 073c FEFFFFEB 		bl	strtok
 1238 0740 0050A0E3 		mov	r5, #0
 1239              	.LVL25:
 1240 0744 0020A0E1 		mov	r2, r0
 1241              	.LVL26:
 1242 0748 D60100EA 		b	.L103
 1243              	.L104:
 704:load_cell.c   ****     i = 0;
 705:load_cell.c   ****     while( settingsParts != NULL )
 706:load_cell.c   ****     {
 707:load_cell.c   ****       settingsBlocks[i++] = settingsParts;
 1244              		.loc 1 707 0
 1245 074c FA3F8DE2 		add	r3, sp, #1000
 1246 0750 052183E7 		str	r2, [r3, r5, asl #2]
 708:load_cell.c   ****       settingsParts = strtok( NULL, settingsDelim );
 1247              		.loc 1 708 0
 1248 0754 FEFFFFEB 		bl	strtok
 1249              	.LVL27:
 1250              		.loc 1 707 0
 1251 0758 015085E2 		add	r5, r5, #1
 1252              		.loc 1 708 0
 1253 075c 0020A0E1 		mov	r2, r0
 1254              	.LVL28:
 1255              	.L103:
 1256 0760 0000A0E3 		mov	r0, #0
 1257 0764 131D8DE2 		add	r1, sp, #1216
 1258              		.loc 1 705 0
 1259 0768 000052E1 		cmp	r2, r0
 1260              		.loc 1 708 0
 1261 076c 021081E2 		add	r1, r1, #2
 1262              		.loc 1 705 0
 1263 0770 D101001A 		bne	.L104
 1264 0774 0240A0E1 		mov	r4, r2
 1265              	.LVL29:
 1266 0778 E10100EA 		b	.L106
 1267              	.L107:
 709:load_cell.c   ****     }
 710:load_cell.c   ****     for (j = 0; j < i; j++)
 711:load_cell.c   ****     {
 712:load_cell.c   ****        parseSettings(settingsBlocks[j]);
 1268              		.loc 1 712 0
 1269 077c FA3F8DE2 		add	r3, sp, #1000
 1270 0780 040193E7 		ldr	r0, [r3, r4, asl #2]
 1271 0784 FEFFFFEB 		bl	parseSettings
 1272              	.LVL30:
 1273              		.loc 1 710 0
 1274 0788 014084E2 		add	r4, r4, #1
 1275              	.LVL31:
 1276              	.L106:
 1277 078c 050054E1 		cmp	r4, r5
 1278 0790 DD0100BA 		blt	.L107
 713:load_cell.c   ****     }
 714:load_cell.c   **** 
 715:load_cell.c   ****     InitADC();
 1279              		.loc 1 715 0
 1280 0794 FEFFFFEB 		bl	InitADC
 1281              	.LVL32:
 716:load_cell.c   **** 
 717:load_cell.c   ****     Init_PWM();
 1282              		.loc 1 717 0
 1283 0798 FEFFFFEB 		bl	Init_PWM
 1284              	.LBB210:
 1285              	.LBB211:
 1286              		.loc 2 521 0
 1287 079c 0B2CE0E3 		mvn	r2, #2816
 1288 07a0 0237A0E3 		mov	r3, #524288
 1289 07a4 EB3002E5 		str	r3, [r2, #-235]
 1290              		.loc 2 522 0
 1291 07a8 FF3002E5 		str	r3, [r2, #-255]
 1292              	.LBE211:
 1293              	.LBE210:
 1294              	.LBB212:
 1295              	.LBB213:
 1296              		.loc 2 609 0
 1297 07ac 013743E2 		sub	r3, r3, #262144
 1298 07b0 CF3002E5 		str	r3, [r2, #-207]
 1299              	.LBE213:
 1300              	.LBE212:
 1301              	.LBB214:
 1302              	.LBB215:
 1303 07b4 023843E2 		sub	r3, r3, #131072
 1304              	.LBE215:
 1305              	.LBE214:
 718:load_cell.c   **** 
 719:load_cell.c   ****     AT91F_PIO_CfgInput(AT91C_BASE_PIOA, SW1_MASK);
 720:load_cell.c   **** 
 721:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED_GREEN);
 722:load_cell.c   ****     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED_YELLOW);
 723:load_cell.c   ****     setForce(0);
 1306              		.loc 1 723 0
 1307 07b8 0000A0E3 		mov	r0, #0
 1308              	.LBB216:
 1309              	.LBB217:
 1310              		.loc 2 609 0
 1311 07bc CF3002E5 		str	r3, [r2, #-207]
 1312              	.LBE217:
 1313              	.LBE216:
 1314              		.loc 1 723 0
 1315 07c0 FEFFFFEB 		bl	setForce
 1316              	.LVL33:
 1317              	.L143:
 724:load_cell.c   **** 
 725:load_cell.c   ****     //startBlinking(250000);
 726:load_cell.c   **** 
 727:load_cell.c   ****     /**** MMC CARD ****/
 728:load_cell.c   **** 
 729:load_cell.c   **** 
 730:load_cell.c   **** 
 731:load_cell.c   **** 
 732:load_cell.c   ****     while (1)
 733:load_cell.c   ****     {
 734:load_cell.c   ****         pressure = (int)GetValue_chanel6();
 1318              		.loc 1 734 0
 1319 07c4 FEFFFFEB 		bl	GetValue_chanel6
 1320 07c8 74429FE5 		ldr	r4, .L144+48
 1321              	.LVL34:
 1322 07cc 000084E5 		str	r0, [r4, #0]
 735:load_cell.c   ****         position = (int)GetValue_chanel5();
 1323              		.loc 1 735 0
 1324 07d0 FEFFFFEB 		bl	GetValue_chanel5
 1325              	.LBB218:
 1326              	.LBB219:
 1327              		.loc 2 586 0
 1328 07d4 0B5CE0E3 		mvn	r5, #2816
 1329              	.LVL35:
 1330 07d8 C33015E5 		ldr	r3, [r5, #-195]
 1331              	.LBE219:
 1332              	.LBE218:
 736:load_cell.c   **** 
 737:load_cell.c   **** /*
 738:load_cell.c   ****         if (aatDiag == 0)
 739:load_cell.c   ****         {
 740:load_cell.c   ****             setPosition(curForce);
 741:load_cell.c   ****         }
 742:load_cell.c   ****         else
 743:load_cell.c   ****         {
 744:load_cell.c   ****             switch (aatDiagStep)
 745:load_cell.c   ****             {
 746:load_cell.c   ****             case 0:
 747:load_cell.c   ****                 for (i = 0; i < 5; i++)
 748:load_cell.c   ****                 {
 749:load_cell.c   ****                     startBlinking(50000);
 750:load_cell.c   ****                 }
 751:load_cell.c   ****                 curPos = maxPos;
 752:load_cell.c   ****                 aatDiagStep = 1;
 753:load_cell.c   ****                 break;
 754:load_cell.c   ****             case 1:
 755:load_cell.c   ****                 if (abs(curPos - position) > 5)
 756:load_cell.c   ****                 {
 757:load_cell.c   ****                     if (curPos > position)
 758:load_cell.c   ****                     {
 759:load_cell.c   ****                         lowerDown(85000);
 760:load_cell.c   ****                     }
 761:load_cell.c   ****                     if (curPos < position)
 762:load_cell.c   ****                     {
 763:load_cell.c   ****                         liftUp(85000);
 764:load_cell.c   ****                     }
 765:load_cell.c   ****                 }
 766:load_cell.c   ****                 else
 767:load_cell.c   ****                 {
 768:load_cell.c   ****                     releasePosition();
 769:load_cell.c   ****                     for (i = 0; i < 5; i++)
 770:load_cell.c   ****                     {
 771:load_cell.c   ****                         startBlinking(50000);
 772:load_cell.c   ****                     }
 773:load_cell.c   ****                     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED1);
 774:load_cell.c   ****                     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED2);
 775:load_cell.c   ****                     AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED3);
 776:load_cell.c   ****                     AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED2);
 777:load_cell.c   ****                     aatDiagStep = 2;
 778:load_cell.c   ****                 }
 779:load_cell.c   ****                 break;
 780:load_cell.c   ****             case 2:
 781:load_cell.c   ****                 if (pressure < 25 && position > minPos)
 782:load_cell.c   ****                 {
 783:load_cell.c   ****                     liftUp(minDiagForce);
 784:load_cell.c   ****                 }
 785:load_cell.c   ****                 else
 786:load_cell.c   ****                 {
 787:load_cell.c   ****                     if (pressure < 25)
 788:load_cell.c   ****                     {
 789:load_cell.c   ****                         curPos = maxPos;
 790:load_cell.c   ****                         Delay(100000);
 791:load_cell.c   ****                         printTrace("DIAG#2#FAILED\r\n");
 792:load_cell.c   ****                         aatDiag = 0;
 793:load_cell.c   ****                     }
 794:load_cell.c   ****                     else
 795:load_cell.c   ****                     {
 796:load_cell.c   ****                         Delay(100000);
 797:load_cell.c   ****                         printTrace("DIAG#2#DONE\r\n");
 798:load_cell.c   ****                         aatDiagStep = 3;
 799:load_cell.c   ****                         diagForce = minDiagForce;
 800:load_cell.c   ****                     }
 801:load_cell.c   ****                     //releasePosition();
 802:load_cell.c   ****                 }
 803:load_cell.c   ****                 break;
 804:load_cell.c   ****             case 3:
 805:load_cell.c   ****                 if (pressure < lockDiagPressure && position > minPos)
 806:load_cell.c   ****                 {
 807:load_cell.c   ****                     if (diagForce < lockDiagForce)
 808:load_cell.c   ****                     {
 809:load_cell.c   ****                         diagForce += 100;
 810:load_cell.c   ****                     }
 811:load_cell.c   ****                     liftUp(diagForce);
 812:load_cell.c   ****                 }
 813:load_cell.c   ****                 else
 814:load_cell.c   ****                 {
 815:load_cell.c   ****                     if (position < minPos)
 816:load_cell.c   ****                     {
 817:load_cell.c   ****                         Delay(100000);
 818:load_cell.c   ****                         printTrace("DIAG#3#FAILED\r\n");
 819:load_cell.c   ****                         aatDiag = 0;
 820:load_cell.c   ****                     }
 821:load_cell.c   ****                     if (pressure >= lockDiagPressure)
 822:load_cell.c   ****                     {
 823:load_cell.c   ****                         Delay(100000);
 824:load_cell.c   ****                         printTrace("DIAG#3#DONE\r\n");
 825:load_cell.c   ****                         aatDiagStep = 4;
 826:load_cell.c   ****                         diagForce = maxForce;
 827:load_cell.c   ****                     }
 828:load_cell.c   ****                 }
 829:load_cell.c   ****                 break;
 830:load_cell.c   ****             case 4:
 831:load_cell.c   ****                 if (position < minPos)
 832:load_cell.c   ****                 {
 833:load_cell.c   ****                     printTrace("DIAG#4#FAILED\r\n");
 834:load_cell.c   ****                     aatDiag = 0;
 835:load_cell.c   ****                 }
 836:load_cell.c   ****                 else
 837:load_cell.c   ****                 {
 838:load_cell.c   ****                     liftUp(diagForce);
 839:load_cell.c   ****                 }
 840:load_cell.c   ****                 break;
 841:load_cell.c   ****             }
 842:load_cell.c   ****         }
 843:load_cell.c   **** */
 844:load_cell.c   **** 
 845:load_cell.c   ****         if ( (AT91F_PIO_GetInput(AT91C_BASE_PIOA) & SW1_MASK) == 0 )
 1333              		.loc 1 845 0
 1334 07dc 022713E2 		ands	r2, r3, #524288
 1335              		.loc 1 735 0
 1336 07e0 60329FE5 		ldr	r3, .L144+52
 1337 07e4 000083E5 		str	r0, [r3, #0]
 1338              		.loc 1 845 0
 1339 07e8 0102001A 		bne	.L110
 846:load_cell.c   ****         {
 847:load_cell.c   ****             test_read = 0;
 1340              		.loc 1 847 0
 1341 07ec 58329FE5 		ldr	r3, .L144+56
 1342 07f0 002083E5 		str	r2, [r3, #0]
 848:load_cell.c   ****             storingOnMMC = 1;
 1343              		.loc 1 848 0
 1344 07f4 54329FE5 		ldr	r3, .L144+60
 1345 07f8 0120A0E3 		mov	r2, #1
 849:load_cell.c   ****             set_zero = pressure;
 1346              		.loc 1 849 0
 1347 07fc 001094E5 		ldr	r1, [r4, #0]
 1348              		.loc 1 848 0
 1349 0800 0020C3E5 		strb	r2, [r3, #0]
 1350              		.loc 1 849 0
 1351 0804 48329FE5 		ldr	r3, .L144+64
 1352 0808 001083E5 		str	r1, [r3, #0]
 1353              	.L110:
 1354              	.LBB220:
 1355              	.LBB221:
 1356              		.loc 2 586 0
 1357 080c C33015E5 		ldr	r3, [r5, #-195]
 1358              	.LBE221:
 1359              	.LBE220:
 850:load_cell.c   ****         }
 851:load_cell.c   **** 
 852:load_cell.c   ****         if ( (AT91F_PIO_GetInput(AT91C_BASE_PIOA) & SW2_MASK) == 0 )
 1360              		.loc 1 852 0
 1361 0810 010613E3 		tst	r3, #1048576
 1362 0814 0C02001A 		bne	.L112
 1363              	.LBB222:
 1364              	.LBB223:
 1365              		.loc 2 620 0
 1366 0818 0248A0E3 		mov	r4, #131072
 1367              	.LBE223:
 1368              	.LBE222:
 853:load_cell.c   ****         {
 854:load_cell.c   ****             AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED_YELLOW);
 855:load_cell.c   ****             printTrace("CLEARING SD CARD...\r\n");
 1369              		.loc 1 855 0
 1370 081c 34029FE5 		ldr	r0, .L144+68
 1371              	.LBB224:
 1372              	.LBB225:
 1373              		.loc 2 620 0
 1374 0820 CB4005E5 		str	r4, [r5, #-203]
 1375              	.LBE225:
 1376              	.LBE224:
 1377              		.loc 1 855 0
 1378 0824 FEFFFFEB 		bl	printTrace
 856:load_cell.c   ****             clearMMCCard();
 1379              		.loc 1 856 0
 1380 0828 FEFFFFEB 		bl	clearMMCCard
 857:load_cell.c   ****             printTrace("CLEARING DONE\r\n");
 1381              		.loc 1 857 0
 1382 082c 28029FE5 		ldr	r0, .L144+72
 1383 0830 FEFFFFEB 		bl	printTrace
 1384              	.LBB226:
 1385              	.LBB227:
 1386              		.loc 2 609 0
 1387 0834 CF4005E5 		str	r4, [r5, #-207]
 1388              	.L112:
 1389              	.LBE227:
 1390              	.LBE226:
 858:load_cell.c   ****             AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED_YELLOW);
 859:load_cell.c   ****         }
 860:load_cell.c   **** 
 861:load_cell.c   ****         if (CDC == 1)
 1391              		.loc 1 861 0
 1392 0838 F4319FE5 		ldr	r3, .L144+32
 1393 083c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1394 0840 010053E3 		cmp	r3, #1
 1395 0844 1802001A 		bne	.L114
 862:load_cell.c   ****         {
 863:load_cell.c   ****             length = pCDC.Read(&pCDC, data, MSG_SIZE);
 1396              		.loc 1 863 0
 1397 0848 D8319FE5 		ldr	r3, .L144+20
 1398 084c 04108DE2 		add	r1, sp, #4
 1399 0850 041041E2 		sub	r1, r1, #4
 1400 0854 0300A0E1 		mov	r0, r3
 1401 0858 FA2FA0E3 		mov	r2, #1000
 1402 085c 0FE0A0E1 		mov	lr, pc
 1403 0860 14F093E5 		ldr	pc, [r3, #20]
 1404 0864 00B0A0E1 		mov	fp, r0
 1405              	.L114:
 864:load_cell.c   ****         }
 865:load_cell.c   **** 
 866:load_cell.c   ****         if (length > 0)
 1406              		.loc 1 866 0
 1407 0868 00005BE3 		cmp	fp, #0
 867:load_cell.c   ****         {
 868:load_cell.c   ****             parseSettings(data);
 1408              		.loc 1 868 0
 1409 086c 04008D12 		addne	r0, sp, #4
 1410 0870 04004012 		subne	r0, r0, #4
 1411 0874 FEFFFF1B 		blne	parseSettings
 1412              	.L116:
 1413 0878 0020A0E3 		mov	r2, #0
 1414              	.LVL36:
 1415              	.L118:
 1416              	.LBB228:
 869:load_cell.c   ****         }
 870:load_cell.c   ****         for(int r = 0; r < MSG_SIZE; r++)
 871:load_cell.c   ****         {
 872:load_cell.c   ****             data[r] = '\0';
 1417              		.loc 1 872 0
 1418 087c 04308DE2 		add	r3, sp, #4
 1419 0880 043043E2 		sub	r3, r3, #4
 1420 0884 0070A0E3 		mov	r7, #0
 1421 0888 0370C2E7 		strb	r7, [r2, r3]
 1422              		.loc 1 870 0
 1423 088c 012082E2 		add	r2, r2, #1
 1424 0890 FA0F52E3 		cmp	r2, #1000
 1425 0894 1D02001A 		bne	.L118
 1426              	.LBE228:
 873:load_cell.c   ****         }
 874:load_cell.c   **** /*
 875:load_cell.c   ****         if (aatDiag == 0)
 876:load_cell.c   ****         {
 877:load_cell.c   ****             if (reading == 1)
 878:load_cell.c   ****             {
 879:load_cell.c   ****                 if (dataReading == 0)
 880:load_cell.c   ****                 {
 881:load_cell.c   ****                     sprintf((char *)res,"PRESSURE: %d\r\n", pressure);
 882:load_cell.c   ****                     printTrace(res);
 883:load_cell.c   ****                     sprintf((char *)pos,"POSITION: %d\r\n", position);
 884:load_cell.c   ****                     printTrace(pos);
 885:load_cell.c   ****                 }
 886:load_cell.c   ****                 if (dataReading == 1)
 887:load_cell.c   ****                 {
 888:load_cell.c   ****                     sprintf((char *)res,"%d|%d|%d|\r\n", pressure, position, direction);
 889:load_cell.c   ****                     pCDC.Write(&pCDC, res, strlen(res));
 890:load_cell.c   ****                 }
 891:load_cell.c   ****             }
 892:load_cell.c   ****         }
 893:load_cell.c   ****         else
 894:load_cell.c   ****         {
 895:load_cell.c   ****             sprintf((char *)res,"%d|%d|%d|\r\n", pressure, position, direction);
 896:load_cell.c   ****             pCDC.Write(&pCDC, res, strlen(res));
 897:load_cell.c   ****         }
 898:load_cell.c   **** */
 899:load_cell.c   ****         /*Load cell test*/
 900:load_cell.c   ****         if (averager > 4)
 1427              		.loc 1 900 0
 1428 0898 C0919FE5 		ldr	r9, .L144+76
 1429 089c 001099E5 		ldr	r1, [r9, #0]
 1430 08a0 040051E3 		cmp	r1, #4
 1431 08a4 98A19FE5 		ldr	sl, .L144+48
 1432 08a8 B4819FE5 		ldr	r8, .L144+80
 1433 08ac 7C0200DA 		ble	.L120
 901:load_cell.c   ****         {
 902:load_cell.c   ****             pressure = round(averager_force / averager);
 1434              		.loc 1 902 0
 1435 08b0 000098E5 		ldr	r0, [r8, #0]
 1436 08b4 FEFFFFEB 		bl	__divsi3
 1437              	.LVL37:
 1438 08b8 FEFFFFEB 		bl	__floatsidf
 1439 08bc FEFFFFEB 		bl	round
 1440 08c0 FEFFFFEB 		bl	__fixdfsi
 903:load_cell.c   ****             //sprintf((char *)res,"LOAD:%d\r\n", pressure);
 904:load_cell.c   ****             //pCDC.Write(&pCDC, res, strlen(res));
 905:load_cell.c   ****             pos[strlen(pos)] = '\0';
 1441              		.loc 1 905 0
 1442 08c4 9C419FE5 		ldr	r4, .L144+84
 1443              		.loc 1 902 0
 1444 08c8 0050A0E1 		mov	r5, r0
 1445 08cc 00008AE5 		str	r0, [sl, #0]
 1446              		.loc 1 905 0
 1447 08d0 0400A0E1 		mov	r0, r4
 1448 08d4 FEFFFFEB 		bl	strlen
 906:load_cell.c   ****             res[strlen(res)] = '\0';
 1449              		.loc 1 906 0
 1450 08d8 8C619FE5 		ldr	r6, .L144+88
 1451              		.loc 1 905 0
 1452 08dc 0070C4E7 		strb	r7, [r4, r0]
 1453              		.loc 1 906 0
 1454 08e0 0600A0E1 		mov	r0, r6
 1455 08e4 FEFFFFEB 		bl	strlen
 907:load_cell.c   ****             averager = 0;
 908:load_cell.c   ****             averager_force = 0;
 909:load_cell.c   **** 
 910:load_cell.c   ****             pressure = pressure - set_zero;
 1456              		.loc 1 910 0
 1457 08e8 64319FE5 		ldr	r3, .L144+64
 1458 08ec 002093E5 		ldr	r2, [r3, #0]
 911:load_cell.c   **** 
 912:load_cell.c   ****             if (test_read == 0)
 1459              		.loc 1 912 0
 1460 08f0 54319FE5 		ldr	r3, .L144+56
 1461 08f4 004093E5 		ldr	r4, [r3, #0]
 1462              		.loc 1 910 0
 1463 08f8 052062E0 		rsb	r2, r2, r5
 1464              		.loc 1 912 0
 1465 08fc 070054E1 		cmp	r4, r7
 1466              		.loc 1 906 0
 1467 0900 0070C6E7 		strb	r7, [r6, r0]
 1468              		.loc 1 908 0
 1469 0904 007088E5 		str	r7, [r8, #0]
 1470              		.loc 1 907 0
 1471 0908 007089E5 		str	r7, [r9, #0]
 1472              		.loc 1 910 0
 1473 090c 00208AE5 		str	r2, [sl, #0]
 1474              		.loc 1 912 0
 1475 0910 7402001A 		bne	.L122
 913:load_cell.c   ****             {
 914:load_cell.c   ****                 if (storingOnMMC == 1)
 1476              		.loc 1 914 0
 1477 0914 34319FE5 		ldr	r3, .L144+60
 1478 0918 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1479 091c 010053E3 		cmp	r3, #1
 1480 0920 EF01001A 		bne	.L143
 915:load_cell.c   ****                 {
 916:load_cell.c   ****                     sprintf(str, "%d", pressure);
 1481              		.loc 1 916 0
 1482 0924 4B0E8DE2 		add	r0, sp, #1200
 1483 0928 40119FE5 		ldr	r1, .L144+92
 1484 092c 020080E2 		add	r0, r0, #2
 1485 0930 FEFFFFEB 		bl	sprintf
 1486 0934 4F0200EA 		b	.L125
 1487              	.LVL38:
 1488              	.L126:
 1489              	.LBB229:
 917:load_cell.c   ****                     for (int i = 0; i < strlen(str); i++)
 918:load_cell.c   ****                     {
 919:load_cell.c   ****                         putCharToMMCBuffer(str[i]);
 1490              		.loc 1 919 0
 1491 0938 0500D4E7 		ldrb	r0, [r4, r5]	@ zero_extendqisi2
 1492 093c FEFFFFEB 		bl	putCharToMMCBuffer
 1493              		.loc 1 917 0
 1494 0940 014084E2 		add	r4, r4, #1
 1495              	.L125:
 1496 0944 4B5E8DE2 		add	r5, sp, #1200
 1497 0948 025085E2 		add	r5, r5, #2
 1498 094c 0500A0E1 		mov	r0, r5
 1499 0950 FEFFFFEB 		bl	strlen
 1500 0954 000054E1 		cmp	r4, r0
 1501 0958 4C02003A 		bcc	.L126
 1502              	.LBE229:
 920:load_cell.c   ****                     }
 921:load_cell.c   ****                     putCharToMMCBuffer('|');
 922:load_cell.c   **** 
 923:load_cell.c   ****                     if (green_led_off < 50)
 1503              		.loc 1 923 0
 1504 095c 10519FE5 		ldr	r5, .L144+96
 1505              		.loc 1 921 0
 1506 0960 7C00A0E3 		mov	r0, #124
 1507 0964 FEFFFFEB 		bl	putCharToMMCBuffer
 1508              		.loc 1 923 0
 1509 0968 003095E5 		ldr	r3, [r5, #0]
 1510 096c 310053E3 		cmp	r3, #49
 1511 0970 630200CA 		bgt	.L128
 1512              	.LBB230:
 1513              	.LBB231:
 1514              		.loc 2 620 0
 1515 0974 0B3CE0E3 		mvn	r3, #2816
 1516 0978 0127A0E3 		mov	r2, #262144
 1517 097c CB2003E5 		str	r2, [r3, #-203]
 1518              	.LBE231:
 1519              	.LBE230:
 924:load_cell.c   ****                     {
 925:load_cell.c   ****                         AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, LED_GREEN);
 926:load_cell.c   ****                         setForce(80000);
 1520              		.loc 1 926 0
 1521 0980 F0009FE5 		ldr	r0, .L144+100
 1522 0984 FEFFFFEB 		bl	setForce
 927:load_cell.c   ****                         green_led_off++;
 1523              		.loc 1 927 0
 1524 0988 003095E5 		ldr	r3, [r5, #0]
 1525 098c 013083E2 		add	r3, r3, #1
 1526 0990 720200EA 		b	.L142
 1527              	.L128:
 928:load_cell.c   ****                     }
 929:load_cell.c   ****                     else
 930:load_cell.c   ****                     {
 931:load_cell.c   ****                         if (green_led_on < 50)
 1528              		.loc 1 931 0
 1529 0994 E0409FE5 		ldr	r4, .L144+104
 1530              	.LVL39:
 1531 0998 003094E5 		ldr	r3, [r4, #0]
 1532 099c 310053E3 		cmp	r3, #49
 932:load_cell.c   ****                         {
 933:load_cell.c   ****                             AT91F_PIO_SetOutput( AT91C_BASE_PIOA, LED_GREEN);
 934:load_cell.c   ****                             setForce(0);
 935:load_cell.c   ****                             green_led_on++;
 936:load_cell.c   ****                         }
 937:load_cell.c   ****                         else
 938:load_cell.c   ****                         {
 939:load_cell.c   ****                             green_led_off = 0;
 1533              		.loc 1 939 0
 1534 09a0 0030A0C3 		movgt	r3, #0
 940:load_cell.c   ****                             green_led_on = 0;
 1535              		.loc 1 940 0
 1536 09a4 003084C5 		strgt	r3, [r4, #0]
 1537              		.loc 1 931 0
 1538 09a8 720200CA 		bgt	.L142
 1539              	.LBB232:
 1540              	.LBB233:
 1541              		.loc 2 609 0
 1542 09ac 0B3CE0E3 		mvn	r3, #2816
 1543 09b0 0127A0E3 		mov	r2, #262144
 1544 09b4 CF2003E5 		str	r2, [r3, #-207]
 1545              	.LBE233:
 1546              	.LBE232:
 1547              		.loc 1 934 0
 1548 09b8 0000A0E3 		mov	r0, #0
 1549 09bc FEFFFFEB 		bl	setForce
 1550              		.loc 1 935 0
 1551 09c0 003094E5 		ldr	r3, [r4, #0]
 1552 09c4 013083E2 		add	r3, r3, #1
 1553 09c8 003084E5 		str	r3, [r4, #0]
 1554 09cc EF0100EA 		b	.L143
 1555              	.LVL40:
 1556              	.L142:
 1557              		.loc 1 939 0
 1558 09d0 003085E5 		str	r3, [r5, #0]
 1559 09d4 EF0100EA 		b	.L143
 1560              	.LVL41:
 1561              	.L122:
 941:load_cell.c   ****                         }
 942:load_cell.c   ****                     }
 943:load_cell.c   ****                 }
 944:load_cell.c   ****             }
 945:load_cell.c   ****             else
 946:load_cell.c   ****             {
 947:load_cell.c   ****                 sprintf(str, "%d\n", pressure);
 1562              		.loc 1 947 0
 1563 09d8 4B4E8DE2 		add	r4, sp, #1200
 1564 09dc 024084E2 		add	r4, r4, #2
 1565 09e0 0400A0E1 		mov	r0, r4
 1566 09e4 94109FE5 		ldr	r1, .L144+108
 1567 09e8 FEFFFFEB 		bl	sprintf
 948:load_cell.c   ****                 printTrace(str);
 1568              		.loc 1 948 0
 1569 09ec 0400A0E1 		mov	r0, r4
 1570 09f0 FEFFFFEB 		bl	printTrace
 1571 09f4 EF0100EA 		b	.L143
 1572              	.LVL42:
 1573              	.L120:
 949:load_cell.c   ****             }
 950:load_cell.c   ****         }
 951:load_cell.c   ****         else
 952:load_cell.c   ****         {
 953:load_cell.c   ****             averager++;
 954:load_cell.c   ****             averager_force += pressure;
 1574              		.loc 1 954 0
 1575 09f8 00309AE5 		ldr	r3, [sl, #0]
 1576 09fc 002098E5 		ldr	r2, [r8, #0]
 1577              	.LVL43:
 1578 0a00 032082E0 		add	r2, r2, r3
 1579              		.loc 1 953 0
 1580 0a04 013081E2 		add	r3, r1, #1
 1581 0a08 003089E5 		str	r3, [r9, #0]
 1582              		.loc 1 954 0
 1583 0a0c 002088E5 		str	r2, [r8, #0]
 1584 0a10 EF0100EA 		b	.L143
 1585              	.L145:
 1586              		.align	2
 1587              	.L144:
 1588 0a14 00000000 		.word	mmc_buffer
 1589 0a18 00014800 		.word	4718848
 1590 0a1c 010400A5 		.word	-1526725631
 1591 0a20 F8000600 		.word	393464
 1592 0a24 409C0000 		.word	40000
 1593 0a28 00000000 		.word	pCDC
 1594 0a2c A0252600 		.word	2500000
 1595 0a30 9F252600 		.word	2499999
 1596 0a34 00000000 		.word	CDC
 1597 0a38 80FF1100 		.word	1179520
 1598 0a3c 00000000 		.word	settings
 1599 0a40 D4000000 		.word	.LC17
 1600 0a44 00000000 		.word	pressure
 1601 0a48 00000000 		.word	position
 1602 0a4c 00000000 		.word	test_read
 1603 0a50 00000000 		.word	storingOnMMC
 1604 0a54 00000000 		.word	set_zero
 1605 0a58 A0000000 		.word	.LC15
 1606 0a5c B8000000 		.word	.LC16
 1607 0a60 00000000 		.word	averager
 1608 0a64 00000000 		.word	averager_force
 1609 0a68 00000000 		.word	pos
 1610 0a6c 00000000 		.word	res
 1611 0a70 CC000000 		.word	.LC18
 1612 0a74 00000000 		.word	green_led_off
 1613 0a78 80380100 		.word	80000
 1614 0a7c 00000000 		.word	green_led_on
 1615 0a80 D0000000 		.word	.LC19
 1616              	.LFE302:
 1618              		.align	2
 1619              		.global	setPosition
 1621              	setPosition:
 1622              	.LFB297:
 1623              		.loc 1 232 0
 1624              		@ args = 0, pretend = 0, frame = 0
 1625              		@ frame_needed = 0, uses_anonymous_args = 0
 1626              	.LVL44:
 1627 0a84 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1628              	.LCFI16:
 1629              		.loc 1 234 0
 1630 0a88 64509FE5 		ldr	r5, .L154
 1631 0a8c 64609FE5 		ldr	r6, .L154+4
 1632              		.loc 1 232 0
 1633 0a90 0040A0E1 		mov	r4, r0
 1634              		.loc 1 233 0
 1635 0a94 FEFFFFEB 		bl	setForce
 1636              	.LVL45:
 1637              		.loc 1 234 0
 1638 0a98 001095E5 		ldr	r1, [r5, #0]
 1639 0a9c 002096E5 		ldr	r2, [r6, #0]
 1640 0aa0 013062E0 		rsb	r3, r2, r1
 1641 0aa4 000053E3 		cmp	r3, #0
 1642 0aa8 003063B2 		rsblt	r3, r3, #0
 1643 0aac 050053E3 		cmp	r3, #5
 1644              	.LBB240:
 1645              	.LBB241:
 1646              	.LBB242:
 1647              	.LBB243:
 1648              		.loc 2 620 0
 1649 0ab0 0B0CE0E3 		mvn	r0, #2816
 1650              	.LBE243:
 1651              	.LBE242:
 1652              	.LBE241:
 1653              	.LBE240:
 1654              		.loc 1 234 0
 1655 0ab4 B60200DA 		ble	.L147
 1656              		.loc 1 236 0
 1657 0ab8 020051E1 		cmp	r1, r2
 1658              		.loc 1 238 0
 1659 0abc 0400A0E1 		mov	r0, r4
 1660              		.loc 1 236 0
 1661              	.LVL46:
 1662              		.loc 1 238 0
 1663 0ac0 FEFFFFCB 		blgt	lowerDown
 1664              	.LVL47:
 1665              	.L149:
 1666              		.loc 1 240 0
 1667 0ac4 002095E5 		ldr	r2, [r5, #0]
 1668 0ac8 003096E5 		ldr	r3, [r6, #0]
 1669 0acc 030052E1 		cmp	r2, r3
 1670              		.loc 1 242 0
 1671 0ad0 0400A0E1 		mov	r0, r4
 1672              		.loc 1 240 0
 1673 0ad4 7080BDA8 		ldmgefd	sp!, {r4, r5, r6, pc}
 1674              	.LVL48:
 1675              		.loc 1 249 0
 1676 0ad8 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1677              		.loc 1 242 0
 1678 0adc FEFFFFEA 		b	liftUp
 1679              	.LVL49:
 1680              	.L147:
 1681              	.LBB244:
 1682              	.LBB245:
 1683              	.LBB246:
 1684              	.LBB247:
 1685              		.loc 2 620 0
 1686 0ae0 8030A0E3 		mov	r3, #128
 1687 0ae4 CB3000E5 		str	r3, [r0, #-203]
 1688              	.LBE247:
 1689              	.LBE246:
 1690              	.LBB248:
 1691              	.LBB249:
 1692 0ae8 4030A0E3 		mov	r3, #64
 1693 0aec CB3000E5 		str	r3, [r0, #-203]
 1694 0af0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1695              	.L155:
 1696              		.align	2
 1697              	.L154:
 1698 0af4 00000000 		.word	curPos
 1699 0af8 00000000 		.word	position
 1700              	.LBE249:
 1701              	.LBE248:
 1702              	.LBE245:
 1703              	.LBE244:
 1704              	.LFE297:
 1706              		.global	LedSpeed
 1707              		.data
 1708              		.align	2
 1711              	LedSpeed:
 1712 0000 F0A70300 		.word	239600
 1713              		.global	maxPos
 1714              		.align	2
 1717              	maxPos:
 1718 0004 84030000 		.word	900
 1719              		.global	minPos
 1720              		.align	2
 1723              	minPos:
 1724 0008 2C010000 		.word	300
 1725              		.global	curPos
 1726              		.align	2
 1729              	curPos:
 1730 000c 58020000 		.word	600
 1731              		.global	maxForce
 1732              		.align	2
 1735              	maxForce:
 1736 0010 A0860100 		.word	100000
 1737              		.global	minForce
 1738              		.align	2
 1741              	minForce:
 1742 0014 D0010100 		.word	66000
 1743              		.global	curForce
 1744              		.align	2
 1747              	curForce:
 1748 0018 D0010100 		.word	66000
 1749              		.global	reading
 1750              		.bss
 1753              	reading:
 1754 0000 00       		.space	1
 1755              		.global	dataReading
 1758              	dataReading:
 1759 0001 00       		.space	1
 1760              		.global	aatDiag
 1763              	aatDiag:
 1764 0002 00       		.space	1
 1765              		.global	aatDiagStep
 1768              	aatDiagStep:
 1769 0003 00       		.space	1
 1770              		.global	minDiagForce
 1771              		.data
 1772              		.align	2
 1775              	minDiagForce:
 1776 001c 905F0100 		.word	90000
 1777              		.global	lockDiagForce
 1778              		.align	2
 1781              	lockDiagForce:
 1782 0020 A0860100 		.word	100000
 1783              		.global	lockDiagPressure
 1784              		.bss
 1785              		.align	2
 1788              	lockDiagPressure:
 1789 0004 00000000 		.space	4
 1790              		.global	diagForce
 1791              		.data
 1792              		.align	2
 1795              	diagForce:
 1796 0024 80380100 		.word	80000
 1797              		.global	averager
 1798              		.bss
 1799              		.align	2
 1802              	averager:
 1803 0008 00000000 		.space	4
 1804              		.global	averager_force
 1805              		.align	2
 1808              	averager_force:
 1809 000c 00000000 		.space	4
 1810              		.global	test_read
 1811              		.align	2
 1814              	test_read:
 1815 0010 00000000 		.space	4
 1816              		.global	set_zero
 1817              		.align	2
 1820              	set_zero:
 1821 0014 00000000 		.space	4
 1822              		.global	green_led_off
 1823              		.align	2
 1826              	green_led_off:
 1827 0018 00000000 		.space	4
 1828              		.global	green_led_on
 1829              		.align	2
 1832              	green_led_on:
 1833 001c 00000000 		.space	4
 1834              		.global	CDC
 1837              	CDC:
 1838 0020 00       		.space	1
 1839              		.global	mmc_buffer_index
 1840 0021 000000   		.align	2
 1843              	mmc_buffer_index:
 1844 0024 00000000 		.space	4
 1845              		.global	mmc_block_index
 1846              		.align	2
 1849              	mmc_block_index:
 1850 0028 00000000 		.space	4
 1851              		.global	storingOnMMC
 1854              	storingOnMMC:
 1855 002c 00       		.space	1
 1856              		.comm	res,1000,1
 1857              		.comm	pos,1000,1
 1858              		.comm	cmd,1000,1
 1859              		.comm	msg,1000,1
 1860              		.comm	settings,128,1
 1861              		.comm	pressure,4,4
 1862              		.comm	position,4,4
 1863              		.comm	direction,4,4
 1864              		.comm	mmc_buffer_out,512,1
 1865              		.comm	pCDC,24,4
 2166              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 load_cell.c
     /tmp/cczXiQqp.s:13     .text:00000000 flashInit
     /tmp/cczXiQqp.s:20     .text:00000000 $a
     /tmp/cczXiQqp.s:39     .text:00000020 $d
     /tmp/cczXiQqp.s:45     .text:00000024 Delay
     /tmp/cczXiQqp.s:52     .text:00000024 $a
     /tmp/cczXiQqp.s:77     .text:00000050 printTrace
     /tmp/cczXiQqp.s:113    .text:00000098 $d
     /tmp/cczXiQqp.s:1758   .bss:00000001 dataReading
     /tmp/cczXiQqp.s:1837   .bss:00000020 CDC
                            *COM*:00000018 pCDC
     /tmp/cczXiQqp.s:121    .text:000000a4 clearMMCCard
     /tmp/cczXiQqp.s:126    .text:000000a4 $a
     /tmp/cczXiQqp.s:163    .text:00000104 $d
     /tmp/cczXiQqp.s:170    .text:00000108 putCharToMMCBuffer
     /tmp/cczXiQqp.s:177    .text:00000108 $a
     /tmp/cczXiQqp.s:229    .text:00000174 $d
     /tmp/cczXiQqp.s:1843   .bss:00000024 mmc_buffer_index
     /tmp/cczXiQqp.s:1849   .bss:00000028 mmc_block_index
     /tmp/cczXiQqp.s:237    .text:00000180 AT91F_USB_Open
     /tmp/cczXiQqp.s:243    .text:00000180 $a
     /tmp/cczXiQqp.s:291    .text:000001c8 $d
     /tmp/cczXiQqp.s:298    .text:000001d0 blinkingGreen
     /tmp/cczXiQqp.s:304    .text:000001d0 $a
     /tmp/cczXiQqp.s:336    .text:000001f8 clearLEDs
     /tmp/cczXiQqp.s:376    .text:00000218 releasePosition
     /tmp/cczXiQqp.s:410    .text:00000230 startBlinking
     /tmp/cczXiQqp.s:557    .text:00000290 parseSettings
     /tmp/cczXiQqp.s:763    .text:00000488 $d
     /tmp/cczXiQqp.s:1814   .bss:00000010 test_read
                            *COM*:00000004 pressure
     /tmp/cczXiQqp.s:1820   .bss:00000014 set_zero
     /tmp/cczXiQqp.s:1854   .bss:0000002c storingOnMMC
     /tmp/cczXiQqp.s:793    .text:000004ec setForce
     /tmp/cczXiQqp.s:803    .text:000004ec $a
     /tmp/cczXiQqp.s:851    .text:0000051c $d
     /tmp/cczXiQqp.s:859    .text:00000528 lowerDown
     /tmp/cczXiQqp.s:865    .text:00000528 $a
     /tmp/cczXiQqp.s:894    .text:00000554 $d
                            *COM*:00000004 direction
     /tmp/cczXiQqp.s:900    .text:00000558 liftUp
     /tmp/cczXiQqp.s:906    .text:00000558 $a
     /tmp/cczXiQqp.s:935    .text:00000584 $d
     /tmp/cczXiQqp.s:941    .text:00000588 Init_PWM
     /tmp/cczXiQqp.s:949    .text:00000588 $a
     /tmp/cczXiQqp.s:1078   .text:00000604 $d
     /tmp/cczXiQqp.s:1102   .text:00000618 main
     /tmp/cczXiQqp.s:1107   .text:00000618 $a
     /tmp/cczXiQqp.s:1588   .text:00000a14 $d
                            *COM*:00000080 settings
                            *COM*:00000004 position
     /tmp/cczXiQqp.s:1802   .bss:00000008 averager
     /tmp/cczXiQqp.s:1808   .bss:0000000c averager_force
                            *COM*:000003e8 pos
                            *COM*:000003e8 res
     /tmp/cczXiQqp.s:1826   .bss:00000018 green_led_off
     /tmp/cczXiQqp.s:1832   .bss:0000001c green_led_on
     /tmp/cczXiQqp.s:1621   .text:00000a84 setPosition
     /tmp/cczXiQqp.s:1627   .text:00000a84 $a
     /tmp/cczXiQqp.s:1698   .text:00000af4 $d
     /tmp/cczXiQqp.s:1729   .data:0000000c curPos
     /tmp/cczXiQqp.s:1711   .data:00000000 LedSpeed
     /tmp/cczXiQqp.s:1712   .data:00000000 $d
     /tmp/cczXiQqp.s:1717   .data:00000004 maxPos
     /tmp/cczXiQqp.s:1723   .data:00000008 minPos
     /tmp/cczXiQqp.s:1735   .data:00000010 maxForce
     /tmp/cczXiQqp.s:1741   .data:00000014 minForce
     /tmp/cczXiQqp.s:1747   .data:00000018 curForce
     /tmp/cczXiQqp.s:1753   .bss:00000000 reading
     /tmp/cczXiQqp.s:1763   .bss:00000002 aatDiag
     /tmp/cczXiQqp.s:1768   .bss:00000003 aatDiagStep
     /tmp/cczXiQqp.s:1775   .data:0000001c minDiagForce
     /tmp/cczXiQqp.s:1781   .data:00000020 lockDiagForce
     /tmp/cczXiQqp.s:1788   .bss:00000004 lockDiagPressure
     /tmp/cczXiQqp.s:1795   .data:00000024 diagForce
                            *COM*:000003e8 cmd
                            *COM*:000003e8 msg
                            *COM*:00000200 mmc_buffer_out

UNDEFINED SYMBOLS
strlen
initMMC
memset
mmcReadRegister
mmcWriteBlock
mmc_buffer
mmcReadBlock
AT91F_CDC_Open
strtok
strcmp
__divsi3
__floatsidf
__fixdfsi
Init_CP_WP
memcpy
InitADC
GetValue_chanel6
GetValue_chanel5
round
sprintf
